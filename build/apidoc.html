<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/newrelic/node-newrelic"

    >newrelic (v1.38.2)</a>
</h1>
<h4>New Relic agent</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic">module newrelic</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent">
            function <span class="apidocSignatureSpan">newrelic.</span>agent
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator">
            function <span class="apidocSignatureSpan">newrelic.</span>aggregator
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.apdex">
            function <span class="apidocSignatureSpan">newrelic.</span>apdex
            <span class="apidocSignatureSpan">(apdexT)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api">
            function <span class="apidocSignatureSpan">newrelic.</span>api
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aws_info">
            function <span class="apidocSignatureSpan">newrelic.</span>aws_info
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config">
            function <span class="apidocSignatureSpan">newrelic.</span>config
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.label_parser">
            function <span class="apidocSignatureSpan">newrelic.</span>label_parser
            <span class="apidocSignatureSpan">(labels)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.mapper">
            function <span class="apidocSignatureSpan">newrelic.</span>mapper
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state">
            function <span class="apidocSignatureSpan">newrelic.</span>name_state
            <span class="apidocSignatureSpan">(prefix, verb, delimiter, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.normalizer">
            function <span class="apidocSignatureSpan">newrelic.</span>normalizer
            <span class="apidocSignatureSpan">(config, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.parsed_statement">
            function <span class="apidocSignatureSpan">newrelic.</span>parsed_statement
            <span class="apidocSignatureSpan">(type, operation, model, raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method">
            function <span class="apidocSignatureSpan">newrelic.</span>remote_method
            <span class="apidocSignatureSpan">(name, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir">
            function <span class="apidocSignatureSpan">newrelic.</span>reservoir
            <span class="apidocSignatureSpan">(limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.rule">
            function <span class="apidocSignatureSpan">newrelic.</span>rule
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment">
            function <span class="apidocSignatureSpan">newrelic.</span>segment
            <span class="apidocSignatureSpan">(transaction, name, recorder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.statement_matcher">
            function <span class="apidocSignatureSpan">newrelic.</span>statement_matcher
            <span class="apidocSignatureSpan">(operation, operationPattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stream_sink">
            function <span class="apidocSignatureSpan">newrelic.</span>stream_sink
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api">
            function <span class="apidocSignatureSpan">newrelic.</span>stub_api
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info">
            function <span class="apidocSignatureSpan">newrelic.</span>system_info
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer">
            function <span class="apidocSignatureSpan">newrelic.</span>timer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tracer">
            function <span class="apidocSignatureSpan">newrelic.</span>tracer
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tx_segment">
            function <span class="apidocSignatureSpan">newrelic.</span>tx_segment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>agent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>aggregator.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>apdex.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>api.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>arrays</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>cat</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>codec</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>config.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>copy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>environment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>express_2</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>hashes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>http_agents</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>mapper.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>name_state.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>normalizer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>parsed_statement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>remote_method.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>reservoir.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>rule.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>safe_json</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>sampler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>segment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>shimmer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>statement_matcher.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>stream_sink.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>stub_api.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>timer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>tracer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>tx_segment.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>uninstrumented</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>urltils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.agent">module newrelic.agent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.agent">
            function <span class="apidocSignatureSpan">newrelic.</span>agent
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.super_">
            function <span class="apidocSignatureSpan">newrelic.agent.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.agent.prototype">module newrelic.agent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._addEventFromTransaction">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_addEventFromTransaction
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._addIntrinsicAttrsFromTransaction">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_addIntrinsicAttrsFromTransaction
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._apdexTChange">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_apdexTChange
            <span class="apidocSignatureSpan">(apdexT)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._configChange">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_configChange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._enabledChange">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_enabledChange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._harvesterIntervalChange">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_harvesterIntervalChange
            <span class="apidocSignatureSpan">(interval, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._processCustomEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_processCustomEvents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._processErrorEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_processErrorEvents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._restartHarvester">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_restartHarvester
            <span class="apidocSignatureSpan">(harvestSeconds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendCustomEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendCustomEvents
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendErrorEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendErrorEvents
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendErrors">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendErrors
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendEvents
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendMetrics">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendMetrics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendQueries">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendQueries
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendTrace">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendTrace
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._setupTracer">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_setupTracer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._startHarvester">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_startHarvester
            <span class="apidocSignatureSpan">(harvestSeconds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._stopHarvester">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_stopHarvester
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._transactionFinished">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_transactionFinished
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.getTransaction">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>getTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.harvest">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>harvest
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.reconfigure">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>reconfigure
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.reset">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.setState">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>setState
            <span class="apidocSignatureSpan">(newState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.start">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>start
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.stop">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>stop
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.aggregator">module newrelic.aggregator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.aggregator">
            function <span class="apidocSignatureSpan">newrelic.</span>aggregator
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.aggregator.prototype">module newrelic.aggregator.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype._collect">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>_collect
            <span class="apidocSignatureSpan">(transaction, exception, customParameters, timestamp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.add">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>add
            <span class="apidocSignatureSpan">(transaction, exception, customParameters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.addUserError">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>addUserError
            <span class="apidocSignatureSpan">(transaction, exception, customParameters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.clearErrors">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>clearErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.clearEvents">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>clearEvents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.getBackgroundTransactionsErrorCount">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getBackgroundTransactionsErrorCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.getErrors">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.getEvents">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getEvents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.getEventsLimit">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getEventsLimit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.getEventsSeen">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getEventsSeen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.getTotalErrorCount">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getTotalErrorCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.getWebTransactionsErrorCount">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getWebTransactionsErrorCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.haveSeen">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>haveSeen
            <span class="apidocSignatureSpan">(transaction, exception)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.merge">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>merge
            <span class="apidocSignatureSpan">(errors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.mergeEvents">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>mergeEvents
            <span class="apidocSignatureSpan">(events)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.onTransactionFinished">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>onTransactionFinished
            <span class="apidocSignatureSpan">(transaction, metrics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aggregator.prototype.reconfigure">
            function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>reconfigure
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.apdex">module newrelic.apdex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.apdex.apdex">
            function <span class="apidocSignatureSpan">newrelic.</span>apdex
            <span class="apidocSignatureSpan">(apdexT)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.apdex.prototype">module newrelic.apdex.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.apdex.prototype.incrementFrustrating">
            function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>incrementFrustrating
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.apdex.prototype.merge">
            function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>merge
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.apdex.prototype.recordValue">
            function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>recordValue
            <span class="apidocSignatureSpan">(time, overrideApdex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.apdex.prototype.recordValueInMillis">
            function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>recordValueInMillis
            <span class="apidocSignatureSpan">(timeInMillis, overrideApdex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.apdex.prototype.toJSON">
            function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.api">module newrelic.api</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.api">
            function <span class="apidocSignatureSpan">newrelic.</span>api
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.api.prototype">module newrelic.api.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.addCustomParameter">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addCustomParameter
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.addCustomParameters">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addCustomParameters
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.addIgnoringRule">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addIgnoringRule
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.addNamingRule">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addNamingRule
            <span class="apidocSignatureSpan">(pattern, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.createBackgroundTransaction">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createBackgroundTransaction
            <span class="apidocSignatureSpan">(name, group, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.createTracer">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createTracer
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.createWebTransaction">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createWebTransaction
            <span class="apidocSignatureSpan">(url, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.endTransaction">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>endTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.getBrowserTimingHeader">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>getBrowserTimingHeader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.incrementMetric">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>incrementMetric
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.noticeError">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>noticeError
            <span class="apidocSignatureSpan">(error, customParameters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.recordCustomEvent">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>recordCustomEvent
            <span class="apidocSignatureSpan">(eventType, attributes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.recordMetric">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>recordMetric
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.setControllerName">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setControllerName
            <span class="apidocSignatureSpan">(name, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.setIgnoreTransaction">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setIgnoreTransaction
            <span class="apidocSignatureSpan">(ignored)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.setTransactionName">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setTransactionName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.shutdown">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>shutdown
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.arrays">module newrelic.arrays</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.arrays.find">
            function <span class="apidocSignatureSpan">newrelic.arrays.</span>find
            <span class="apidocSignatureSpan">(arr, pred, ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.arrays.findIndex">
            function <span class="apidocSignatureSpan">newrelic.arrays.</span>findIndex
            <span class="apidocSignatureSpan">(arr, pred, ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.arrays.findLast">
            function <span class="apidocSignatureSpan">newrelic.arrays.</span>findLast
            <span class="apidocSignatureSpan">(arr, pred, ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.arrays.findLastIndex">
            function <span class="apidocSignatureSpan">newrelic.arrays.</span>findLastIndex
            <span class="apidocSignatureSpan">(arr, pred, ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.aws_info">module newrelic.aws_info</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aws_info.aws_info">
            function <span class="apidocSignatureSpan">newrelic.</span>aws_info
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aws_info._awsQuery">
            function <span class="apidocSignatureSpan">newrelic.aws_info.</span>_awsQuery
            <span class="apidocSignatureSpan">(key, agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aws_info.clearCache">
            function <span class="apidocSignatureSpan">newrelic.aws_info.</span>clearCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.cat">module newrelic.cat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.cat.handleCatHeaders">
            function <span class="apidocSignatureSpan">newrelic.cat.</span>handleCatHeaders
            <span class="apidocSignatureSpan">(incomingCatId, obfTransaction, encKey, transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.cat.parsedHeadersToTrans">
            function <span class="apidocSignatureSpan">newrelic.cat.</span>parsedHeadersToTrans
            <span class="apidocSignatureSpan">(parsedCatId, externalTrans, transaction)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.codec">module newrelic.codec</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.codec.decode">
            function <span class="apidocSignatureSpan">newrelic.codec.</span>decode
            <span class="apidocSignatureSpan">(encoded, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.codec.encode">
            function <span class="apidocSignatureSpan">newrelic.codec.</span>encode
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.common">module newrelic.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.common.ensurePartialName">
            function <span class="apidocSignatureSpan">newrelic.common.</span>ensurePartialName
            <span class="apidocSignatureSpan">(trans)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.config">module newrelic.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.config">
            function <span class="apidocSignatureSpan">newrelic.</span>config
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.getOrCreateInstance">
            function <span class="apidocSignatureSpan">newrelic.config.</span>getOrCreateInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.initialize">
            function <span class="apidocSignatureSpan">newrelic.config.</span>initialize
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.super_">
            function <span class="apidocSignatureSpan">newrelic.config.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.config.prototype">module newrelic.config.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._alwaysUpdateIfChanged">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_alwaysUpdateIfChanged
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._applyHighSecurity">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_applyHighSecurity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._canonicalize">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_canonicalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._emitIfSet">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_emitIfSet
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._fromEnvironment">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromEnvironment
            <span class="apidocSignatureSpan">(metadata, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._fromPassed">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromPassed
            <span class="apidocSignatureSpan">(external, internal, arbitrary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._fromServer">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromServer
            <span class="apidocSignatureSpan">(params, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._fromSpecial">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromSpecial
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._updateIfChanged">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateIfChanged
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._updateNestedIfChanged">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateNestedIfChanged
            <span class="apidocSignatureSpan">(remote, local, remoteKey, localKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._updateNestedIfChangedRaw">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateNestedIfChangedRaw
            <span class="apidocSignatureSpan">( remote, local, remoteKey, localKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.applications">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>applications
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.clearDisplayHostCache">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>clearDisplayHostCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.clearHostnameCache">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>clearHostnameCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.getDisplayHost">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getDisplayHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.getHostnameSafe">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getHostnameSafe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.getIPAddresses">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getIPAddresses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.logDisabled">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logDisabled
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.logUnknown">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logUnknown
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.logUnsupported">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logUnsupported
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.measureInternal">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>measureInternal
            <span class="apidocSignatureSpan">(suffix, duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.onConnect">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>onConnect
            <span class="apidocSignatureSpan">(json, recursion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.publicSettings">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>publicSettings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.setLogger">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>setLogger
            <span class="apidocSignatureSpan">(bootstrapped)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.validateFlags">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>validateFlags
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.copy">module newrelic.copy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.copy.shallow">
            function <span class="apidocSignatureSpan">newrelic.copy.</span>shallow
            <span class="apidocSignatureSpan">(source, dest)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.environment">module newrelic.environment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.clearDispatcher">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>clearDispatcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.clearFramework">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>clearFramework
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.get">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.listPackages">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>listPackages
            <span class="apidocSignatureSpan">(root, packages)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.refresh">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>refresh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.setDispatcher">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>setDispatcher
            <span class="apidocSignatureSpan">(dispatcher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.setFramework">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>setFramework
            <span class="apidocSignatureSpan">(framework)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.toJSON">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.express_2">module newrelic.express_2</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.express_2.wrapMatchRequest">
            function <span class="apidocSignatureSpan">newrelic.express_2.</span>wrapMatchRequest
            <span class="apidocSignatureSpan">(tracer, version, original)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.hashes">module newrelic.hashes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.hashes.calculatePathHash">
            function <span class="apidocSignatureSpan">newrelic.hashes.</span>calculatePathHash
            <span class="apidocSignatureSpan">(appName, pathName, referingPathHash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.hashes.deobfuscateNameUsingKey">
            function <span class="apidocSignatureSpan">newrelic.hashes.</span>deobfuscateNameUsingKey
            <span class="apidocSignatureSpan">(name, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.hashes.getHash">
            function <span class="apidocSignatureSpan">newrelic.hashes.</span>getHash
            <span class="apidocSignatureSpan">(appName, txName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.hashes.obfuscateNameUsingKey">
            function <span class="apidocSignatureSpan">newrelic.hashes.</span>obfuscateNameUsingKey
            <span class="apidocSignatureSpan">(name, key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.http_agents">module newrelic.http_agents</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.http_agents.proxyAgent">
            function <span class="apidocSignatureSpan">newrelic.http_agents.</span>proxyAgent
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.label_parser">module newrelic.label_parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.label_parser.label_parser">
            function <span class="apidocSignatureSpan">newrelic.</span>label_parser
            <span class="apidocSignatureSpan">(labels)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.label_parser.fromMap">
            function <span class="apidocSignatureSpan">newrelic.label_parser.</span>fromMap
            <span class="apidocSignatureSpan">(map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.label_parser.fromString">
            function <span class="apidocSignatureSpan">newrelic.label_parser.</span>fromString
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.mapper">module newrelic.mapper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.mapper.mapper">
            function <span class="apidocSignatureSpan">newrelic.</span>mapper
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.mapper.prototype">module newrelic.mapper.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.mapper.prototype.load">
            function <span class="apidocSignatureSpan">newrelic.mapper.prototype.</span>load
            <span class="apidocSignatureSpan">(raw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.mapper.prototype.map">
            function <span class="apidocSignatureSpan">newrelic.mapper.prototype.</span>map
            <span class="apidocSignatureSpan">(name, scope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.name_state">module newrelic.name_state</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.name_state">
            function <span class="apidocSignatureSpan">newrelic.</span>name_state
            <span class="apidocSignatureSpan">(prefix, verb, delimiter, path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.name_state.prototype">module newrelic.name_state.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.appendPath">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>appendPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.appendPathIfEmpty">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>appendPathIfEmpty
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.getName">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>getName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.getNameNotFound">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>getNameNotFound
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.popPath">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>popPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.reset">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.setDelimiter">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>setDelimiter
            <span class="apidocSignatureSpan">(delimiter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.setName">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>setName
            <span class="apidocSignatureSpan">(prefix, verb, delimiter, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.setPrefix">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>setPrefix
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.name_state.prototype.setVerb">
            function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>setVerb
            <span class="apidocSignatureSpan">(verb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.normalizer">module newrelic.normalizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.normalizer.normalizer">
            function <span class="apidocSignatureSpan">newrelic.</span>normalizer
            <span class="apidocSignatureSpan">(config, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.normalizer.super_">
            function <span class="apidocSignatureSpan">newrelic.normalizer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.normalizer.prototype">module newrelic.normalizer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.normalizer.prototype.addSimple">
            function <span class="apidocSignatureSpan">newrelic.normalizer.prototype.</span>addSimple
            <span class="apidocSignatureSpan">(pattern, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.normalizer.prototype.load">
            function <span class="apidocSignatureSpan">newrelic.normalizer.prototype.</span>load
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.normalizer.prototype.loadFromConfig">
            function <span class="apidocSignatureSpan">newrelic.normalizer.prototype.</span>loadFromConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.normalizer.prototype.normalize">
            function <span class="apidocSignatureSpan">newrelic.normalizer.prototype.</span>normalize
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.parsed_statement">module newrelic.parsed_statement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.parsed_statement.parsed_statement">
            function <span class="apidocSignatureSpan">newrelic.</span>parsed_statement
            <span class="apidocSignatureSpan">(type, operation, model, raw)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.parsed_statement.prototype">module newrelic.parsed_statement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.parsed_statement.prototype.recordMetrics">
            function <span class="apidocSignatureSpan">newrelic.parsed_statement.prototype.</span>recordMetrics
            <span class="apidocSignatureSpan">(segment, scope)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.remote_method">module newrelic.remote_method</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.remote_method">
            function <span class="apidocSignatureSpan">newrelic.</span>remote_method
            <span class="apidocSignatureSpan">(name, config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.remote_method.prototype">module newrelic.remote_method.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype._headers">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_headers
            <span class="apidocSignatureSpan">(body, compressed)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype._path">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_path
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype._post">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_post
            <span class="apidocSignatureSpan">(data, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype._request">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_request
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype._safeRequest">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_safeRequest
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype._shouldCompress">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_shouldCompress
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype._userAgent">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_userAgent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype.invoke">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>invoke
            <span class="apidocSignatureSpan">(payload, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.remote_method.prototype.serialize">
            function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>serialize
            <span class="apidocSignatureSpan">(payload, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.reservoir">module newrelic.reservoir</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.reservoir">
            function <span class="apidocSignatureSpan">newrelic.</span>reservoir
            <span class="apidocSignatureSpan">(limit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.reservoir.prototype">module newrelic.reservoir.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.add">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>add
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.merge">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>merge
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.overflow">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>overflow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.setLimit">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>setLimit
            <span class="apidocSignatureSpan">(newLimit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.toArray">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.rule">module newrelic.rule</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.rule.rule">
            function <span class="apidocSignatureSpan">newrelic.</span>rule
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.rule.prototype">module newrelic.rule.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.rule.prototype.apply">
            function <span class="apidocSignatureSpan">newrelic.rule.prototype.</span>apply
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.rule.prototype.getSegments">
            function <span class="apidocSignatureSpan">newrelic.rule.prototype.</span>getSegments
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.rule.prototype.matches">
            function <span class="apidocSignatureSpan">newrelic.rule.prototype.</span>matches
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.rule.prototype.toJSON">
            function <span class="apidocSignatureSpan">newrelic.rule.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.safe_json">module newrelic.safe_json</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.safe_json.parse">
            function <span class="apidocSignatureSpan">newrelic.safe_json.</span>parse
            <span class="apidocSignatureSpan">(str, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.safe_json.stringify">
            function <span class="apidocSignatureSpan">newrelic.safe_json.</span>stringify
            <span class="apidocSignatureSpan">(obj, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.safe_json.stringifySync">
            function <span class="apidocSignatureSpan">newrelic.safe_json.</span>stringifySync
            <span class="apidocSignatureSpan">(obj, returnVal)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.sampler">module newrelic.sampler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.checkEvents">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>checkEvents
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.sampleCpu">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleCpu
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.sampleGc">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleGc
            <span class="apidocSignatureSpan">(agent, nativeMetrics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.sampleLoop">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleLoop
            <span class="apidocSignatureSpan">(agent, nativeMetrics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.sampleMemory">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleMemory
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.start">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>start
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.stop">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.sampler.</span>nativeMetrics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">newrelic.sampler.</span>state</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.segment">module newrelic.segment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.segment">
            function <span class="apidocSignatureSpan">newrelic.</span>segment
            <span class="apidocSignatureSpan">(transaction, name, recorder)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.segment.prototype">module newrelic.segment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype._getChildPairs">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>_getChildPairs
            <span class="apidocSignatureSpan">(end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype._isEnded">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>_isEnded
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype._setExclusiveDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>_setExclusiveDurationInMillis
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype._updateRootTimer">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>_updateRootTimer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.add">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>add
            <span class="apidocSignatureSpan">(childName, recorder)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.captureDBInstanceAttributes">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>captureDBInstanceAttributes
            <span class="apidocSignatureSpan">(host, port, database)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.end">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.getChildren">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>getChildren
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.getCollectedChildren">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>getCollectedChildren
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.getDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>getDurationInMillis
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.getExclusiveDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>getExclusiveDurationInMillis
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.isInCallbackState">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>isInCallbackState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.markAsWeb">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>markAsWeb
            <span class="apidocSignatureSpan">(rawURL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.moveToCallbackState">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>moveToCallbackState
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.overwriteDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>overwriteDurationInMillis
            <span class="apidocSignatureSpan">(duration, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.probe">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>probe
            <span class="apidocSignatureSpan">(action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.setDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>setDurationInMillis
            <span class="apidocSignatureSpan">(duration, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.start">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.toJSON">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.segment.prototype.touch">
            function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.shimmer">module newrelic.shimmer</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">newrelic.shimmer.</span>debug</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.bootstrapInstrumentation">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>bootstrapInstrumentation
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.isWrapped">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>isWrapped
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.patchModule">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>patchModule
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.reinstrument">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>reinstrument
            <span class="apidocSignatureSpan">(agent, modulePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.unpatchModule">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unpatchModule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.unwrapAll">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unwrapAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.unwrapMethod">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unwrapMethod
            <span class="apidocSignatureSpan">(nodule, noduleName, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.wrapDeprecated">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>wrapDeprecated
            <span class="apidocSignatureSpan">(nodule, noduleName, property, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.wrapMethod">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>wrapMethod
            <span class="apidocSignatureSpan">(nodule, noduleName, methods, wrapper)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.statement_matcher">module newrelic.statement_matcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.statement_matcher.statement_matcher">
            function <span class="apidocSignatureSpan">newrelic.</span>statement_matcher
            <span class="apidocSignatureSpan">(operation, operationPattern)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.statement_matcher.prototype">module newrelic.statement_matcher.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.statement_matcher.prototype.getParsedStatement">
            function <span class="apidocSignatureSpan">newrelic.statement_matcher.prototype.</span>getParsedStatement
            <span class="apidocSignatureSpan">(type, sql)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.stream_sink">module newrelic.stream_sink</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stream_sink.stream_sink">
            function <span class="apidocSignatureSpan">newrelic.</span>stream_sink
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stream_sink.super_">
            function <span class="apidocSignatureSpan">newrelic.stream_sink.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.stream_sink.prototype">module newrelic.stream_sink.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stream_sink.prototype.destroy">
            function <span class="apidocSignatureSpan">newrelic.stream_sink.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stream_sink.prototype.end">
            function <span class="apidocSignatureSpan">newrelic.stream_sink.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stream_sink.prototype.write">
            function <span class="apidocSignatureSpan">newrelic.stream_sink.prototype.</span>write
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.stub_api">module newrelic.stub_api</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.stub_api">
            function <span class="apidocSignatureSpan">newrelic.</span>stub_api
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.stub_api.prototype">module newrelic.stub_api.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.addCustomParameter">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addCustomParameter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.addCustomParameters">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addCustomParameters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.addIgnoringRule">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addIgnoringRule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.addNamingRule">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addNamingRule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.createBackgroundTransaction">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createBackgroundTransaction
            <span class="apidocSignatureSpan">(name, group, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.createTracer">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createTracer
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.createWebTransaction">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createWebTransaction
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.endTransaction">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>endTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.getBrowserTimingHeader">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>getBrowserTimingHeader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.incrementMetric">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>incrementMetric
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.noticeError">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>noticeError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.recordCustomEvent">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>recordCustomEvent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.recordMetric">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>recordMetric
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.setControllerName">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setControllerName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.setIgnoreTransaction">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setIgnoreTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.setTransactionName">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setTransactionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.shutdown">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>shutdown
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.system_info">module newrelic.system_info</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info.system_info">
            function <span class="apidocSignatureSpan">newrelic.</span>system_info
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info._getDockerContainerId">
            function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getDockerContainerId
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info._getMemoryStats">
            function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getMemoryStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info._getProcessorStats">
            function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getProcessorStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.timer">module newrelic.timer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.timer">
            function <span class="apidocSignatureSpan">newrelic.</span>timer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.timer.prototype">module newrelic.timer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.begin">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>begin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.end">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.endsAfter">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>endsAfter
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.getDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>getDurationInMillis
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.hasEnd">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>hasEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.isActive">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>isActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.isRunning">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>isRunning
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.overwriteDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>overwriteDurationInMillis
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.setDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>setDurationInMillis
            <span class="apidocSignatureSpan">(duration, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.softEnd">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>softEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.startedRelativeTo">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>startedRelativeTo
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.toRange">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>toRange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.touch">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.tracer">module newrelic.tracer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tracer.tracer">
            function <span class="apidocSignatureSpan">newrelic.</span>tracer
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.tracer.prototype">module newrelic.tracer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tracer.prototype.addQuery">
            function <span class="apidocSignatureSpan">newrelic.tracer.prototype.</span>addQuery
            <span class="apidocSignatureSpan">(segment, type, query, trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tracer.prototype.merge">
            function <span class="apidocSignatureSpan">newrelic.tracer.prototype.</span>merge
            <span class="apidocSignatureSpan">(tracer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tracer.prototype.prepareJSON">
            function <span class="apidocSignatureSpan">newrelic.tracer.prototype.</span>prepareJSON
            <span class="apidocSignatureSpan">(done)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tracer.prototype.removeShortest">
            function <span class="apidocSignatureSpan">newrelic.tracer.prototype.</span>removeShortest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.tx_segment">module newrelic.tx_segment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tx_segment.tx_segment">
            function <span class="apidocSignatureSpan">newrelic.</span>tx_segment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.tx_segment.prototype">module newrelic.tx_segment.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tx_segment.prototype.load">
            function <span class="apidocSignatureSpan">newrelic.tx_segment.prototype.</span>load
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.tx_segment.prototype.normalize">
            function <span class="apidocSignatureSpan">newrelic.tx_segment.prototype.</span>normalize
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.uninstrumented">module newrelic.uninstrumented</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.uninstrumented.check">
            function <span class="apidocSignatureSpan">newrelic.uninstrumented.</span>check
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.uninstrumented.createMetrics">
            function <span class="apidocSignatureSpan">newrelic.uninstrumented.</span>createMetrics
            <span class="apidocSignatureSpan">(metrics)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.urltils">module newrelic.urltils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.urltils.copyParameters">
            function <span class="apidocSignatureSpan">newrelic.urltils.</span>copyParameters
            <span class="apidocSignatureSpan">(config, source, destination)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.urltils.isError">
            function <span class="apidocSignatureSpan">newrelic.urltils.</span>isError
            <span class="apidocSignatureSpan">(config, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.urltils.isIgnoredError">
            function <span class="apidocSignatureSpan">newrelic.urltils.</span>isIgnoredError
            <span class="apidocSignatureSpan">(config, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.urltils.isLocalhost">
            function <span class="apidocSignatureSpan">newrelic.urltils.</span>isLocalhost
            <span class="apidocSignatureSpan">(host)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.urltils.overwriteParameters">
            function <span class="apidocSignatureSpan">newrelic.urltils.</span>overwriteParameters
            <span class="apidocSignatureSpan">(config, source, destination)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.urltils.parseParameters">
            function <span class="apidocSignatureSpan">newrelic.urltils.</span>parseParameters
            <span class="apidocSignatureSpan">(requestURL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.urltils.scrub">
            function <span class="apidocSignatureSpan">newrelic.urltils.</span>scrub
            <span class="apidocSignatureSpan">(requestURL)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.urltils.scrubAndParseParameters">
            function <span class="apidocSignatureSpan">newrelic.urltils.</span>scrubAndParseParameters
            <span class="apidocSignatureSpan">(requestURL)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.urltils.</span>LOCALHOST_NAMES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.util">module newrelic.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.util.extractDatabaseChangeFromUse">
            function <span class="apidocSignatureSpan">newrelic.util.</span>extractDatabaseChangeFromUse
            <span class="apidocSignatureSpan">(sql)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic" id="apidoc.module.newrelic">module newrelic</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.agent" id="apidoc.element.newrelic.agent">
        function <span class="apidocSignatureSpan">newrelic.</span>agent
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(config) {
  EventEmitter.call(this)

  if (!config) throw new Error(&#x22;Agent must be created with a configuration!&#x22;)

  // The agent base attributes which last throughout its lifetime.
  this._state = &#x27;stopped&#x27;
  this.config = config
  this.environment = require(&#x27;./environment&#x27;)
  this.version = this.config.version
  this.collector = new CollectorAPI(this)

  // Reset the agent to add all the sub-objects it needs. These object are the
  // ones that get re-created if the agent is told to restart from the collector.
  this.events = null
  this.customEvents = null
  this.errors = null
  this.mapper = null
  this.metricNameNormalizer = null
  this.metrics = null
  this.transactionNameNormalizer = null
  this.urlNormalizer = null
  this.txSegmentNormalizer = null
  this.userNormalizer = null
  this.reset()

  // Transaction tracing.
  this.tracer = this._setupTracer()
  this.traces = new TraceAggregator(this.config)

  // Query tracing.
  this.queries = new QueryTracer(this.config)

  // Set up all the configuration events the agent needs to listen for.
  var self = this
  this.config.on(&#x27;apdex_t&#x27;, this._apdexTChange.bind(this))
  this.config.on(&#x27;data_report_period&#x27;, this._harvesterIntervalChange.bind(this))
  this.config.on(&#x27;agent_enabled&#x27;, this._enabledChange.bind(this))
  this.config.on(&#x27;change&#x27;, this._configChange.bind(this))
  this.config.on(&#x27;metric_name_rules&#x27;, function updateMetricNameNormalizer() {
    self.metricNameNormalizer.load.apply(self.metricNameNormalizer, arguments)
  })
  this.config.on(&#x27;transaction_name_rules&#x27;, function updateTransactionNameNormalizer() {
    self.transactionNameNormalizer.load.apply(self.transactionNameNormalizer, arguments)
  })
  this.config.on(&#x27;url_rules&#x27;, function updateUrlNormalizer() {
    self.urlNormalizer.load.apply(self.urlNormalizer, arguments)
  })
  this.config.on(&#x27;transaction_segment_terms&#x27;, function updateSegmentNormalizer() {
    self.txSegmentNormalizer.load.apply(self.txSegmentNormalizer, arguments)
  })

  // Entity tracking metrics.
  this.totalActiveSegments = 0
  this.segmentsCreatedInHarvest = 0
  this.segmentsClearedInHarvest = 0
  this.activeTransactions = 0

  // Hidden class optimizations.
  this.harvesterHandle = null

  // Finally, add listeners for the agent&#x27;s own events.
  this.on(&#x27;transactionFinished&#x27;, this._transactionFinished.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator" id="apidoc.element.newrelic.aggregator">
        function <span class="apidocSignatureSpan">newrelic.</span>aggregator
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ErrorAggregator(config) {
  this.config = config
  this.errorCount = 0
  this.webTransactionErrorCount = 0
  this.otherTransactionErrorCount = 0
  this.errors = []
  this.seenObjectsByTransaction = {}
  this.seenStringsByTransaction = {}

  // reservoir used for error events
  this.events = new Reservoir(this.config.error_collector.max_event_samples_stored)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.apdex" id="apidoc.element.newrelic.apdex">
        function <span class="apidocSignatureSpan">newrelic.</span>apdex
        <span class="apidocSignatureSpan">(apdexT)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ApdexStats(apdexT) {
  if (!apdexT &#x26;&#x26; apdexT !== 0) {
    throw new Error(&#x27;Apdex summary must be created with apdexT.&#x27;)
  }
  this.apdexT = apdexT

  this.satisfying = 0
  this.tolerating = 0
  this.frustrating = 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api" id="apidoc.element.newrelic.api">
        function <span class="apidocSignatureSpan">newrelic.</span>api
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function API(agent) {
  this.agent = agent
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aws_info" id="apidoc.element.newrelic.aws_info">
        function <span class="apidocSignatureSpan">newrelic.</span>aws_info
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchAWSInfo(agent, callback) {
  if (!agent.config.utilization || !agent.config.utilization.detect_aws) {
    return callback(null)
  }

  if (resultDict) {
    return callback(resultDict)
  }

  var awsQuery = module.exports._awsQuery

  awsQuery(&#x27;instance-type&#x27;, agent, function getInstanceType(type) {
    if (!type) return callback(null)
    awsQuery(&#x27;instance-id&#x27;, agent, function getInstanceId(id) {
      if (!id) return callback(null)
      awsQuery(&#x27;placement/availability-zone&#x27;, agent, function getZone(zone) {
        if (!zone) return callback(null)
        resultDict = {
          type: type,
          id: id,
          zone: zone
        }
        return callback(resultDict)
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config" id="apidoc.element.newrelic.config">
        function <span class="apidocSignatureSpan">newrelic.</span>config
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(config) {
  EventEmitter.call(this)

  // 1. start by cloning the defaults
  try {
    var basis = JSON.parse(stringifySync(DEFAULT_CONFIG))
    Object.keys(basis).forEach(function cb_forEach(key) {
      this[key] = basis[key]
    }, this)
  } catch (err) {
    logger.warn(&#x27;Unable to clone the default config, %s: %s&#x27;, DEFAULT_CONFIG_PATH, err)
  }

  if (config &#x26;&#x26;
      (process.env[ENV_MAPPING.ssl] === &#x27;false&#x27; || config.ssl === false) &#x26;&#x26;
      process.env[ENV_MAPPING.port] === undefined &#x26;&#x26; config.port === undefined ) {
    config.port = 80
  }

  // 2. initialize undocumented, internal-only default values

  // feature flags are mostly private settings for gating unreleased features
  // flags are set in the feature_flags.js file
  this.feature_flag = feature_flag.prerelease

  // set by environment
  this.newrelic_home = null
  // set by configuration file loader
  this.config_file_path = null
  // set by collector on handshake
  this.run_id = null
  this.application_id = null
  this.web_transactions_apdex = {}
  this.cross_process_id = null
  this.encoding_key = null
  this.obfuscatedId = null
  this.trusted_account_ids = null

  // how frequently harvester runs
  this.data_report_period = 60

  // this value is arbitrary
  this.max_trace_segments = 900

  // feature level of this account
  this.product_level = 0
  // product-level related
  this.collect_traces = true
  this.collect_errors = true

  // override options for utilization stats
  this.utilization.logical_processors = null
  this.utilization.total_ram_mib = null
  this.utilization.billing_hostname = null

  this.browser_monitoring.loader = &#x27;rum&#x27;
  this.browser_monitoring.loader_version = &#x27;&#x27;

  // Settings to play nice with DLPs (see NODE-1044).
  this.compressed_content_encoding = &#x22;deflate&#x22;  // Deflate or gzip
  this.simple_compression = false               // Disables subcomponent compression
  this.put_for_data_send = false                // Changes http verb for harvest


  // 3. override defaults with values from the loaded / passed configuration
  this._fromPassed(config)

  // 3.5. special values (only Azure environment APP_POOL_ID for now)
  this._fromSpecial()

  // 4. override config with environment variables
  this._fromEnvironment()

  // 5. clean up anything that requires postprocessing
  this._canonicalize()

  // 6. put the version in the config
  this.version = require(&#x27;../package.json&#x27;).version

  // 7. apply high security overrides
  if (this.high_security === true) {
    this._applyHighSecurity()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.label_parser" id="apidoc.element.newrelic.label_parser">
        function <span class="apidocSignatureSpan">newrelic.</span>label_parser
        <span class="apidocSignatureSpan">(labels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(labels) {
  var results

  if (!labels) {
    return []
  } else if (typeof labels === &#x27;string&#x27;) {
    results = fromString(labels)
  } else if (labels) {
    results = fromMap(labels)
  }

  results.warnings.forEach(function logWarnings(messaage) {
    logger.warn(messaage)
  })

  return results.labels
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.mapper" id="apidoc.element.newrelic.mapper">
        function <span class="apidocSignatureSpan">newrelic.</span>mapper
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MetricMapper(raw) {
  this.unscoped = {}
  this.scoped = {}
  this.length = 0

  this.load(raw)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state" id="apidoc.element.newrelic.name_state">
        function <span class="apidocSignatureSpan">newrelic.</span>name_state
        <span class="apidocSignatureSpan">(prefix, verb, delimiter, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NameState(prefix, verb, delimiter, path) {
  this.setName(prefix, verb, delimiter, path)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.normalizer" id="apidoc.element.newrelic.normalizer">
        function <span class="apidocSignatureSpan">newrelic.</span>normalizer
        <span class="apidocSignatureSpan">(config, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MetricNormalizer(config, type) {
  if (!config) throw new Error(&#x22;normalizer must be created with configuration.&#x22;)
  if (!type) throw new Error(&#x22;normalizer must be created with a type.&#x22;)

  EventEmitter.call(this)

  this.config = config
  this.type = type
  // some mildly cheesy polymorphism to make normalizers work generically
  if (type === &#x27;URL&#x27;) {
    this.formatter = url
  } else {
    this.formatter = plain
  }

  this.rules = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.parsed_statement" id="apidoc.element.newrelic.parsed_statement">
        function <span class="apidocSignatureSpan">newrelic.</span>parsed_statement
        <span class="apidocSignatureSpan">(type, operation, model, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParsedStatement(type, operation, model, raw) {
  this.type = type
  this.operation = operation
  this.model = model
  this.trace = null
  this.raw = &#x27;&#x27;

  if (typeof raw === &#x27;string&#x27;) {
    this.trace = new Error()
    this.raw = raw
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method" id="apidoc.element.newrelic.remote_method">
        function <span class="apidocSignatureSpan">newrelic.</span>remote_method
        <span class="apidocSignatureSpan">(name, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RemoteMethod(name, config) {
  if (!name) {
    throw new TypeError(&#x22;Must include name of method to invoke on collector.&#x22;)
  }

  this.name = name
  this._config = config
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir" id="apidoc.element.newrelic.reservoir">
        function <span class="apidocSignatureSpan">newrelic.</span>reservoir
        <span class="apidocSignatureSpan">(limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reservoir(limit) {
  this.limit = limit || 10
  this.seen = 0
  this._data = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.rule" id="apidoc.element.newrelic.rule">
        function <span class="apidocSignatureSpan">newrelic.</span>rule
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NormalizerRule(json) {
  if (!json) {
    logger.debug(
      &#x22;Received incompletely specified metric normalization rule from collector.&#x22;
    )
    json = {}
  }

  this.eachSegment = json.each_segment || false
  this.precedence = json.eval_order || 0
  this.isTerminal = json.terminate_chain || false
  this.replacement = replaceReplacer(json.replacement || &#x27;$0&#x27;)
  this.replaceAll = json.replace_all || false
  this.ignore = json.ignore || false
  this.matched = false

  var modifiers = &#x27;i&#x27;
  if (this.replaceAll) modifiers += &#x27;g&#x27;

  // don&#x27;t allow this to fail
  if (json.match_expression instanceof RegExp) {
    this.pattern = _addRegExpFlags(json.match_expression, modifiers)
  } else {
    try {
      this.pattern = new RegExp(json.match_expression || &#x27;^$&#x27;, modifiers)
    } catch (error) {
      logger.warn(error, &#x22;Problem compiling metric normalization rule pattern.&#x22;)
      this.pattern = /^$/
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment" id="apidoc.element.newrelic.segment">
        function <span class="apidocSignatureSpan">newrelic.</span>segment
        <span class="apidocSignatureSpan">(transaction, name, recorder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TraceSegment(transaction, name, recorder) {
  if (!transaction) throw new Error(&#x27;All segment must be associated with a transaction.&#x27;)
  if (!name) throw new Error(&#x27;All segment must be named&#x27;)

  this.name = name
  this.transaction = transaction

  transaction.numSegments++
  transaction.agent.totalActiveSegments++
  transaction.agent.segmentsCreatedInHarvest++

  if (recorder) {
    transaction.addRecorder(recorder.bind(null, this))
  }

  this.parameters = {nr_exclusive_duration_millis: null}
  this.children = []

  this.timer = new Timer()

  // hidden class optimization
  this.partialName = null
  this._exclusiveDuration = null
  this._collect = true
  this.host = null
  this.port = null
  this.state = STATE.EXTERNAL
  this.async = true
  this.ignore = false

  this.probe(&#x27;new TraceSegment&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.statement_matcher" id="apidoc.element.newrelic.statement_matcher">
        function <span class="apidocSignatureSpan">newrelic.</span>statement_matcher
        <span class="apidocSignatureSpan">(operation, operationPattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StatementMatcher(operation, operationPattern) {
  this.operation = operation
  this.operationPattern = operationPattern
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stream_sink" id="apidoc.element.newrelic.stream_sink">
        function <span class="apidocSignatureSpan">newrelic.</span>stream_sink
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StreamSink(callback) {
  EventEmitter.call(this)

  this.callback = callback
  this.sink = &#x27;&#x27;
  this.writable = true

  var sink = this
  this.on(&#x27;error&#x27;, function handle_error(error) {
    sink.writable = false
    callback(error)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api" id="apidoc.element.newrelic.stub_api">
        function <span class="apidocSignatureSpan">newrelic.</span>stub_api
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stub() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.system_info" id="apidoc.element.newrelic.system_info">
        function <span class="apidocSignatureSpan">newrelic.</span>system_info
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchSystemInfo(agent, callback) {
  var config = agent.config
  var systemInfo = {
    processorArch: os.arch()
  }

  var utilizationConfig = {}
  if (config.utilization) {
    var configProcessors = config.utilization.logical_processors
    var configRam = config.utilization.total_ram_mib
    var configHostname = config.utilization.billing_hostname

    if (configProcessors) {
      var parsedConfigProcessors = parseFloat(configProcessors, 10)
      if (!isNaN(parsedConfigProcessors) &#x26;&#x26; isInteger(parsedConfigProcessors)) {
        utilizationConfig.logical_processors = parsedConfigProcessors
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.logical_processors, expected a number&#x27;,
          configProcessors
        )
      }
    }

    if (configRam) {
      var parsedConfigRam = parseFloat(configRam, 10)
      if (!isNaN(parsedConfigRam) &#x26;&#x26; isInteger(parsedConfigRam)) {
        utilizationConfig.total_ram_mib = parsedConfigRam
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.total_ram_mib, expected a number&#x27;,
          configRam
        )
      }
    }

    if (configHostname) {
      if (typeof configHostname === &#x27;string&#x27;) {
        utilizationConfig.hostname = configHostname
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.Hostname, expected a string&#x27;,
          configHostname
        )
      }
    }

    if (Object.keys(utilizationConfig).length &#x3e; 0) {
      systemInfo.config = utilizationConfig
    }
  }

  var tasksDone = 0
  var numTasks = 5
  function finishedResponse() {
    if (++tasksDone === numTasks) return callback(systemInfo)
  }

  module.exports._getProcessorStats(function getProcessCB(processorStats) {
    systemInfo.packages = processorStats.packages
    systemInfo.logicalProcessors = processorStats.logical
    systemInfo.cores = processorStats.cores
    finishedResponse()
  })
  module.exports._getMemoryStats(function getMemCB(memory) {
    systemInfo.memory = memory
    finishedResponse()
  })
  getKernelVersion(function getVersionCB(kernelVersion) {
    systemInfo.kernelVersion = kernelVersion
    finishedResponse()
  })
  module.exports._getDockerContainerId(agent, function getContainerId(containerId) {
    if (containerId) {
      systemInfo.docker = {
        id: containerId
      }
    }
    finishedResponse()
  })
  fetchAWSInfo(agent, function getAWSInfo(aws) {
    systemInfo.aws = aws
    finishedResponse()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer" id="apidoc.element.newrelic.timer">
        function <span class="apidocSignatureSpan">newrelic.</span>timer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timer() {
  this.state = PENDING
  this.touched = false
  this.duration = null
  this.hrDuration = null
  this.hrstart = null
  this.durationInMillis = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.tracer" id="apidoc.element.newrelic.tracer">
        function <span class="apidocSignatureSpan">newrelic.</span>tracer
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryTracer(config) {
  if (!(this instanceof QueryTracer)) {
    return new QueryTracer(config)
  }
  this.samples = {}
  this.config = config
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.tx_segment" id="apidoc.element.newrelic.tx_segment">
        function <span class="apidocSignatureSpan">newrelic.</span>tx_segment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TxSegmentNormalizer() {
  this.terms = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.agent" id="apidoc.module.newrelic.agent">module newrelic.agent</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.agent.agent" id="apidoc.element.newrelic.agent.agent">
        function <span class="apidocSignatureSpan">newrelic.</span>agent
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(config) {
  EventEmitter.call(this)

  if (!config) throw new Error(&#x22;Agent must be created with a configuration!&#x22;)

  // The agent base attributes which last throughout its lifetime.
  this._state = &#x27;stopped&#x27;
  this.config = config
  this.environment = require(&#x27;./environment&#x27;)
  this.version = this.config.version
  this.collector = new CollectorAPI(this)

  // Reset the agent to add all the sub-objects it needs. These object are the
  // ones that get re-created if the agent is told to restart from the collector.
  this.events = null
  this.customEvents = null
  this.errors = null
  this.mapper = null
  this.metricNameNormalizer = null
  this.metrics = null
  this.transactionNameNormalizer = null
  this.urlNormalizer = null
  this.txSegmentNormalizer = null
  this.userNormalizer = null
  this.reset()

  // Transaction tracing.
  this.tracer = this._setupTracer()
  this.traces = new TraceAggregator(this.config)

  // Query tracing.
  this.queries = new QueryTracer(this.config)

  // Set up all the configuration events the agent needs to listen for.
  var self = this
  this.config.on(&#x27;apdex_t&#x27;, this._apdexTChange.bind(this))
  this.config.on(&#x27;data_report_period&#x27;, this._harvesterIntervalChange.bind(this))
  this.config.on(&#x27;agent_enabled&#x27;, this._enabledChange.bind(this))
  this.config.on(&#x27;change&#x27;, this._configChange.bind(this))
  this.config.on(&#x27;metric_name_rules&#x27;, function updateMetricNameNormalizer() {
    self.metricNameNormalizer.load.apply(self.metricNameNormalizer, arguments)
  })
  this.config.on(&#x27;transaction_name_rules&#x27;, function updateTransactionNameNormalizer() {
    self.transactionNameNormalizer.load.apply(self.transactionNameNormalizer, arguments)
  })
  this.config.on(&#x27;url_rules&#x27;, function updateUrlNormalizer() {
    self.urlNormalizer.load.apply(self.urlNormalizer, arguments)
  })
  this.config.on(&#x27;transaction_segment_terms&#x27;, function updateSegmentNormalizer() {
    self.txSegmentNormalizer.load.apply(self.txSegmentNormalizer, arguments)
  })

  // Entity tracking metrics.
  this.totalActiveSegments = 0
  this.segmentsCreatedInHarvest = 0
  this.segmentsClearedInHarvest = 0
  this.activeTransactions = 0

  // Hidden class optimizations.
  this.harvesterHandle = null

  // Finally, add listeners for the agent&#x27;s own events.
  this.on(&#x27;transactionFinished&#x27;, this._transactionFinished.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.super_" id="apidoc.element.newrelic.agent.super_">
        function <span class="apidocSignatureSpan">newrelic.agent.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.agent.prototype" id="apidoc.module.newrelic.agent.prototype">module newrelic.agent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._addEventFromTransaction" id="apidoc.element.newrelic.agent.prototype._addEventFromTransaction">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_addEventFromTransaction
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _addEventFromTransaction(transaction) {
  if (!this.config.transaction_events.enabled) return

  var intrinsicAttributes = this._addIntrinsicAttrsFromTransaction(transaction)
  var userAttributes = transaction.trace.custom
  var agentAttributes = transaction.trace.parameters

  var event = [
    intrinsicAttributes,
    userAttributes,
    agentAttributes
  ]

  this.events.add(event)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.metrics.merge(transaction.metrics)
  this.errors.onTransactionFinished(transaction, this.metrics)
  this.traces.add(transaction)

  var trace = transaction.trace
  trace.intrinsics = transaction.getIntrinsicAttributes()

  this.<span class="apidocCodeKeywordSpan">_addEventFromTransaction</span>(transaction)
} else if (transaction.forceIgnore === true) {
  logger.debug(&#x22;Explicitly ignoring %s.&#x22;, transaction.name)
} else {
  logger.debug(&#x22;Ignoring %s.&#x22;, transaction.name)
}

this.activeTransactions--
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._addIntrinsicAttrsFromTransaction" id="apidoc.element.newrelic.agent.prototype._addIntrinsicAttrsFromTransaction">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_addIntrinsicAttrsFromTransaction
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _addIntrinsicAttrsFromTransaction(transaction) {
  var intrinsicAttributes = {
    webDuration: transaction.timer.duration / 1000,
    timestamp: transaction.timer.start,
    name: transaction.name,
    duration: transaction.timer.duration / 1000,
    type: &#x27;Transaction&#x27;,
    error: transaction.hasErrors()
  }

  var metric = transaction.metrics.getMetric(NAMES.QUEUETIME)
  if (metric) {
    intrinsicAttributes.queueDuration = metric.total
  }

  metric = transaction.metrics.getMetric(NAMES.EXTERNAL.ALL)
  if (metric) {
    intrinsicAttributes.externalDuration = metric.total
    intrinsicAttributes.externalCallCount = metric.callCount
  }

  metric = transaction.metrics.getMetric(NAMES.DB.ALL)
  if (metric) {
    intrinsicAttributes.databaseDuration = metric.total
    intrinsicAttributes.databaseCallCount = metric.callCount
  }

  // FLAG: cat
  if (this.config.feature_flag.cat) {
    if (!transaction.invalidIncomingExternalTransaction &#x26;&#x26;
         (
           transaction.referringTransactionGuid ||
           transaction.includesOutboundRequests()
         )
       ) {
      intrinsicAttributes[&#x27;nr.guid&#x27;] = transaction.id
      intrinsicAttributes[&#x27;nr.tripId&#x27;] = transaction.tripId || transaction.id
      intrinsicAttributes[&#x27;nr.pathHash&#x27;] = hashes.calculatePathHash(
        this.config.applications()[0],
        transaction.name || transaction.nameState.getName(),
        transaction.referringPathHash
      )
      if (transaction.referringPathHash) {
        intrinsicAttributes[&#x27;nr.referringPathHash&#x27;] = transaction.referringPathHash
      }
      if (transaction.referringTransactionGuid) {
        var refId = transaction.referringTransactionGuid
        intrinsicAttributes[&#x27;nr.referringTransactionGuid&#x27;] = refId
      }
      var alternatePathHashes = transaction.alternatePathHashes()
      if (alternatePathHashes) {
        intrinsicAttributes[&#x27;nr.alternatePathHashes&#x27;] = alternatePathHashes
      }
      if (transaction.webSegment) {
        var apdex = (this.config.web_transactions_apdex[transaction.name] ||
                     this.config.apdex_t)
        var duration = transaction.webSegment.getDurationInMillis() / 1000
        intrinsicAttributes[&#x27;nr.apdexPerfZone&#x27;] = calculateApdexZone(duration, apdex)
      }
    }
  }

  if (transaction.syntheticsData) {
    intrinsicAttributes[&#x22;nr.syntheticsResourceId&#x22;] = transaction.syntheticsData.resourceId
    intrinsicAttributes[&#x22;nr.syntheticsJobId&#x22;] = transaction.syntheticsData.jobId
    intrinsicAttributes[&#x22;nr.syntheticsMonitorId&#x22;] = transaction.syntheticsData.monitorId
  }

  return intrinsicAttributes
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Agent.prototype._addEventFromTransaction = _addEventFromTransaction

function _addEventFromTransaction(transaction) {
if (!this.config.transaction_events.enabled) return

var intrinsicAttributes = this.<span class="apidocCodeKeywordSpan">_addIntrinsicAttrsFromTransaction</span>(transaction)
var userAttributes = transaction.trace.custom
var agentAttributes = transaction.trace.parameters

var event = [
  intrinsicAttributes,
  userAttributes,
  agentAttributes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._apdexTChange" id="apidoc.element.newrelic.agent.prototype._apdexTChange">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_apdexTChange
        <span class="apidocSignatureSpan">(apdexT)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _apdexTChange(apdexT) {
  logger.debug(&#x22;Apdex tolerating value changed to %s.&#x22;, apdexT)
  this.metrics.apdexT = apdexT
  if (this.config.debug.supportability) {
    this.config.debug.supportability.apdexT = apdexT
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._configChange" id="apidoc.element.newrelic.agent.prototype._configChange">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_configChange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _configChange() {
  this.collector.reportSettings()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._enabledChange" id="apidoc.element.newrelic.agent.prototype._enabledChange">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_enabledChange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _enabledChange() {
  if (this.config.agent_enabled === false) {
    logger.warn(&#x27;agent_enabled has been changed to false, stopping the agent.&#x27;)
    this.stop(function nop() {})
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._harvesterIntervalChange" id="apidoc.element.newrelic.agent.prototype._harvesterIntervalChange">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_harvesterIntervalChange
        <span class="apidocSignatureSpan">(interval, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _harvesterIntervalChange(interval, callback) {
  var agent = this

  // only change the setup if the harvester is currently running
  if (this.harvesterHandle) {
    // force a harvest now, to be safe
    this.harvest(function cb_harvest(error) {
      agent._restartHarvester(interval)
      if (callback) callback(error)
    })
  } else if (callback) {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._processCustomEvents" id="apidoc.element.newrelic.agent.prototype._processCustomEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_processCustomEvents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _processCustomEvents() {
  this.customEventsPool = this.customEvents.toArray()

  // Create the metrics so they are at least set to 0
  var dropped = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.DROPPED)
  var seen = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SEEN)
  var sent = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SENT)

  // Bail out if there are no events
  if (this.customEventsPool.length === 0) {
    return
  }

  if (this.config.custom_insights_events.enabled) {
    // Record their values
    var diff = this.customEvents.overflow()
    dropped.incrementCallCount(diff)
    seen.incrementCallCount(this.customEvents.seen)
    sent.incrementCallCount(this.customEvents.seen - diff)

    // Log any warnings about dropping events
    if (diff) {
      logger.warn(&#x27;Dropped %s custom events out of %s.&#x27;, diff, this.customEvents.seen)
    }

    // Create a new reservoir now (instead of at send time) so metrics match
    // what we actually send.
    this.customEvents = new Reservoir(
      this.config.custom_insights_events.max_samples_stored
    )
  } else if (this.customEventsPool.length &#x3e; 0) {
    // We have events and custom events are disabled. Clear everything out so we
    // don&#x27;t hold onto memory that we shouldn&#x27;t. Only time this could happen is
    // if the server sent down settings disabling custom events in the middle of
    // a harvest cycle.
    this.customEventsPool = []
    this.customEvents = new Reservoir(
      this.config.custom_insights_events.max_samples_stored
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.config.debug.supportability) {
  this.metrics.merge(this.config.debug.supportability)
}

// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this.<span class="apidocCodeKeywordSpan">_processCustomEvents</span>()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.toJSON().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._processErrorEvents" id="apidoc.element.newrelic.agent.prototype._processErrorEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_processErrorEvents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _processErrorEvents() {
  var events = this.errors.getEvents()

  this._lastErrorEvents = [
    this.errors.getEventsLimit(),
    this.errors.getEventsSeen(),
    events
  ]

  // Create the metrics so they are at least set to 0
  var seen = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SEEN)
  var sent = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SENT)

  // Bail out if there are no events
  if (events.length === 0) {
    return
  }

  if (this.config.error_collector.capture_events) {
    // Record their values
    var diff = this.errors.events.overflow()
    seen.incrementCallCount(this.errors.events.seen)
    sent.incrementCallCount(this.errors.events.seen - diff)

    // Log any warnings about dropping events
    if (diff) {
      logger.warn(&#x27;Dropped %s error events out of %s.&#x27;, diff, this.errors.events.seen)
    }

    // clear the reservoir now (instead of at send time) so metrics match
    // what we actually send.
    this.errors.clearEvents()
  } else if (events.length &#x3e; 0) {
    // We have events and error events are disabled. Clear everything out so we
    // don&#x27;t hold onto memory that we shouldn&#x27;t. Only time this could happen is
    // if the server sent down settings disabling error events in the middle of
    // a harvest cycle.
    this._lastErrorEvents = []
    this.errors.clearEvents()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.metrics.merge(this.config.debug.supportability)
}

// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this._processCustomEvents()
this.<span class="apidocCodeKeywordSpan">_processErrorEvents</span>()

// wait to check until all the standard stuff has been added
if (this.metrics.toJSON().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._restartHarvester" id="apidoc.element.newrelic.agent.prototype._restartHarvester">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_restartHarvester
        <span class="apidocSignatureSpan">(harvestSeconds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _restartHarvester(harvestSeconds) {
  this._stopHarvester()
  this._startHarvester(harvestSeconds)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function _harvesterIntervalChange(interval, callback) {
  var agent = this

  // only change the setup if the harvester is currently running
  if (this.harvesterHandle) {
    // force a harvest now, to be safe
    this.harvest(function cb_harvest(error) {
      agent.<span class="apidocCodeKeywordSpan">_restartHarvester</span>(interval)
      if (callback) callback(error)
    })
  } else if (callback) {
    process.nextTick(callback)
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendCustomEvents" id="apidoc.element.newrelic.agent.prototype._sendCustomEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendCustomEvents
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendCustomEvents(callback) {
  // Must be enabled and actually have events to send, otherwise bail and nextTick
  if (this.config.custom_insights_events.enabled &#x26;&#x26; this.customEventsPool.length &#x3e; 0) {
    var agent = this
    var run_id = agent.config.run_id

    var payload = [
      run_id,
      agent.customEventsPool
    ]

    // send data to collector
    agent.collector.customEvents(payload, function cb_customEvents(err) {
      if (err &#x26;&#x26; err.statusCode === 413 ) {
        var tooLarge = agent.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.TOO_LARGE)
        tooLarge.incrementCallCount()
        logger.warn(&#x27;request too large; custom event data dropped&#x27;)
      } else if (err) {
        var failed = agent.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.FAILED)
        failed.incrementCallCount()
        logger.warn(&#x27;custom events failed to send; re-sampling&#x27;)

        for (var i = 0; i &#x3c; agent.customEventsPool.length; i++) {
          agent.customEvents.add(agent.customEventsPool[i])
        }
      }

      callback(err)
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendErrorEvents" id="apidoc.element.newrelic.agent.prototype._sendErrorEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendErrorEvents
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendErrorEvents(callback) {
  if (this.config.error_collector.capture_events &#x26;&#x26; this._lastErrorEvents &#x26;&#x26;
        this._lastErrorEvents[2].length &#x3e; 0) {
    var agent = this
    var eventsLimit = this._lastErrorEvents[0]
    var eventsSeen = this._lastErrorEvents[1]
    var events = this._lastErrorEvents[2]
    var run_id = agent.config.run_id

    if (events.length &#x3c; 1) {
      return process.nextTick(callback)
    }

    var metrics = {
      reservoir_size: eventsLimit,
      events_seen: eventsSeen
    }

    var payload = [
      run_id,
      metrics,
      events
    ]

    // send data to collector
    agent.collector.errorEvents(payload, function cb_errorEvents(err) {
      if (err &#x26;&#x26; err.statusCode === 413 ) {
        logger.warn(&#x27;request too large; event data dropped&#x27;)
      } else if (err) {
        logger.warn(&#x27;error events failed to send; re-sampling&#x27;)
        agent.errors.mergeEvents(events)
      }
      callback(err)
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendErrors" id="apidoc.element.newrelic.agent.prototype._sendErrors">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendErrors
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendErrors(callback) {
  var agent = this

  if (this.config.collect_errors &#x26;&#x26; this.config.error_collector.enabled) {
    if (!this.collector.isConnected()) {
      return process.nextTick(function cb_nextTick() {
        callback(new Error(&#x22;not connected to New Relic (errors will be held)&#x22;))
      })
    } else if (this.errors.getTotalErrorCount() &#x3c; 1) {
      logger.debug(&#x22;No errors to send.&#x22;)
      return process.nextTick(callback)
    }

    var errors = this.errors.getErrors()
    var payload = [this.config.run_id, errors]

    // reset now to avoid losing errors that come in after delivery starts
    this.errors.clearErrors()

    this.collector.errorData(payload, function cb_errorData(error) {
      if (error) agent.errors.merge(errors)

      callback(error)
    })
  } else {
<span class="apidocCodeCommentSpan">    /**
     * Reset the errors object even if collection is disabled due to error
     * counting. Also covers the case where the error collector gets disabled
     * in the middle of a harvest cycle so the agent doesn&#x27;t continue to hold
     * on to the errors it had collected during the harvest cycle so far.
     */
</span>    this.errors.clearErrors()
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendEvents" id="apidoc.element.newrelic.agent.prototype._sendEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendEvents
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendEvents(callback) {
  if (this.config.transaction_events.enabled) {
    var agent = this
    var events = agent.events
    var sample = events.toArray()
    var run_id = agent.config.run_id

    // bail if there are no events
    if (sample.length &#x3c; 1) {
      return process.nextTick(callback)
    }

    var metrics = {
      reservoir_size: events.limit,
      events_seen: events.seen
    }

    var payload = [
      run_id,
      metrics,
      sample
    ]

    // clear events
    agent.events = new Reservoir(agent.config.transaction_events.max_samples_per_minute)

    // send data to collector
    agent.collector.analyticsEvents(payload, function cb_analyticsEvents(err) {
      if (err &#x26;&#x26; err.statusCode === 413 ) {
        logger.warn(&#x27;request too large; event data dropped&#x27;)
      } else if (err) {
        logger.warn(&#x27;analytics events failed to send; re-sampling&#x27;)

        // boost the limit if a connection fails
        // and re-aggregate on failure
        var newlimit = agent.config.transaction_events.max_samples_stored
        agent.events.limit = newlimit

        for (var k = 0; k &#x3c; sample.length; k++) agent.events.add(sample[k])
      } else {
        // if we had to limit events and sample them, emit a warning
        var diff = events.overflow()
        if (diff &#x3e; 0) logger.warn(
          &#x27;analytics event overflow, dropped %d events; &#x27; +
           &#x27;try increasing your limit above %d&#x27;,
          diff, events.limit
        )
      }

      callback(err)
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendMetrics" id="apidoc.element.newrelic.agent.prototype._sendMetrics">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendMetrics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendMetrics(callback) {
  var agent = this

  if (this.collector.isConnected()) {
    if (this.errors.getTotalErrorCount() &#x3e; 0) {
      var count = this.errors.getTotalErrorCount()
      this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount(count)

      count = this.errors.getWebTransactionsErrorCount()
      this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount(count)

      count = this.errors.getBackgroundTransactionsErrorCount()
      this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount(count)
    }

    if (this.config.debug.supportability) {
      this.metrics.merge(this.config.debug.supportability)
    }

    // Send uninstrumented supportability metrics every harvest cycle
    uninstrumented.createMetrics(this.metrics)

    this._processCustomEvents()
    this._processErrorEvents()

    // wait to check until all the standard stuff has been added
    if (this.metrics.toJSON().length &#x3c; 1) {
      logger.debug(&#x22;No metrics to send.&#x22;)
      return process.nextTick(callback)
    }

    var metrics = this.metrics
    var beginSeconds = metrics.started * FROM_MILLIS
    var endSeconds = Date.now() * FROM_MILLIS
    var payload = [this.config.run_id, beginSeconds, endSeconds, metrics]


    // reset now to avoid losing metrics that come in after delivery starts
    this.metrics = new Metrics(
      this.config.apdex_t,
      this.mapper,
      this.metricNameNormalizer
    )

    this.collector.metricData(payload, function cb_metricData(error, rules) {
      if (error) agent.metrics.merge(metrics)
      if (rules) agent.mapper.load(rules)

      callback(error)
    })
  } else {
    process.nextTick(function cb_nextTick() {
      callback(new Error(&#x22;not connected to New Relic (metrics will be held)&#x22;))
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendQueries" id="apidoc.element.newrelic.agent.prototype._sendQueries">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendQueries
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendQueries(callback) {
  var agent = this
  var queries = this.queries

  this.queries = new QueryTracer(agent.config)

  if (!this.config.slow_sql.enabled) {
    logger.debug(&#x27;Slow Query is not enabled.&#x27;)
    return process.nextTick(callback)
  }

  if (Object.keys(queries.samples).length &#x3c; 1) {
    logger.debug(&#x27;No queries to send.&#x27;)
    return process.nextTick(callback)
  }

  queries.prepareJSON(function gotJSON(err, data) {
    if (err) {
      this.queries.merge(queries)
      logger.debug(&#x27;Error while serializing query data: %s&#x27;, err.message)
      return callback(err)
    }

    agent.collector.queryData([data], function handleResponse(error) {
      if (error) agent.queries.merge(queries)
      callback(error)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendTrace" id="apidoc.element.newrelic.agent.prototype._sendTrace">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendTrace
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendTrace(callback) {
  var agent = this
  if (this.config.collect_traces &#x26;&#x26; this.config.transaction_tracer.enabled) {
    if (!this.collector.isConnected()) {
      return process.nextTick(function cb_nextTick() {
        callback(new Error(&#x22;not connected to New Relic (slow trace data will be held)&#x22;))
      })
    }

    this.traces.harvest(function cb_harvest(error, traces, trace) {
      if (error || !traces || traces.length === 0) return callback(error)

      var payload = [agent.config.run_id, traces]
      agent.collector.transactionSampleData(
        payload,
        function cb_transactionSampleData(error) {
          if (!error) agent.traces.reset(trace)

          callback(error)
        }
      )
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._setupTracer" id="apidoc.element.newrelic.agent.prototype._setupTracer">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_setupTracer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _setupTracer() {
  var Tracer = require(&#x27;./transaction/tracer&#x27;)
  return new Tracer(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.transactionNameNormalizer = null
this.urlNormalizer = null
this.txSegmentNormalizer = null
this.userNormalizer = null
this.reset()

// Transaction tracing.
this.tracer = this.<span class="apidocCodeKeywordSpan">_setupTracer</span>()
this.traces = new TraceAggregator(this.config)

// Query tracing.
this.queries = new QueryTracer(this.config)

// Set up all the configuration events the agent needs to listen for.
var self = this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._startHarvester" id="apidoc.element.newrelic.agent.prototype._startHarvester">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_startHarvester
        <span class="apidocSignatureSpan">(harvestSeconds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _startHarvester(harvestSeconds) {
  var agent = this

  function onError(error) {
    if (error) {
      logger.info(error, &#x22;Error on submission to New Relic (data held for redelivery):&#x22;)
    }
  }

  function harvester() {
    agent.harvest(onError)
  }

  this.harvesterHandle = setInterval(harvester, harvestSeconds * TO_MILLIS)
  // timer.unref is 0.9+
  if (this.harvesterHandle.unref) this.harvesterHandle.unref()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (agent.collector.isConnected() &#x26;&#x26; !agent.config.no_immediate_harvest) {
  // harvest immediately for quicker data display, but after at least 1
  // second or the collector will throw away the data.
  setTimeout(function one_sec_delayed_harvest() {
    agent.harvest(function cb_harvest(error) {
      agent.<span class="apidocCodeKeywordSpan">_startHarvester</span>(agent.config.data_report_period)

      agent.setState(&#x27;started&#x27;)
      callback(error, config)
    })
  }, 1000)
} else {
  process.nextTick(function cb_nextTick() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._stopHarvester" id="apidoc.element.newrelic.agent.prototype._stopHarvester">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_stopHarvester
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _stopHarvester() {
  if (this.harvesterHandle) clearInterval(this.harvesterHandle)
  this.harvesterHandle = undefined
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Agent.prototype.stop = function stop(callback) {
if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

var agent = this

this.setState(&#x27;stopping&#x27;)
this.<span class="apidocCodeKeywordSpan">_stopHarvester</span>()
sampler.stop()

if (this.collector.isConnected()) {
  this.collector.shutdown(function cb_shutdown(error) {
    if (error) {
      agent.setState(&#x27;errored&#x27;)
      logger.warn(error, &#x22;Got error shutting down connection to New Relic:&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._transactionFinished" id="apidoc.element.newrelic.agent.prototype._transactionFinished">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_transactionFinished
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _transactionFinished(transaction) {
  // only available when this.config.debug.tracer_tracing is true
  if (transaction.describer) {
    logger.trace({trace_dump: transaction.describer.verbose}, &#x27;Dumped transaction state.&#x27;)
  }

  // Allow the API to explicitly set the ignored status on bg-tx.
  // This is handled for web-tx when setName is called on the tx.
  if (!transaction.isWeb() &#x26;&#x26; transaction.forceIgnore !== null) {
    transaction.ignore = transaction.forceIgnore
  }

  if (!transaction.ignore) {
    if (transaction.forceIgnore === false) {
      logger.debug(&#x22;Explicitly not ignoring %s.&#x22;, transaction.name)
    }
    this.metrics.merge(transaction.metrics)
    this.errors.onTransactionFinished(transaction, this.metrics)
    this.traces.add(transaction)

    var trace = transaction.trace
    trace.intrinsics = transaction.getIntrinsicAttributes()

    this._addEventFromTransaction(transaction)
  } else if (transaction.forceIgnore === true) {
    logger.debug(&#x22;Explicitly ignoring %s.&#x22;, transaction.name)
  } else {
    logger.debug(&#x22;Ignoring %s.&#x22;, transaction.name)
  }

  this.activeTransactions--
  this.totalActiveSegments -= transaction.numSegments
  this.segmentsClearedInHarvest += transaction.numSegments
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.getTransaction" id="apidoc.element.newrelic.agent.prototype.getTransaction">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>getTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTransaction() {
  return this.tracer.getTransaction()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
API.prototype.setTransactionName = function setTransactionName(name) {
var metric = this.agent.metrics.getOrCreateMetric(
  NAMES.SUPPORTABILITY.API + &#x27;/setTransactionName&#x27;
)
metric.incrementCallCount()

var transaction = this.agent.tracer.<span class="apidocCodeKeywordSpan">getTransaction</span>()
if (!transaction) {
  return logger.warn(&#x22;No transaction found when setting name to &#x27;%s&#x27;.&#x22;, name)
}

if (!name) {
  if (transaction &#x26;&#x26; transaction.url) {
    logger.error(&#x22;Must include name in setTransactionName call for URL %s.&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.harvest" id="apidoc.element.newrelic.agent.prototype.harvest">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>harvest
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function harvest(callback) {
  if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

  var agent = this
  var harvestSteps = [
    &#x27;_sendMetrics&#x27;,
    &#x27;_sendErrors&#x27;,
    &#x27;_sendTrace&#x27;,
    &#x27;_sendEvents&#x27;,
    &#x27;_sendCustomEvents&#x27;,
    &#x27;_sendQueries&#x27;,
    &#x27;_sendErrorEvents&#x27;
  ]

  logger.trace({
    segmentTotal: this.totalActiveSegments,
    harvestCreated: this.segmentsCreatedInHarvest,
    harvestCleared: this.segmentsClearedInHarvest,
    activeTransactions: this.activeTransactions
  }, &#x27;Entity stats on harvest&#x27;)

  this.segmentsCreatedInHarvest = 0
  this.segmentsClearedInHarvest = 0

  if (!this.collector.isConnected()) {
    return process.nextTick(function cb_nextTick() {
      callback(new Error(&#x22;Not connected to New Relic!&#x22;))
    })
  }
  runHarvestStep(0)

  function runHarvestStep(n) {
    agent[harvestSteps[n++]](next)

    function next(error) {
      if (error || n &#x3e;= harvestSteps.length) return callback(error)
      runHarvestStep(n)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  logger.warn(
    &#x27;options.timeout should be of type &#x22;number&#x22;. Got %s&#x27;,
    typeof options.timeout
  )
}

agent.on(&#x27;started&#x27;, function shutdownHarvest() {
  agent.<span class="apidocCodeKeywordSpan">harvest</span>(cb_harvest)
})
agent.on(&#x27;errored&#x27;, function logShutdownError(error) {
  agent.stop(callback)
  if (error) {
    logger.error(
      error,
      &#x27;The agent encountered an error after calling shutdown.&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.reconfigure" id="apidoc.element.newrelic.agent.prototype.reconfigure">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>reconfigure
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reconfigure(configuration) {
  if (!configuration) throw new TypeError(&#x22;must pass configuration&#x22;)

  this.config.onConnect(configuration)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)

// Error tracing.
if (!this.errors) {
  this.errors = new ErrorAggregator(this.config)
}
this.errors.<span class="apidocCodeKeywordSpan">reconfigure</span>(this.config)

// Metrics.
this.mapper = new MetricMapper()
this.metricNameNormalizer = new MetricNormalizer(this.config, &#x27;metric name&#x27;)
this.metrics = new Metrics(this.config.apdex_t, this.mapper, this.metricNameNormalizer)

// Transaction naming.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.reset" id="apidoc.element.newrelic.agent.prototype.reset">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
  // Insights events.
  if (!this.events) {
    this.events = new Reservoir()
  }
  this.events.setLimit(this.config.transaction_events.max_samples_per_minute)
  if (!this.customEvents) {
    this.customEvents = new Reservoir()
  }
  this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)

  // Error tracing.
  if (!this.errors) {
    this.errors = new ErrorAggregator(this.config)
  }
  this.errors.reconfigure(this.config)

  // Metrics.
  this.mapper = new MetricMapper()
  this.metricNameNormalizer = new MetricNormalizer(this.config, &#x27;metric name&#x27;)
  this.metrics = new Metrics(this.config.apdex_t, this.mapper, this.metricNameNormalizer)

  // Transaction naming.
  this.transactionNameNormalizer = new MetricNormalizer(this.config, &#x27;transaction name&#x27;)
  this.urlNormalizer = new MetricNormalizer(this.config, &#x27;URL&#x27;)

  // Segment term based tx renaming for MGI mitigation.
  this.txSegmentNormalizer = new TxSegmentNormalizer()

  // User naming and ignoring rules.
  this.userNormalizer = new MetricNormalizer(this.config, &#x27;user&#x27;)
  this.userNormalizer.loadFromConfig()

  // Supportability.
  if (this.config.debug.internal_metrics) {
    this.config.debug.supportability = new Metrics(
      this.config.apdex_t,
      this.mapper,
      this.metricNameNormalizer
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.mapper = null
this.metricNameNormalizer = null
this.metrics = null
this.transactionNameNormalizer = null
this.urlNormalizer = null
this.txSegmentNormalizer = null
this.userNormalizer = null
this.<span class="apidocCodeKeywordSpan">reset</span>()

// Transaction tracing.
this.tracer = this._setupTracer()
this.traces = new TraceAggregator(this.config)

// Query tracing.
this.queries = new QueryTracer(this.config)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.setState" id="apidoc.element.newrelic.agent.prototype.setState">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>setState
        <span class="apidocSignatureSpan">(newState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setState(newState) {
  if (STATES.indexOf(newState) === -1) {
    throw new TypeError(&#x22;Invalid state &#x22; + newState)
  }
  logger.debug(&#x22;Agent state changed from %s to %s.&#x22;, this._state, newState)
  this._state = newState
  this.emit(this._state)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} callback Continuation and error handler.
 */
Agent.prototype.start = function start(callback) {
  if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

  var agent = this

  this.<span class="apidocCodeKeywordSpan">setState</span>(&#x27;starting&#x27;)

  if (this.config.agent_enabled !== true) {
logger.warn(&#x22;The New Relic Node.js agent is disabled by its configuration. &#x22; +
            &#x22;Not starting!&#x22;)

this.setState(&#x27;stopped&#x27;)
return process.nextTick(callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.start" id="apidoc.element.newrelic.agent.prototype.start">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>start
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start(callback) {
  if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

  var agent = this

  this.setState(&#x27;starting&#x27;)

  if (this.config.agent_enabled !== true) {
    logger.warn(&#x22;The New Relic Node.js agent is disabled by its configuration. &#x22; +
                &#x22;Not starting!&#x22;)

    this.setState(&#x27;stopped&#x27;)
    return process.nextTick(callback)
  }

  if (!(this.config.license_key)) {
    logger.error(&#x22;A valid account license key cannot be found. &#x22; +
                 &#x22;Has a license key been specified in the agent configuration &#x22; +
                 &#x22;file or via the NEW_RELIC_LICENSE_KEY environment variable?&#x22;)

    this.setState(&#x27;errored&#x27;)
    return process.nextTick(function cb_nextTick() {
      callback(new Error(&#x22;Not starting without license key!&#x22;))
    })
  }

  sampler.start(agent)

  logger.info(&#x22;Starting New Relic for Node.js connection process.&#x22;)

  this.collector.connect(function cb_connect(error, config) {
    if (error) {
      agent.setState(&#x27;errored&#x27;)
      return callback(error, config)
    }

    if (agent.collector.isConnected() &#x26;&#x26; !agent.config.no_immediate_harvest) {
      // harvest immediately for quicker data display, but after at least 1
      // second or the collector will throw away the data.
      setTimeout(function one_sec_delayed_harvest() {
        agent.harvest(function cb_harvest(error) {
          agent._startHarvester(agent.config.data_report_period)

          agent.setState(&#x27;started&#x27;)
          callback(error, config)
        })
      }, 1000)
    } else {
      process.nextTick(function cb_nextTick() {
        callback(null, config)
      })
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error(message)
      }

      var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
      shimmer.patchModule(agent)
      shimmer.bootstrapInstrumentation(agent)

      agent.<span class="apidocCodeKeywordSpan">start</span>(function cb_start(error) {
if (!error) {
  return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
}

var errorMessage = &#x22;New Relic for Node.js halted startup due to an error:&#x22;
logger.error(error, errorMessage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.stop" id="apidoc.element.newrelic.agent.prototype.stop">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>stop
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stop(callback) {
  if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

  var agent = this

  this.setState(&#x27;stopping&#x27;)
  this._stopHarvester()
  sampler.stop()

  if (this.collector.isConnected()) {
    this.collector.shutdown(function cb_shutdown(error) {
      if (error) {
        agent.setState(&#x27;errored&#x27;)
        logger.warn(error, &#x22;Got error shutting down connection to New Relic:&#x22;)
      } else {
        agent.setState(&#x27;stopped&#x27;)
        logger.info(&#x22;Stopped New Relic for Node.js.&#x22;)
      }

      callback(error)
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function cb_harvest(error) {
  if (error) {
    logger.error(
      error,
      &#x27;An error occurred while running last harvest before shutdown.&#x27;
    )
  }
  agent.<span class="apidocCodeKeywordSpan">stop</span>(callback)
}

if (options &#x26;&#x26; options.collectPendingData &#x26;&#x26; agent._state !== &#x27;started&#x27;) {
  if (typeof options.timeout === &#x27;number&#x27;) {
    var shutdownTimeout = setTimeout(function shutdownTimeout() {
      agent.stop(callback)
    }, options.timeout)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.aggregator" id="apidoc.module.newrelic.aggregator">module newrelic.aggregator</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.aggregator.aggregator" id="apidoc.element.newrelic.aggregator.aggregator">
        function <span class="apidocSignatureSpan">newrelic.</span>aggregator
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ErrorAggregator(config) {
  this.config = config
  this.errorCount = 0
  this.webTransactionErrorCount = 0
  this.otherTransactionErrorCount = 0
  this.errors = []
  this.seenObjectsByTransaction = {}
  this.seenStringsByTransaction = {}

  // reservoir used for error events
  this.events = new Reservoir(this.config.error_collector.max_event_samples_stored)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.aggregator.prototype" id="apidoc.module.newrelic.aggregator.prototype">module newrelic.aggregator.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype._collect" id="apidoc.element.newrelic.aggregator.prototype._collect">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>_collect
        <span class="apidocSignatureSpan">(transaction, exception, customParameters, timestamp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _collect(transaction, exception, customParameters, timestamp) {
  if (exception) {
    if (this.haveSeen(transaction, exception)) {
      return
    }

    if (typeof exception !== &#x27;string&#x27; &#x26;&#x26; !exception.message &#x26;&#x26; !exception.stack) {
      logger.trace(exception,
        &#x22;Got error that is not an instance of Error or string.&#x22;)
      exception = null
    }
  }

  if (!exception) {
    if (!transaction) return
    if (!transaction.statusCode) return
    if (transaction.error) return
  }

  this.errorCount++

  if (transaction) {
    if (transaction.isWeb()) {
      this.webTransactionErrorCount++
    } else {
      this.otherTransactionErrorCount++
    }
  }

  // allow enabling &#x26; disabling the error tracer at runtime
  // TODO: it would be better to check config in the public add() to prevents collecting
  // errors on the transaction unnecessarily
  if (!this.config.collect_errors ||
      !this.config.error_collector || !this.config.error_collector.enabled) return

  if (exception) {
    logger.trace(exception, &#x22;Got exception to trace:&#x22;)
  }

  var error = createError(transaction, exception, customParameters, this.config)

  if (this.errors.length &#x3c; MAX_ERRORS) {
    logger.debug({error: error}, &#x22;Error to be sent to collector:&#x22;)

    // XXX: 2016-05-24 Remove this when APM UI is updated to use correct request_uri
    //
    // For right now, when this flag is enabled, the request_uri will be added
    // to the error data. This will result in duplicated data being displayed on
    // APM which is a no-go, so we need to remove it here. However, we want the
    // data to still be there for error events metrics, so we need to perform a
    // deep copy and only remove it from this data.
    //
    // In order to save cycles, we perform a smart deep copy in the form of a
    // series of shallow copies down just the path that needs to change.
    if (this.config.feature_flag.send_request_uri_attribute) {
      var err = []
      err.push.apply(err, error)
      err[4] = copy.shallow(err[4])
      err[4].agentAttributes = copy.shallow(err[4].agentAttributes)
      delete err[4].agentAttributes.request_uri
      this.errors.push(err)
    } else {
      this.errors.push(error)
    }
  } else {
    logger.debug(&#x22;Already have %d errors to send to collector, not keeping.&#x22;,
                 MAX_ERRORS)
  }

  // add error event
  if (this.config.error_collector.capture_events === true) {
    this.events.add(createEvent(transaction, error, timestamp))
  }
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// collect user errors even if status code is ignored
var collectedErrors = 0
var exception, i
if (transaction.userErrors.length &#x3e; 0) {
  for (i = 0; i &#x3c; transaction.userErrors.length; i++) {
    exception = transaction.userErrors[i]
    if (this.<span class="apidocCodeKeywordSpan">_collect</span>(transaction, exception[0], exception[1], exception[2])) {
      collectedErrors++
    }
  }
}

var hasExceptions = transaction.exceptions.length &#x3e; 0
var isErroredTransaction = urltils.isError(this.config, transaction.statusCode)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.add" id="apidoc.element.newrelic.aggregator.prototype.add">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>add
        <span class="apidocSignatureSpan">(transaction, exception, customParameters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(transaction, exception, customParameters) {
  if (!exception) return

  var timestamp = Date.now()

  if (transaction) {
    transaction.addException(exception, customParameters, timestamp)
  } else {
    this._collect(transaction, exception, customParameters, timestamp)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 var instrinics = {
   type: eventType,
   timestamp: Date.now()
 }

 this.agent.customEvents.<span class="apidocCodeKeywordSpan">add</span>([instrinics, attributes])
}

/**
* Shuts down the agent.
*
* @param {object}  [options]                           object with shut down options
* @param {boolean} [options.collectPendingData=false]  If true, the agent will send any
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.addUserError" id="apidoc.element.newrelic.aggregator.prototype.addUserError">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>addUserError
        <span class="apidocSignatureSpan">(transaction, exception, customParameters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addUserError(transaction, exception, customParameters) {
  if (!exception) return

  var timestamp = Date.now()

  if (transaction) {
    transaction.addUserError(exception, customParameters, timestamp)
  } else {
    this._collect(transaction, exception, customParameters, timestamp)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 )
 metric.incrementCallCount()


 if (typeof error === &#x27;string&#x27;) error = new Error(error)
 var transaction = this.agent.tracer.getTransaction()

 this.agent.errors.<span class="apidocCodeKeywordSpan">addUserError</span>(transaction, error, customParameters)
}

/**
* If the URL for a transaction matches the provided pattern, name the
* transaction with the provided name. If there are capture groups in the
* pattern (which is a standard JavaScript regular expression, and can be
* passed as either a RegExp or a string), then the substring matches ($1, $2,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.clearErrors" id="apidoc.element.newrelic.aggregator.prototype.clearErrors">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>clearErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearErrors() {
  this.errors = []
  this.seenStringsByTransaction = {}
  this.seenObjectsByTransaction = {}
  this.errorCount = 0
  this.webTransactionErrorCount = 0
  this.otherTransactionErrorCount = 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return process.nextTick(callback)
  }

  var errors = this.errors.getErrors()
  var payload = [this.config.run_id, errors]

  // reset now to avoid losing errors that come in after delivery starts
  this.errors.<span class="apidocCodeKeywordSpan">clearErrors</span>()

  this.collector.errorData(payload, function cb_errorData(error) {
    if (error) agent.errors.merge(errors)

    callback(error)
  })
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.clearEvents" id="apidoc.element.newrelic.aggregator.prototype.clearEvents">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>clearEvents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearEvents() {
  this.events = new Reservoir(this.config.error_collector.max_event_samples_stored)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Log any warnings about dropping events
  if (diff) {
    logger.warn(&#x27;Dropped %s error events out of %s.&#x27;, diff, this.errors.events.seen)
  }

  // clear the reservoir now (instead of at send time) so metrics match
  // what we actually send.
  this.errors.<span class="apidocCodeKeywordSpan">clearEvents</span>()
} else if (events.length &#x3e; 0) {
  // We have events and error events are disabled. Clear everything out so we
  // don&#x27;t hold onto memory that we shouldn&#x27;t. Only time this could happen is
  // if the server sent down settings disabling error events in the middle of
  // a harvest cycle.
  this._lastErrorEvents = []
  this.errors.clearEvents()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.getBackgroundTransactionsErrorCount" id="apidoc.element.newrelic.aggregator.prototype.getBackgroundTransactionsErrorCount">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getBackgroundTransactionsErrorCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOtherTransactionsErrorCount() {
  return this.otherTransactionErrorCount
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.errors.getTotalErrorCount() &#x3e; 0) {
  var count = this.errors.getTotalErrorCount()
  this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount(count)

  count = this.errors.getWebTransactionsErrorCount()
  this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount(count)

  count = this.errors.<span class="apidocCodeKeywordSpan">getBackgroundTransactionsErrorCount</span>()
  this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount(count)
}

if (this.config.debug.supportability) {
  this.metrics.merge(this.config.debug.supportability)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.getErrors" id="apidoc.element.newrelic.aggregator.prototype.getErrors">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getErrors() {
  return this.errors
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    callback(new Error(&#x22;not connected to New Relic (errors will be held)&#x22;))
  })
} else if (this.errors.getTotalErrorCount() &#x3c; 1) {
  logger.debug(&#x22;No errors to send.&#x22;)
  return process.nextTick(callback)
}

var errors = this.errors.<span class="apidocCodeKeywordSpan">getErrors</span>()
var payload = [this.config.run_id, errors]

// reset now to avoid losing errors that come in after delivery starts
this.errors.clearErrors()

this.collector.errorData(payload, function cb_errorData(error) {
  if (error) agent.errors.merge(errors)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.getEvents" id="apidoc.element.newrelic.aggregator.prototype.getEvents">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getEvents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEvents() {
  return this.events.toArray()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * This function takes the error events reservoir, gets stats on it for
 * metric purposes, then instantiates a new error events reservoir. This is
 * so the stats are consistent with what actually gets pushed by the later
 * call to _sendErrorEvents.
 */
Agent.prototype._processErrorEvents = function _processErrorEvents() {
var events = this.errors.<span class="apidocCodeKeywordSpan">getEvents</span>()

this._lastErrorEvents = [
  this.errors.getEventsLimit(),
  this.errors.getEventsSeen(),
  events
]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.getEventsLimit" id="apidoc.element.newrelic.aggregator.prototype.getEventsLimit">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getEventsLimit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEventsLimit() {
  return this.events.limit
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * so the stats are consistent with what actually gets pushed by the later
 * call to _sendErrorEvents.
 */
Agent.prototype._processErrorEvents = function _processErrorEvents() {
var events = this.errors.getEvents()

this._lastErrorEvents = [
  this.errors.<span class="apidocCodeKeywordSpan">getEventsLimit</span>(),
  this.errors.getEventsSeen(),
  events
]

// Create the metrics so they are at least set to 0
var seen = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SEEN)
var sent = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SENT)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.getEventsSeen" id="apidoc.element.newrelic.aggregator.prototype.getEventsSeen">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getEventsSeen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEventsSeen() {
  return this.events.seen
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * call to _sendErrorEvents.
 */
Agent.prototype._processErrorEvents = function _processErrorEvents() {
var events = this.errors.getEvents()

this._lastErrorEvents = [
  this.errors.getEventsLimit(),
  this.errors.<span class="apidocCodeKeywordSpan">getEventsSeen</span>(),
  events
]

// Create the metrics so they are at least set to 0
var seen = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SEEN)
var sent = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SENT)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.getTotalErrorCount" id="apidoc.element.newrelic.aggregator.prototype.getTotalErrorCount">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getTotalErrorCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTotalErrorCount() {
  return this.errorCount
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param {Function} callback Gets any delivery errors.
 */
Agent.prototype._sendMetrics = function _sendMetrics(callback) {
  var agent = this

  if (this.collector.isConnected()) {
    if (this.errors.<span class="apidocCodeKeywordSpan">getTotalErrorCount</span>() &#x3e; 0) {
var count = this.errors.getTotalErrorCount()
this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount(count)

count = this.errors.getWebTransactionsErrorCount()
this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount(count)

count = this.errors.getBackgroundTransactionsErrorCount()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.getWebTransactionsErrorCount" id="apidoc.element.newrelic.aggregator.prototype.getWebTransactionsErrorCount">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>getWebTransactionsErrorCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWebTransactionsErrorCount() {
  return this.webTransactionErrorCount
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var agent = this

  if (this.collector.isConnected()) {
if (this.errors.getTotalErrorCount() &#x3e; 0) {
  var count = this.errors.getTotalErrorCount()
  this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount(count)

  count = this.errors.<span class="apidocCodeKeywordSpan">getWebTransactionsErrorCount</span>()
  this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount(count)

  count = this.errors.getBackgroundTransactionsErrorCount()
  this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount(count)
}

if (this.config.debug.supportability) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.haveSeen" id="apidoc.element.newrelic.aggregator.prototype.haveSeen">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>haveSeen
        <span class="apidocSignatureSpan">(transaction, exception)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function haveSeen(transaction, exception) {
  if (!transaction) {
    transaction = {id: &#x27;Unknown&#x27;}
  }


  if (typeof exception === &#x27;object&#x27;) {
    if (!this.seenObjectsByTransaction[transaction.id]) {
      if (WeakSet) {
        this.seenObjectsByTransaction[transaction.id] = new WeakSet()
      } else {
        this.seenObjectsByTransaction[transaction.id] = []
      }
    }

    var seenObjects = this.seenObjectsByTransaction[transaction.id]

    if (WeakSet) {
      if (seenObjects.has(exception)) {
        return true
      }

      seenObjects.add(exception)
    } else {
      if (seenObjects.indexOf(exception) !== -1) {
        return true
      }

      seenObjects.push(exception)
    }
  } else { // typeof exception !== &#x27;object&#x27;
    if (!this.seenStringsByTransaction[transaction.id]) {
      this.seenStringsByTransaction[transaction.id] = {}
    }

    var seenStrings = this.seenStringsByTransaction[transaction.id]
    if (seenStrings[exception]) {
      return true
    }

    seenStrings[exception] = true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                                       the request (optional).
 * @returns {bool}  True if the error was collected.
 */
ErrorAggregator.prototype._collect = _collect

function _collect(transaction, exception, customParameters, timestamp) {
  if (exception) {
if (this.<span class="apidocCodeKeywordSpan">haveSeen</span>(transaction, exception)) {
  return
}

if (typeof exception !== &#x27;string&#x27; &#x26;&#x26; !exception.message &#x26;&#x26; !exception.stack) {
  logger.trace(exception,
    &#x22;Got error that is not an instance of Error or string.&#x22;)
  exception = null
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.merge" id="apidoc.element.newrelic.aggregator.prototype.merge">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>merge
        <span class="apidocSignatureSpan">(errors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(errors) {
  if (!errors) return

  var len = Math.min(errors.length, MAX_ERRORS - this.errors.length)
  logger.warn(&#x22;Merging %s (of %s) errors for next delivery.&#x22;, len, errors.length)
  for (var i = 0; i &#x3c; len; i++) this.errors.push(errors[i])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof value.totalExclusive === &#x27;number&#x27;) {
  stats.totalExclusive = value.totalExclusive
} else {
  stats.totalExclusive = value.total
}

metric.<span class="apidocCodeKeywordSpan">merge</span>(stats)
}

API.prototype.incrementMetric = function incrementMetric(name, value) {
var metric = this.agent.metrics.getOrCreateMetric(
  NAMES.SUPPORTABILITY.API + &#x27;/incrementMetric&#x27;
)
metric.incrementCallCount()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.mergeEvents" id="apidoc.element.newrelic.aggregator.prototype.mergeEvents">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>mergeEvents
        <span class="apidocSignatureSpan">(events)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mergeEvents(events) {
  this.events.merge(events)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // send data to collector
    agent.collector.errorEvents(payload, function cb_errorEvents(err) {
      if (err &#x26;&#x26; err.statusCode === 413 ) {
        logger.warn(&#x27;request too large; event data dropped&#x27;)
      } else if (err) {
        logger.warn(&#x27;error events failed to send; re-sampling&#x27;)
        agent.errors.<span class="apidocCodeKeywordSpan">mergeEvents</span>(events)
      }
      callback(err)
    })
  } else {
    process.nextTick(callback)
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.onTransactionFinished" id="apidoc.element.newrelic.aggregator.prototype.onTransactionFinished">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>onTransactionFinished
        <span class="apidocSignatureSpan">(transaction, metrics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onTransactionFinished(transaction, metrics) {
  if (!transaction) throw new Error(&#x22;Error collector got a blank transaction.&#x22;)
  if (!metrics) throw new Error(&#x22;Error collector requires metrics to count errors.&#x22;)
  if (transaction.ignore) return

  // collect user errors even if status code is ignored
  var collectedErrors = 0
  var exception, i
  if (transaction.userErrors.length &#x3e; 0) {
    for (i = 0; i &#x3c; transaction.userErrors.length; i++) {
      exception = transaction.userErrors[i]
      if (this._collect(transaction, exception[0], exception[1], exception[2])) {
        collectedErrors++
      }
    }
  }

  var hasExceptions = transaction.exceptions.length &#x3e; 0
  var isErroredTransaction = urltils.isError(this.config, transaction.statusCode)
  var isIgnoredErrorStatusCode = urltils.isIgnoredError(this.config,
      transaction.statusCode)

  // collect other exceptions only if status code is not ignored
  if (hasExceptions &#x26;&#x26; !isIgnoredErrorStatusCode) {
    for (i = 0; i &#x3c; transaction.exceptions.length; i++) {
      exception = transaction.exceptions[i]
      if (this._collect(transaction, exception[0], exception[1], exception[2])) {
        collectedErrors++
      }
    }
  } else if (isErroredTransaction) {
    if (this._collect(transaction)) {
      collectedErrors++
    }
  }

  // the metric should be incremented only if the error was actually collected
  if (collectedErrors &#x3e; 0) {
    var count = metrics.getOrCreateMetric(NAMES.ERRORS.PREFIX + transaction.name)
    count.incrementCallCount(collectedErrors)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (!transaction.ignore) {
  if (transaction.forceIgnore === false) {
    logger.debug(&#x22;Explicitly not ignoring %s.&#x22;, transaction.name)
  }
  this.metrics.merge(transaction.metrics)
  this.errors.<span class="apidocCodeKeywordSpan">onTransactionFinished</span>(transaction, this.metrics)
  this.traces.add(transaction)

  var trace = transaction.trace
  trace.intrinsics = transaction.getIntrinsicAttributes()

  this._addEventFromTransaction(transaction)
} else if (transaction.forceIgnore === true) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aggregator.prototype.reconfigure" id="apidoc.element.newrelic.aggregator.prototype.reconfigure">
        function <span class="apidocSignatureSpan">newrelic.aggregator.prototype.</span>reconfigure
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reconfigure(config) {
  this.config = config
  this.events.setLimit(this.config.error_collector.max_event_samples_stored)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)

// Error tracing.
if (!this.errors) {
  this.errors = new ErrorAggregator(this.config)
}
this.errors.<span class="apidocCodeKeywordSpan">reconfigure</span>(this.config)

// Metrics.
this.mapper = new MetricMapper()
this.metricNameNormalizer = new MetricNormalizer(this.config, &#x27;metric name&#x27;)
this.metrics = new Metrics(this.config.apdex_t, this.mapper, this.metricNameNormalizer)

// Transaction naming.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.apdex" id="apidoc.module.newrelic.apdex">module newrelic.apdex</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.apdex.apdex" id="apidoc.element.newrelic.apdex.apdex">
        function <span class="apidocSignatureSpan">newrelic.</span>apdex
        <span class="apidocSignatureSpan">(apdexT)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ApdexStats(apdexT) {
  if (!apdexT &#x26;&#x26; apdexT !== 0) {
    throw new Error(&#x27;Apdex summary must be created with apdexT.&#x27;)
  }
  this.apdexT = apdexT

  this.satisfying = 0
  this.tolerating = 0
  this.frustrating = 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.apdex.prototype" id="apidoc.module.newrelic.apdex.prototype">module newrelic.apdex.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.apdex.prototype.incrementFrustrating" id="apidoc.element.newrelic.apdex.prototype.incrementFrustrating">
        function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>incrementFrustrating
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function incrementFrustrating() {
  ++this.frustrating
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.apdex.prototype.merge" id="apidoc.element.newrelic.apdex.prototype.merge">
        function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>merge
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(other) {
  this.satisfying += other.satisfying
  this.tolerating += other.tolerating
  this.frustrating += other.frustrating
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof value.totalExclusive === &#x27;number&#x27;) {
  stats.totalExclusive = value.totalExclusive
} else {
  stats.totalExclusive = value.total
}

metric.<span class="apidocCodeKeywordSpan">merge</span>(stats)
}

API.prototype.incrementMetric = function incrementMetric(name, value) {
var metric = this.agent.metrics.getOrCreateMetric(
  NAMES.SUPPORTABILITY.API + &#x27;/incrementMetric&#x27;
)
metric.incrementCallCount()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.apdex.prototype.recordValue" id="apidoc.element.newrelic.apdex.prototype.recordValue">
        function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>recordValue
        <span class="apidocSignatureSpan">(time, overrideApdex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordValue(time, overrideApdex) {
  var apdexT = overrideApdex || this.apdexT
  if (time &#x3c;= apdexT) {
    ++this.satisfying
  } else if (time &#x3c;= 4 * apdexT) {
    ++this.tolerating
  } else {
    ++this.frustrating
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  logger.warn(&#x27;Metric name must be a string&#x27;)
  return
}

var metric = this.agent.metrics.getOrCreateMetric(name)

if (typeof value === &#x27;number&#x27;) {
  metric.<span class="apidocCodeKeywordSpan">recordValue</span>(value)
  return
}

if (typeof value !== &#x27;object&#x27;) {
  logger.warn(&#x27;Metric value must be either a number, or a metric object&#x27;)
  return
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.apdex.prototype.recordValueInMillis" id="apidoc.element.newrelic.apdex.prototype.recordValueInMillis">
        function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>recordValueInMillis
        <span class="apidocSignatureSpan">(timeInMillis, overrideApdex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordValueInMillis(timeInMillis, overrideApdex) {
  this.recordValue(timeInMillis * FROM_MILLIS, overrideApdex * FROM_MILLIS)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.apdex.prototype.toJSON" id="apidoc.element.newrelic.apdex.prototype.toJSON">
        function <span class="apidocSignatureSpan">newrelic.apdex.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
  return [
    this.satisfying,
    this.tolerating,
    this.frustrating,
    this.apdexT,
    this.apdexT,
    0
  ]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this._processCustomEvents()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.<span class="apidocCodeKeywordSpan">toJSON</span>().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}

var metrics = this.metrics
var beginSeconds = metrics.started * FROM_MILLIS
var endSeconds = Date.now() * FROM_MILLIS
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.api" id="apidoc.module.newrelic.api">module newrelic.api</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.api.api" id="apidoc.element.newrelic.api.api">
        function <span class="apidocSignatureSpan">newrelic.</span>api
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function API(agent) {
  this.agent = agent
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.api.prototype" id="apidoc.module.newrelic.api.prototype">module newrelic.api.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.addCustomParameter" id="apidoc.element.newrelic.api.prototype.addCustomParameter">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addCustomParameter
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addCustomParameter(name, value) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/addCustomParameter&#x27;
  )
  metric.incrementCallCount()

  // If high security mode is on, custom params are disabled.
  if (this.agent.config.high_security === true) {
    logger.warnOnce(
      &#x22;Custom params&#x22;,
      &#x22;Custom parameters are disabled by high security mode.&#x22;
    )
    return false
  }

  var ignored = this.agent.config.ignored_params || []

  var transaction = this.agent.tracer.getTransaction()
  if (!transaction) {
    return logger.warn(&#x22;No transaction found for custom parameters.&#x22;)
  }

  var trace = transaction.trace
  if (!trace.custom) {
    return logger.warn(
      &#x22;Couldn&#x27;t add parameter %s to nonexistent custom parameters.&#x22;,
      name
    )
  }

  if (CUSTOM_BLACKLIST.indexOf(name) !== -1) {
    return logger.warn(&#x22;Not overwriting value of NR-only parameter %s.&#x22;, name)
  }

  if (ignored.indexOf(name) !== -1) {
    return logger.warn(&#x22;Not setting ignored parameter name %s.&#x22;, name)
  }

  if (name in trace.custom) {
    logger.debug(
      &#x22;Changing custom parameter %s from %s to %s.&#x22;,
      name,
      trace.custom[name],
      value
    )
  }

  trace.custom[name] = value
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Programmatic version of `rules.ignore` above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. The pattern is mandatory.

### Other API calls

#### newrelic.<span class="apidocCodeKeywordSpan">addCustomParameter</span>(name, value)

Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

#### newrelic.addCustomParameters(params)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.addCustomParameters" id="apidoc.element.newrelic.api.prototype.addCustomParameters">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addCustomParameters
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addCustomParameters(params) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/addCustomParameters&#x27;
  )
  metric.incrementCallCount()

  for (var key in params) {
    if (!params.hasOwnProperty(key)) {
      continue
    }

    this.addCustomParameter(key, params[key])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### newrelic.addCustomParameter(name, value)

Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

#### newrelic.<span class="apidocCodeKeywordSpan">addCustomParameters</span>(params)

Set multiple custom parameter values to be attached to a transaction trace and/or
error in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

Example of setting multiple custom parameters at once:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.addIgnoringRule" id="apidoc.element.newrelic.api.prototype.addIgnoringRule">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addIgnoringRule
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addIgnoringRule(pattern) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/addIgnoringRule&#x27;
  )
  metric.incrementCallCount()

  if (!pattern) return logger.error(&#x22;Must include a URL pattern to ignore.&#x22;)

  this.agent.userNormalizer.addSimple(pattern, null)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### newrelic.addNamingRule(pattern, name)

Programmatic version of `rules.name` above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. Both parameters are mandatory.

#### newrelic.<span class="apidocCodeKeywordSpan">addIgnoringRule</span>(pattern)

Programmatic version of `rules.ignore` above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. The pattern is mandatory.

### Other API calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.addNamingRule" id="apidoc.element.newrelic.api.prototype.addNamingRule">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addNamingRule
        <span class="apidocSignatureSpan">(pattern, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addNamingRule(pattern, name) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/addNamingRule&#x27;
  )
  metric.incrementCallCount()


  if (!name) return logger.error(&#x22;Simple naming rules require a replacement name.&#x22;)

  this.agent.userNormalizer.addSimple(pattern, &#x27;/&#x27; + name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Can also be set via the environment variable `NEW_RELIC_IGNORING_RULES`, with
multiple rules passed in as a list of comma-delimited patterns:
`NEW_RELIC_IGNORING_RULES=&#x27;^/socket\.io/\*/xhr-polling,ignore_me&#x27;` Note that
currently there is no way to escape commas in patterns.

### API for adding naming and ignoring rules

#### newrelic.<span class="apidocCodeKeywordSpan">addNamingRule</span>(pattern, name)

Programmatic version of `rules.name` above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. Both parameters are mandatory.

#### newrelic.addIgnoringRule(pattern)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.createBackgroundTransaction" id="apidoc.element.newrelic.api.prototype.createBackgroundTransaction">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createBackgroundTransaction
        <span class="apidocSignatureSpan">(name, group, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBackgroundTransaction(name, group, handle) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/createBackgroundTransaction&#x27;
  )
  metric.incrementCallCount()

  if (handle === undefined &#x26;&#x26; typeof group === &#x27;function&#x27;) {
    handle = group
    group = &#x27;Nodejs&#x27;
  }
  // FLAG: custom_instrumentation
  if (!this.agent.config.feature_flag.custom_instrumentation) {
    return handle
  }

  var fail = false
  if (!name) {
    logger.warn(&#x27;createBackgroundTransaction called without an url&#x27;)
    fail = true
  }

  if (typeof handle !== &#x27;function&#x27;) {
    logger.warn(
      &#x27;createBackgroundTransaction called with a handle arg that is not a function&#x27;
    )
    fail = true
  }

  if (fail) {
    // If name is undefined but handle is defined we should make a best effort
    // to return it so things don&#x27;t crash.
    return handle
  }

  logger.debug(
    &#x27;creating background transaction generator %s:%s (%s)&#x27;,
    name,
    group,
    handle &#x26;&#x26; handle.name
  )

  var tracer = this.agent.tracer

  return tracer.transactionNestProxy(&#x27;bg&#x27;, function createBackgroundSegment() {
    var tx = tracer.getTransaction()

    logger.debug(
      &#x27;creating background transaction %s:%s (%s) with transaction id: %s&#x27;,
      name,
      group,
      handle &#x26;&#x26; handle.name,
      tx.id
    )

    tx.setBackgroundName(name, group)
    tx.bgSegment = tracer.createSegment(name, recordBackground)
    tx.bgSegment.partialName = group
    tx.bgSegment.start()

    return tracer.bindFunction(handle, tx.bgSegment).apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
independent transaction and any calls within the `handle` will be bound to the
new web transaction.

Custom transactions **must** be ended manually by calling `endTransaction()`.
Timing for custom transaction starts from when the returned wrapped function is
called until `endTransaction()` is called.

#### newrelic.<span class="apidocCodeKeywordSpan">createBackgroundTransaction</span>(name, [group], handle)

`name` is the name of the job. It should be pretty static, and not include job
ids or anything very specific to that run of the job. `group` is optional, and
allows you to group types of jobs together. This should follow similar rules as
the `name`. `handle` is a function that encompases your background job. Both
custom and auto instrumentation will be captured as part of the transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.createTracer" id="apidoc.element.newrelic.api.prototype.createTracer">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createTracer
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTracer(name, callback) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/createTracer&#x27;
  )
  metric.incrementCallCount()

  // FLAG: custom_instrumentation
  if (!this.agent.config.feature_flag.custom_instrumentation) {
    return callback
  }

  var fail = false
  if (!name) {
    logger.warn(&#x27;createTracer called without a name&#x27;)
    fail = true
  }

  if (typeof callback !== &#x27;function&#x27;) {
    logger.warn(&#x27;createTracer called with a callback arg that is not a function&#x27;)
    fail = true
  }

  if (fail) {
    // If name is undefined but callback is defined we should make a best effort
    // to return it so things don&#x27;t crash.
    return callback
  }

  var tracer = this.agent.tracer
  var txn = tracer.getTransaction()
  if (!txn) {
    logger.debug(
      &#x27;createTracer called with %s (%s) outside of a transaction, &#x27; +
        &#x27;unable to create tracer.&#x27;,
      name,
      callback &#x26;&#x26; callback.name
    )
    return callback
  }

  logger.debug(
    &#x27;creating tracer %s (%s) on transaction %s.&#x27;,
    name,
    callback &#x26;&#x26; callback.name,
    txn.id
  )

  var segment = tracer.createSegment(name, customRecorder)
  segment.start()
  return tracer.bindFunction(callback, segment, true)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
called until `endTransaction()` is called.

#### newrelic.endTransaction()

This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.

#### newrelic.<span class="apidocCodeKeywordSpan">createTracer</span>(name, handle)

`name` is the name of the tracer. It will show up as a segment in your
transaction traces and create its own metric. `handle` is the function to be
bound to the tracer.

Timing is from when `createTracer` is called until the `handle` done executing.
This should be called inside of a transaction to get data. If it is called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.createWebTransaction" id="apidoc.element.newrelic.api.prototype.createWebTransaction">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createWebTransaction
        <span class="apidocSignatureSpan">(url, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createWebTransaction(url, handle) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/createWebTransaction&#x27;
  )
  metric.incrementCallCount()

  // FLAG: custom_instrumentation
  if (!this.agent.config.feature_flag.custom_instrumentation) {
    return handle
  }

  var fail = false
  if (!url) {
    logger.warn(&#x27;createWebTransaction called without an url&#x27;)
    fail = true
  }

  if (typeof handle !== &#x27;function&#x27;) {
    logger.warn(&#x27;createWebTransaction called with a handle arg that is not a function&#x27;)
    fail = true
  }

  if (fail) {
    // If name is undefined but handle is defined we should make a best effort
    // to return it so things don&#x27;t crash.
    return handle
  }

  logger.debug(
    &#x27;creating web transaction generator %s (%s).&#x27;,
    url,
    handle &#x26;&#x26; handle.name
  )

  var tracer = this.agent.tracer

  return tracer.transactionNestProxy(&#x27;web&#x27;, function createWebSegment() {
    var tx = tracer.getTransaction()

    logger.debug(
      &#x27;creating web transaction %s (%s) with transaction id: %s&#x27;,
      url,
      handle &#x26;&#x26; handle.name,
      tx.id
    )
    tx.nameState.setName(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url)
    tx.url = url
    tx.applyUserNamingRules(tx.url)
    tx.webSegment = tracer.createSegment(url, recordWeb)
    tx.webSegment.start()

    return tracer.bindFunction(handle, tx.webSegment).apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
varieties of socket servers, and background jobs. These are things that the
agent can&#x27;t automatically instrument because without your knowledge of your
application, the agent can&#x27;t tell when they should begin and end.

Read more at:
https://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/nodejs-custom-instrumentation

#### newrelic.<span class="apidocCodeKeywordSpan">createWebTransaction</span>(url, handle)

`url` is the name of the web transaction. It should be pretty static, not
including anything like user ids or any other data that is very specific to the
request. `handle` is the function you&#x27;d like to wrap in the web transaction.
Both custom and auto instrumentation will be captured as part of the
transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.endTransaction" id="apidoc.element.newrelic.api.prototype.endTransaction">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>endTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endTransaction() {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/endTransaction&#x27;
  )
  metric.incrementCallCount()

  // FLAG: custom_instrumentation
  if (!this.agent.config.feature_flag.custom_instrumentation) {
    return
  }

  var tracer = this.agent.tracer
  var tx = tracer.getTransaction()

  if (tx) {
    if (tx.webSegment) {
      tx.setName(tx.url, 0)
      tx.webSegment.markAsWeb(tx.url)
      tx.webSegment.end()
    } else if (tx.bgSegment) {
      tx.bgSegment.end()
    }
    logger.debug(&#x27;ending transaction with id: %s and name: %s&#x27;, tx.id, tx.name)
    tx.end()
  } else {
    logger.debug(&#x27;endTransaction() called while not in a transaction.&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
transaction and any calls within the `handle` will be bound to the new,
independent background transaction.

Custom transactions **must** be ended manually by calling `endTransaction()`.
Timing for custom transaction starts from when the returned wrapped function is
called until `endTransaction()` is called.

#### newrelic.<span class="apidocCodeKeywordSpan">endTransaction</span>()

This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.

#### newrelic.createTracer(name, handle)

`name` is the name of the tracer. It will show up as a segment in your
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.getBrowserTimingHeader" id="apidoc.element.newrelic.api.prototype.getBrowserTimingHeader">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>getBrowserTimingHeader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getBrowserTimingHeader() {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/getBrowserTimingHeader&#x27;
  )
  metric.incrementCallCount()

  var config = this.agent.config

<span class="apidocCodeCommentSpan">  /**
   * Gracefully fail.
   *
   * Output an HTML comment and log a warning the comment is meant to be
   * innocuous to the end user.
   *
   * @param {number} num          - Error code from `RUM_ISSUES`.
   * @param {bool} [quite=false]  - Be quiet about this failure.
   *
   * @see RUM_ISSUES
   */
</span>  function _gracefail(num, quiet) {
    if (quiet) {
      logger.debug(RUM_ISSUES[num])
    } else {
      logger.warn(RUM_ISSUES[num])
    }
    return &#x27;&#x3c;!-- NREUM: (&#x27; + num + &#x27;) --&#x3e;&#x27;
  }

  var browser_monitoring = config.browser_monitoring

  // config.browser_monitoring should always exist, but we don&#x27;t want the agent
  // to bail here if something goes wrong
  if (!browser_monitoring) return _gracefail(2)

  /* Can control header generation with configuration this setting is only
   * available in the newrelic.js config file, it is not ever set by the
   * server.
   */
  if (!browser_monitoring.enable) {
    // It has been disabled by the user; no need to warn them about their own
    // settings so fail quietly and gracefully.
    return _gracefail(0, true)
  }

  var trans = this.agent.getTransaction()

  // bail gracefully outside a transaction
  if (!trans) return _gracefail(1)

  var name = trans.getName()

  /* If we&#x27;re in an unnamed transaction, add a friendly warning this is to
   * avoid people going crazy, trying to figure out why browser monitoring is
   * not working when they&#x27;re missing a transaction name.
   */
  if (!name) return _gracefail(3)

  var time = trans.timer.getDurationInMillis()

  /*
   * Only the first 13 chars of the license should be used for hashing with
   * the transaction name.
   */
  var key = config.license_key.substr(0, 13)
  var appid = config.application_id

  /* This is only going to work if the agent has successfully handshaked with
   * the collector. If the networks is bad, or there is no license key set in
   * newrelis.js, there will be no application_id set.  We bail instead of
   * outputting null/undefined configuration values.
   */
  if (!appid) return _gracefail(4)

  /* If there is no browser_key, the server has likely decided to disable
   * browser monitoring.
   */
  var licenseKey = browser_monitoring.browser_key
  if (!licenseKey) return _gracefail(5)

  /* If there is no agent_loader script, there is no point
   * in setting the rum data
   */
  var js_agent_loader = browser_monitoring.js_agent_loader
  if (!js_agent_loader) return _gracefail(6)

  /* If rum is enabled, but then later disabled on the server,
   * this is the only parameter that gets updated.
   *
   * This condition should only be met if rum is disabled during
   * the lifetime of an application, and it should be picked up
   * on the next ForceRestart by the collector.
   */
  var loader = browser_monitoring.loader
  if (loader === &#x27;none&#x27;) return _gracefail(7)

  // This hash gets written directly into the browser.
  var rum_hash = {
    agent: browser_monitoring.js_agent_file,
    beacon: browser_monitoring.beacon,
    errorBeacon: browser_monitoring.error_beacon,
    licenseKey: licenseKey,
    applicationID: appid,
    applicationTime: time,
    transactionName: hashes.obfuscateNameUsingKey(name, key),
    queueTime: trans.queueTime,
    ttGuid: trans.id,

    // we don&#x27;t use these parameters yet
    agentToken: null
  }

  // if debugging, do pretty format of JSON
  var tabs = config.browser_monitoring.debug ? 2 : 0
  var json = JSON.stringify(rum_hash, null, tabs)


  // the complete header to be written to the browser
  var out = util.format(
    RUM_STUB,
    json,
    js_agent_loader
  )

  logger.trace(&#x27;generating RUM header&#x27;, out)

  return out
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
times.

Headers must be manually injected, but no extra configuration is necessary to
enable browser timings.

### Basics

- Insert the result of `newrelic.<span class="apidocCodeKeywordSpan">getBrowserTimingHeader</span>()`
into your html page.
- The browser timing headers should be placed in the beginning of your `&#x3c;head&#x3e;` tag.
  - As an exception to the above, for maximum IE compatability, the results of `getBrowserTimingHeader()`
should be placed *after* any `X-UA-COMPATIBLE HTTP-EQUIV` meta tags.
- Do *not* cache the header, call it once for every request.

### Example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.incrementMetric" id="apidoc.element.newrelic.api.prototype.incrementMetric">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>incrementMetric
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function incrementMetric(name, value) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/incrementMetric&#x27;
  )
  metric.incrementCallCount()

  // FLAG: custom_metrics
  if (!this.agent.config.feature_flag.custom_metrics) {
    return
  }

  if (!value &#x26;&#x26; value !== 0) {
    value = 1
  }

  if (typeof value !== &#x27;number&#x27; || value % 1 !== 0) {
    logger.warn(&#x27;Metric Increment value must be an integer&#x27;)
    return
  }

  this.recordMetric(name, {
    count: value,
    total: 0,
    min: 0,
    max: 0,
    sumOfSquares: 0
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`value` is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If `value` is
an object, it must include keys for `count`, `total`, `min`, `max`, and
`sumOfSquares`.

#### newrelic.<span class="apidocCodeKeywordSpan">incrementMetric</span>(name[, amount])

`name` is the metric name to record, it must be a string that beings with
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`amount` is optional, but must be an integer if provided.  `amount` is
the number of times to increment the metrics `count`, it defaults to 1.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.noticeError" id="apidoc.element.newrelic.api.prototype.noticeError">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>noticeError
        <span class="apidocSignatureSpan">(error, customParameters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noticeError(error, customParameters) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/noticeError&#x27;
  )
  metric.incrementCallCount()


  if (typeof error === &#x27;string&#x27;) error = new Error(error)
  var transaction = this.agent.tracer.getTransaction()

  this.agent.errors.addUserError(transaction, error, customParameters)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you **must**
pass `false` as the parameter  in this case `null` or `undefined` will be
ignored.

#### newrelic.<span class="apidocCodeKeywordSpan">noticeError</span>(error, customParameters)

If your app is doing its own error handling with domains or try/catch clauses,
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.recordCustomEvent" id="apidoc.element.newrelic.api.prototype.recordCustomEvent">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>recordCustomEvent
        <span class="apidocSignatureSpan">(eventType, attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordCustomEvent(eventType, attributes) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/recordCustomEvent&#x27;
  )
  metric.incrementCallCount()

  if (!this.agent.config.custom_insights_events.enabled) {
    return
  }
  // Check all the arguments before bailing to give maximum information in a
  // single invocation.
  var fail = false

  if (!eventType || typeof eventType !== &#x27;string&#x27;) {
    logger.warn(
      &#x27;recordCustomEvent requires a string for its first argument, got %s (%s)&#x27;,
      stringify(eventType),
      typeof eventType
    )
    fail = true
  } else if (!CUSTOM_EVENT_TYPE_REGEX.test(eventType)) {
    logger.warn(
      &#x27;recordCustomEvent eventType of %s is invalid, it must match /%s/&#x27;,
      eventType,
      CUSTOM_EVENT_TYPE_REGEX.source
    )
    fail = true
  } else if (eventType.length &#x3e; 255) {
    logger.warn(
      &#x27;recordCustomEvent eventType must have a length less than 256, got %s (%s)&#x27;,
      eventType,
      eventType.length
    )
    fail = true
  }
  // If they don&#x27;t pass an attributes object, or the attributes argument is not
  // an object, or if it is an object and but is actually an array, log a
  // warning and set the fail bit.
  if (!attributes || typeof attributes !== &#x27;object&#x27; || Array.isArray(attributes)) {
    logger.warn(
      &#x27;recordCustomEvent requires an object for its second argument, got %s (%s)&#x27;,
      stringify(attributes),
      typeof attributes
    )
    fail = true
  } else if (_checkKeyLength(attributes, 255)) {
    fail = true
  }

  if (fail) {
    return
  }

  var instrinics = {
    type: eventType,
    timestamp: Date.now()
  }

  this.agent.customEvents.add([instrinics, attributes])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Custom Insights Events
 *
 * Custom insights events are JSON object that are sent to New Relic
 * Insights. You can tell the agent to send your custom events via the
 * `newrelic.<span class="apidocCodeKeywordSpan">recordCustomEvent</span>()` API. These events are sampled once the max
 * reservoir size is reached. You can tune this setting below.
 *
 * Read more here: http://newrelic.com/insights
 */
custom_insights_events: {
  /**
   * If this is disabled, the agent does not collect, nor try to send, custom
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.recordMetric" id="apidoc.element.newrelic.api.prototype.recordMetric">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>recordMetric
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordMetric(name, value) {
  var supportMetric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/recordMetric&#x27;
  )
  supportMetric.incrementCallCount()

  // FLAG: custom_metrics
  if (!this.agent.config.feature_flag.custom_metrics) {
    return
  }

  if (typeof name !== &#x27;string&#x27;) {
    logger.warn(&#x27;Metric name must be a string&#x27;)
    return
  }

  var metric = this.agent.metrics.getOrCreateMetric(name)

  if (typeof value === &#x27;number&#x27;) {
    metric.recordValue(value)
    return
  }

  if (typeof value !== &#x27;object&#x27;) {
    logger.warn(&#x27;Metric value must be either a number, or a metric object&#x27;)
    return
  }

  var stats = {}
  var required = [&#x27;count&#x27;, &#x27;total&#x27;, &#x27;min&#x27;, &#x27;max&#x27;, &#x27;sumOfSquares&#x27;]
  var keyMap = {count: &#x27;callCount&#x27;}

  for (var i = 0, l = required.length; i &#x3c; l; ++i) {
    if (typeof value[required[i]] !== &#x27;number&#x27;) {
      logger.warn(&#x27;Metric object must include &#x27; + required[i] + &#x27; as a number&#x27;)
      return
    }

    var key = keyMap[required[i]] || required[i]
    stats[key] = value[required[i]]
  }

  if (typeof value.totalExclusive === &#x27;number&#x27;) {
    stats.totalExclusive = value.totalExclusive
  } else {
    stats.totalExclusive = value.total
  }

  metric.merge(stats)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
transaction traces and create its own metric. `handle` is the function to be
bound to the tracer.

Timing is from when `createTracer` is called until the `handle` done executing.
This should be called inside of a transaction to get data. If it is called
outside of a transaction it will just pass through.

#### newrelic.<span class="apidocCodeKeywordSpan">recordMetric</span>(name, value)

`name` is the metric name to record, it must be a string that begins with
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`value` is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If `value` is
an object, it must include keys for `count`, `total`, `min`, `max`, and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.setControllerName" id="apidoc.element.newrelic.api.prototype.setControllerName">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setControllerName
        <span class="apidocSignatureSpan">(name, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setControllerName(name, action) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/setControllerName&#x27;
  )
  metric.incrementCallCount()

  var transaction = this.agent.tracer.getTransaction()
  if (!transaction) {
    return logger.warn(&#x22;No transaction found when setting controller to %s.&#x22;, name)
  }

  if (!name) {
    if (transaction &#x26;&#x26; transaction.url) {
      logger.error(&#x22;Must include name in setControllerName call for URL %s.&#x22;,
                   transaction.url)
    } else {
      logger.error(&#x22;Must include name in setControllerName call.&#x22;)
    }

    return
  }

  action = action || transaction.verb || &#x27;GET&#x27;
  transaction.forceName = NAMES.CONTROLLER + &#x27;/&#x27; + name + &#x27;/&#x27; + action
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.

Explicitly calling `newrelic.setTransactionName()` will override any names set
by Express, Restify or Hapi routes. Calls to `newrelic.setTransactionName()` and
`newrelic.<span class="apidocCodeKeywordSpan">setControllerName</span>()` will overwrite each other. The last call made
before the request ends wins.

**VERY IMPORTANT NOTE:** Do not include highly variable information like GUIDs,
numerical IDs, or timestamps in the request names you create. If your request
is slow enough to generate a transaction trace, that trace will contain the
original URL. If you enable parameter capture, the parameters will also be
attached to the trace. The request names are used to group requests for New
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.setIgnoreTransaction" id="apidoc.element.newrelic.api.prototype.setIgnoreTransaction">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setIgnoreTransaction
        <span class="apidocSignatureSpan">(ignored)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setIgnoreTransaction(ignored) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/setIgnoreTransaction&#x27;
  )
  metric.incrementCallCount()

  var transaction = this.agent.tracer.getTransaction()
  if (!transaction) {
    return logger.warn(&#x22;No transaction found to ignore.&#x22;)
  }

  transaction.forceIgnore = ignored
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example of setting multiple custom parameters at once:

```javascript
newrelic.addCustomParameters({test: &#x27;value&#x27;, test2: &#x27;value2&#x27;});
```

#### newrelic.<span class="apidocCodeKeywordSpan">setIgnoreTransaction</span>(ignored)

Tell the module explicitly whether or not a given request should be ignored.
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you **must**
pass `false` as the parameter  in this case `null` or `undefined` will be
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.setTransactionName" id="apidoc.element.newrelic.api.prototype.setTransactionName">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setTransactionName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTransactionName(name) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/setTransactionName&#x27;
  )
  metric.incrementCallCount()

  var transaction = this.agent.tracer.getTransaction()
  if (!transaction) {
    return logger.warn(&#x22;No transaction found when setting name to &#x27;%s&#x27;.&#x22;, name)
  }

  if (!name) {
    if (transaction &#x26;&#x26; transaction.url) {
      logger.error(&#x22;Must include name in setTransactionName call for URL %s.&#x22;,
                   transaction.url)
    } else {
      logger.error(&#x22;Must include name in setTransactionName call.&#x22;)
    }

    return
  }

  transaction.forceName = NAMES.CUSTOM + &#x27;/&#x27; + name
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

is all you need. Please note that you still need to ensure that loading the New
Relic module is the first thing your application does, as it needs to bootstrap
itself before the rest of your application loads, but you can safely require
the module from multiple modules in your application it will only initialize
itself once.

#### newrelic.<span class="apidocCodeKeywordSpan">setTransactionName</span>(name)

Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.

Explicitly calling `newrelic.setTransactionName()` will override any names set
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.shutdown" id="apidoc.element.newrelic.api.prototype.shutdown">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>shutdown
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shutdown(options, cb) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/shutdown&#x27;
  )
  metric.incrementCallCount()

  var callback = cb
  if (!callback) {
    if (typeof options === &#x27;function&#x27;) {
      callback = options
    } else {
      callback = function noop() {}
    }
  }

  var agent = this.agent

  function cb_harvest(error) {
    if (error) {
      logger.error(
        error,
        &#x27;An error occurred while running last harvest before shutdown.&#x27;
      )
    }
    agent.stop(callback)
  }

  if (options &#x26;&#x26; options.collectPendingData &#x26;&#x26; agent._state !== &#x27;started&#x27;) {
    if (typeof options.timeout === &#x27;number&#x27;) {
      var shutdownTimeout = setTimeout(function shutdownTimeout() {
        agent.stop(callback)
      }, options.timeout)
      // timer.unref only in 0.9+
      if (shutdownTimeout.unref) {
        shutdownTimeout.unref()
      }
    } else if (options.timeout) {
      logger.warn(
        &#x27;options.timeout should be of type &#x22;number&#x22;. Got %s&#x27;,
        typeof options.timeout
      )
    }

    agent.on(&#x27;started&#x27;, function shutdownHarvest() {
      agent.harvest(cb_harvest)
    })
    agent.on(&#x27;errored&#x27;, function logShutdownError(error) {
      agent.stop(callback)
      if (error) {
        logger.error(
          error,
          &#x27;The agent encountered an error after calling shutdown.&#x27;
        )
      }
    })
  } else if (options &#x26;&#x26; options.collectPendingData) {
    agent.harvest(cb_harvest)
  } else {
    agent.stop(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
display.

#### newrelic.<span class="apidocCodeKeywordSpan">shutdown</span>([options], callback)

Use this method to gracefully shut down the agent.  When called with
`options.collectPendingData` set to true, the agent will send any pending data to
the New Relic servers before shutting down.  This is useful when you want to shut down
the Node process and make sure that all transactions and/or errors are captured by
New Relic.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.arrays" id="apidoc.module.newrelic.arrays">module newrelic.arrays</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.arrays.find" id="apidoc.element.newrelic.arrays.find">
        function <span class="apidocSignatureSpan">newrelic.arrays.</span>find
        <span class="apidocSignatureSpan">(arr, pred, ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayFind(arr, pred, ctx) {
  var idx = arrayFindIndex(arr, pred, ctx)
  if (idx &#x3e;= 0) {
    return arr[idx]
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.rules = []
logger.debug(&#x22;Received %s %s normalization rule(s) from the server&#x22;,
  json.length, this.type)

json.forEach(function cb_forEach(ruleJSON) {
  // no need to add the same rule twice
  var rule = new Rule(ruleJSON)
  if (!arrUtil.<span class="apidocCodeKeywordSpan">find</span>(this.rules, deepEqual.bind(null, rule))) {
    this.rules.push(rule)
    logger.trace(&#x22;Loaded %s normalization rule: %s&#x22;, this.type, rule)
  }
}, this)

/* I (FLN) always forget this, so making a note: JS sort is always
 * IN-PLACE, even though it returns the sorted array.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.arrays.findIndex" id="apidoc.element.newrelic.arrays.findIndex">
        function <span class="apidocSignatureSpan">newrelic.arrays.</span>findIndex
        <span class="apidocSignatureSpan">(arr, pred, ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayFindIndex(arr, pred, ctx) {
  for (var i = 0; i &#x3c; arr.length; ++i) {
    if (pred.call(ctx, arr[i], i, arr)) {
      return i
    }
  }
  return -1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  replace_all: rule.replace_all,
  replacement: rule.name,
  ignore: false
}

// Find where the rule should be inserted and do so.
var reverse = this.config.feature_flag.reverse_naming_rules
var insert = arrUtil.<span class="apidocCodeKeywordSpan">findIndex</span>(this.rules, function findRule(r) {
  return reverse
    ? r.precedence &#x3e;= json.eval_order
    : r.precedence &#x3e; json.eval_order
})
if (insert === -1) {
  this.rules.push(new Rule(json))
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.arrays.findLast" id="apidoc.element.newrelic.arrays.findLast">
        function <span class="apidocSignatureSpan">newrelic.arrays.</span>findLast
        <span class="apidocSignatureSpan">(arr, pred, ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayFindLast(arr, pred, ctx) {
  var idx = arrayFindLastIndex(arr, pred, ctx)
  if (idx &#x3e;= 0) {
    return arr[idx]
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.arrays.findLastIndex" id="apidoc.element.newrelic.arrays.findLastIndex">
        function <span class="apidocSignatureSpan">newrelic.arrays.</span>findLastIndex
        <span class="apidocSignatureSpan">(arr, pred, ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arrayFindLastIndex(arr, pred, ctx) {
  for (var i = arr.length - 1; i &#x3e;= 0; --i) {
    if (pred.call(ctx, arr[i], i, arr)) {
      return i
    }
  }
  return -1
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
NameState.prototype.popPath = function popPath(path) {
if (this.pathStack.length === 0) {
  return
}

if (path) {
  var idx = arrayUtil.<span class="apidocCodeKeywordSpan">findLastIndex</span>(this.pathStack, function pathMatch(a) {
    return a === path
  })
  if (idx !== -1) {
    this.pathStack.splice(idx)
  }
} else {
  this.pathStack.pop()
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.aws_info" id="apidoc.module.newrelic.aws_info">module newrelic.aws_info</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.aws_info.aws_info" id="apidoc.element.newrelic.aws_info.aws_info">
        function <span class="apidocSignatureSpan">newrelic.</span>aws_info
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchAWSInfo(agent, callback) {
  if (!agent.config.utilization || !agent.config.utilization.detect_aws) {
    return callback(null)
  }

  if (resultDict) {
    return callback(resultDict)
  }

  var awsQuery = module.exports._awsQuery

  awsQuery(&#x27;instance-type&#x27;, agent, function getInstanceType(type) {
    if (!type) return callback(null)
    awsQuery(&#x27;instance-id&#x27;, agent, function getInstanceId(id) {
      if (!id) return callback(null)
      awsQuery(&#x27;placement/availability-zone&#x27;, agent, function getZone(zone) {
        if (!zone) return callback(null)
        resultDict = {
          type: type,
          id: id,
          zone: zone
        }
        return callback(resultDict)
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aws_info._awsQuery" id="apidoc.element.newrelic.aws_info._awsQuery">
        function <span class="apidocSignatureSpan">newrelic.aws_info.</span>_awsQuery
        <span class="apidocSignatureSpan">(key, agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function awsQuery(key, agent, callback) {
  var instanceHost = &#x27;169.254.169.254&#x27;
  var apiVersion = &#x27;2008-02-01&#x27;
  var url = [&#x27;http:/&#x27;, instanceHost, apiVersion, &#x27;meta-data&#x27;, key].join(&#x27;/&#x27;)
  var req = http.get(url, function awsRequest(res) {
    res.pipe(concat(respond))
    function respond(data) {
      var valid = checkResponseString(data)
      if (!valid) {
        var awsError = agent.metrics.getOrCreateMetric(NAMES.UTILIZATION.AWS_ERROR)
        awsError.incrementCallCount()
        logger.debug(&#x27;Response for attribute &#x27; + key + &#x27;: %s&#x27;
          , data)
        data = null
      } else {
        data = data.toString(&#x27;utf8&#x27;)
      }

      agent.removeListener(&#x27;errored&#x27;, abortRequest)
      agent.removeListener(&#x27;stopped&#x27;, abortRequest)
      callback(data)
    }
  })
  req.setTimeout(1000, function awsTimeout() {
    logger.debug(&#x27;Request for attribute %s timed out&#x27;, key)
    callback(null)
  })
  req.on(&#x27;error&#x27;, function awsError(err) {
    logger.debug(&#x27;Message for attribute %s: %s&#x27;, key, err.message)
    callback(null)
  })

  agent.once(&#x27;errored&#x27;, abortRequest)
  agent.once(&#x27;stopped&#x27;, abortRequest)

  function abortRequest() {
    logger.debug(&#x27;Abborting request for attribute %s&#x27;, key)
    req.abort()
    agent.removeListener(&#x27;errored&#x27;, abortRequest)
    agent.removeListener(&#x27;stopped&#x27;, abortRequest)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aws_info.clearCache" id="apidoc.element.newrelic.aws_info.clearCache">
        function <span class="apidocSignatureSpan">newrelic.aws_info.</span>clearCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearAWSCache() {
  resultDict = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.cat" id="apidoc.module.newrelic.cat">module newrelic.cat</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.cat.handleCatHeaders" id="apidoc.element.newrelic.cat.handleCatHeaders">
        function <span class="apidocSignatureSpan">newrelic.cat.</span>handleCatHeaders
        <span class="apidocSignatureSpan">(incomingCatId, obfTransaction, encKey, transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function handleCatHeaders(incomingCatId, obfTransaction, encKey, transaction) {
  var parsedCatId = null
  if (incomingCatId) {
    parsedCatId = hashes.deobfuscateNameUsingKey(
      incomingCatId,
      encKey
    )
  }

  var externalTrans = null
  if (obfTransaction) {
    try {
      externalTrans = JSON.parse(
        hashes.deobfuscateNameUsingKey(obfTransaction, encKey)
      )
    } catch (e) {
      logger.trace(
        &#x27;Got an unparsable CAT header x-newrelic-transaction: %s&#x27;,
        obfTransaction
      )
    }
  }

  parsedHeadersToTrans(parsedCatId, externalTrans, transaction)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (agent.config.feature_flag.cat) {
  var encKey = agent.config.encoding_key
  var incomingCatId = request.headers[NEWRELIC_ID_HEADER]
  var obfTransaction = request.headers[NEWRELIC_TRANSACTION_HEADER]
  var synthHeader = request.headers[NEWRELIC_SYNTHETICS_HEADER]
  if (encKey) {
    cat.<span class="apidocCodeKeywordSpan">handleCatHeaders</span>(incomingCatId, obfTransaction, encKey, transaction)
    if (transaction.incomingCatId) {
      logger.trace(&#x27;Got inbound request CAT headers in transaction %s&#x27;,
        transaction.id)
    }
    if (synthHeader &#x26;&#x26; agent.config.trusted_account_ids) {
      handleSyntheticsHeader(
        synthHeader,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.cat.parsedHeadersToTrans" id="apidoc.element.newrelic.cat.parsedHeadersToTrans">
        function <span class="apidocSignatureSpan">newrelic.cat.</span>parsedHeadersToTrans
        <span class="apidocSignatureSpan">(parsedCatId, externalTrans, transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parsedHeadersToTrans(parsedCatId, externalTrans, transaction) {
  if (typeof parsedCatId === &#x27;string&#x27;) {
    transaction.incomingCatId = parsedCatId
  }

  if (util.isArray(externalTrans)) {
    transaction.referringTransactionGuid = externalTrans[0]
    if (typeof externalTrans[2] === &#x27;string&#x27;) {
      transaction.tripId = externalTrans[2]
    } else if (externalTrans[2]) {
      transaction.invalidIncomingExternalTransaction = true
    }

    if (_isValidReferringHash(externalTrans[3])) {
      transaction.referringPathHash = externalTrans[3]
    } else if (externalTrans[3]) {
      transaction.invalidIncomingExternalTransaction = true
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.codec" id="apidoc.module.newrelic.codec">module newrelic.codec</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.codec.decode" id="apidoc.element.newrelic.codec.decode">
        function <span class="apidocSignatureSpan">newrelic.codec.</span>decode
        <span class="apidocSignatureSpan">(encoded, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode(encoded, callback) {
  zlib.inflate(new Buffer(encoded, &#x27;base64&#x27;), function cb_inflate(err, raw) {
    if (err) return callback(err)

    try {
      return callback(null, JSON.parse(raw))
    } catch (error) {
      return callback(error)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.codec.encode" id="apidoc.element.newrelic.codec.encode">
        function <span class="apidocSignatureSpan">newrelic.codec.</span>encode
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode(data, callback) {
  try {
    zlib.deflate(safeJSON.stringifySync(data), function cb_deflate(err, raw) {
      if (err) return callback(err)

      return callback(null, raw.toString(&#x27;base64&#x27;))
    })
  } catch (err) {
    return callback(err)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.common" id="apidoc.module.newrelic.common">module newrelic.common</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.common.ensurePartialName" id="apidoc.element.newrelic.common.ensurePartialName">
        function <span class="apidocSignatureSpan">newrelic.common.</span>ensurePartialName
        <span class="apidocSignatureSpan">(trans)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensurePartialName(trans) {
  if (trans.nameState.getName() == null ||
      trans.nameState.prefix !== NAMES.EXPRESS.PREFIX) {
    trans.nameState.setPrefix(NAMES.EXPRESS.PREFIX)
    trans.nameState.setVerb(trans.verb)
    trans.nameState.setDelimiter(NAMES.ACTION_DELIMITER)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.config" id="apidoc.module.newrelic.config">module newrelic.config</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.config.config" id="apidoc.element.newrelic.config.config">
        function <span class="apidocSignatureSpan">newrelic.</span>config
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(config) {
  EventEmitter.call(this)

  // 1. start by cloning the defaults
  try {
    var basis = JSON.parse(stringifySync(DEFAULT_CONFIG))
    Object.keys(basis).forEach(function cb_forEach(key) {
      this[key] = basis[key]
    }, this)
  } catch (err) {
    logger.warn(&#x27;Unable to clone the default config, %s: %s&#x27;, DEFAULT_CONFIG_PATH, err)
  }

  if (config &#x26;&#x26;
      (process.env[ENV_MAPPING.ssl] === &#x27;false&#x27; || config.ssl === false) &#x26;&#x26;
      process.env[ENV_MAPPING.port] === undefined &#x26;&#x26; config.port === undefined ) {
    config.port = 80
  }

  // 2. initialize undocumented, internal-only default values

  // feature flags are mostly private settings for gating unreleased features
  // flags are set in the feature_flags.js file
  this.feature_flag = feature_flag.prerelease

  // set by environment
  this.newrelic_home = null
  // set by configuration file loader
  this.config_file_path = null
  // set by collector on handshake
  this.run_id = null
  this.application_id = null
  this.web_transactions_apdex = {}
  this.cross_process_id = null
  this.encoding_key = null
  this.obfuscatedId = null
  this.trusted_account_ids = null

  // how frequently harvester runs
  this.data_report_period = 60

  // this value is arbitrary
  this.max_trace_segments = 900

  // feature level of this account
  this.product_level = 0
  // product-level related
  this.collect_traces = true
  this.collect_errors = true

  // override options for utilization stats
  this.utilization.logical_processors = null
  this.utilization.total_ram_mib = null
  this.utilization.billing_hostname = null

  this.browser_monitoring.loader = &#x27;rum&#x27;
  this.browser_monitoring.loader_version = &#x27;&#x27;

  // Settings to play nice with DLPs (see NODE-1044).
  this.compressed_content_encoding = &#x22;deflate&#x22;  // Deflate or gzip
  this.simple_compression = false               // Disables subcomponent compression
  this.put_for_data_send = false                // Changes http verb for harvest


  // 3. override defaults with values from the loaded / passed configuration
  this._fromPassed(config)

  // 3.5. special values (only Azure environment APP_POOL_ID for now)
  this._fromSpecial()

  // 4. override config with environment variables
  this._fromEnvironment()

  // 5. clean up anything that requires postprocessing
  this._canonicalize()

  // 6. put the version in the config
  this.version = require(&#x27;../package.json&#x27;).version

  // 7. apply high security overrides
  if (this.high_security === true) {
    this._applyHighSecurity()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.getOrCreateInstance" id="apidoc.element.newrelic.config.getOrCreateInstance">
        function <span class="apidocSignatureSpan">newrelic.config.</span>getOrCreateInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOrCreateInstance() {
  if (_configInstance === null) {
    _configInstance = initialize()
  }
  return _configInstance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error(message)
}

logger.debug(&#x22;Current working directory at module load is %s.&#x22;, process.cwd())
logger.debug(&#x22;Process title is %s.&#x22;, process.title)
logger.debug(&#x22;Application was invoked as %s.&#x22;, process.argv.join(&#x27; &#x27;))

var config = require(&#x27;./lib/config.js&#x27;).<span class="apidocCodeKeywordSpan">getOrCreateInstance</span>()

// Get the initialized logger as we likely have a bootstrap logger which
// just pipes to stdout.
logger = require(&#x27;./lib/logger.js&#x27;)

if (!config || !config.agent_enabled) {
  logger.info(&#x22;Module not enabled in configuration; not starting.&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.initialize" id="apidoc.element.newrelic.config.initialize">
        function <span class="apidocSignatureSpan">newrelic.config.</span>initialize
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initialize(config) {
<span class="apidocCodeCommentSpan">  /* When the logger is required here, it bootstraps itself and then
   * injects itself into this module&#x27;s closure via setLogger on the
   * instance of the logger it creates.
   */
</span>  logger = require(&#x27;./logger.js&#x27;)

  if (config) return new Config(config)

  if (isTruthular(process.env.NEW_RELIC_NO_CONFIG_FILE)) {
    config = new Config({})
    if (config.newrelic_home) delete config.newrelic_home
    return config
  }

  var filepath = _findConfigFile()
  if (!filepath) {
    _noConfigFile()
    return null
  }

  try {
    config = new Config(require(filepath).config)
    config.config_file_path = filepath
    logger.debug(&#x22;Using configuration file %s.&#x22;, filepath)

    config.validateFlags()

    return config
  } catch (error) {
    logger.error(error)

    throw new Error(
      &#x22;Unable to read configuration file &#x22; + filepath + &#x22;. A default\n&#x22; +
      &#x22;configuration file can be copied from &#x22; + DEFAULT_CONFIG_PATH + &#x22;\n&#x22; +
      &#x22;and renamed to &#x27;newrelic.js&#x27; in the directory from which you&#x27;ll be starting\n&#x22; +
      &#x22;your application.&#x22;
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.super_" id="apidoc.element.newrelic.config.super_">
        function <span class="apidocSignatureSpan">newrelic.config.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.config.prototype" id="apidoc.module.newrelic.config.prototype">module newrelic.config.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._alwaysUpdateIfChanged" id="apidoc.element.newrelic.config.prototype._alwaysUpdateIfChanged">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_alwaysUpdateIfChanged
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _alwaysUpdateIfChanged(json, key) {
  var value = json[key]
  if (value !== null &#x26;&#x26; value !== undefined &#x26;&#x26; this[key] !== value) {
    if (Array.isArray(value) &#x26;&#x26; Array.isArray(this[key])) {
      value.forEach(function cb_forEach(element) {
        if (this[key].indexOf(element) === -1) this[key].push(element)
      }, this)
    } else {
      this[key] = value
    }
    this.emit(key, value)
    logger.debug(&#x22;Configuration of %s was changed to %s by New Relic.&#x22;, key, value)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handled by config.onConnect
case &#x27;high_security&#x27;:
  break

// always accept these settings
case &#x27;cross_process_id&#x27;:
case &#x27;encoding_key&#x27;:
  this.<span class="apidocCodeKeywordSpan">_alwaysUpdateIfChanged</span>(params, key)
  if (this.cross_process_id &#x26;&#x26; this.encoding_key) {
    this.obfuscatedId = hashes.obfuscateNameUsingKey(this.cross_process_id,
                                                     this.encoding_key)
  }
  break

// always accept these settings
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._applyHighSecurity" id="apidoc.element.newrelic.config.prototype._applyHighSecurity">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_applyHighSecurity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _applyHighSecurity() {
  var config = this
  checkNode(&#x27;&#x27;, this, HIGH_SECURITY_SETTINGS)

  function checkNode(base, target, settings) {
    Object.keys(settings).forEach(checkKey.bind(null, base, target, settings))
  }

  function checkKey(base, target, settings, key) {
    var hsValue = settings[key]


    if (hsValue &#x26;&#x26; typeof hsValue === &#x27;object&#x27;) {
      if (typeof target[key] !== &#x27;object&#x27;) {
        logger.warn(
          &#x27;High Security Mode: %s should be an object, found %s&#x27;,
          key,
          target[key]
        )
        target[key] = {}
      }

      return checkNode(base + key + &#x27;.&#x27;, target[key], hsValue)
    }

    if (target[key] !== hsValue) {
      logger.warn(&#x27;High Security Mode: %s was set to %s, coercing to %s&#x27;,
                  key, target[key], hsValue)
      target[key] = hsValue
      config.emit(base + key, hsValue)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this._canonicalize()

 // 6. put the version in the config
 this.version = require(&#x27;../package.json&#x27;).version

 // 7. apply high security overrides
 if (this.high_security === true) {
   this.<span class="apidocCodeKeywordSpan">_applyHighSecurity</span>()
 }
}
util.inherits(Config, EventEmitter)

/**
* Because this module and logger depend on each other, the logger needs
* a way to inject the actual logger instance once it&#x27;s constructed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._canonicalize" id="apidoc.element.newrelic.config.prototype._canonicalize">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_canonicalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _canonicalize() {
  var codes = this.error_collector &#x26;&#x26; this.error_collector.ignore_status_codes
  if (codes) {
    this.error_collector.ignore_status_codes = codes.map(function cb_map(code) {
      return parseInt(code, 10)
    })
  }

  var logAliases = {
    &#x27;verbose&#x27;: &#x27;trace&#x27;,
    &#x27;debugging&#x27;: &#x27;debug&#x27;,
    &#x27;warning&#x27;: &#x27;warn&#x27;,
    &#x27;err&#x27;: &#x27;error&#x27;
  }
  var level = this.logging.level
  this.logging.level = logAliases[level] || level
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3.5. special values (only Azure environment APP_POOL_ID for now)
this._fromSpecial()

// 4. override config with environment variables
this._fromEnvironment()

// 5. clean up anything that requires postprocessing
this.<span class="apidocCodeKeywordSpan">_canonicalize</span>()

// 6. put the version in the config
this.version = require(&#x27;../package.json&#x27;).version

// 7. apply high security overrides
if (this.high_security === true) {
  this._applyHighSecurity()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._emitIfSet" id="apidoc.element.newrelic.config.prototype._emitIfSet">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_emitIfSet
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _emitIfSet(json, key) {
  var value = json[key]
  if (value !== null &#x26;&#x26; value !== undefined) this.emit(key, value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break

// also accept these settings
case &#x27;url_rules&#x27;:
case &#x27;metric_name_rules&#x27;:
case &#x27;transaction_name_rules&#x27;:
case &#x27;transaction_segment_terms&#x27;:
  this.<span class="apidocCodeKeywordSpan">_emitIfSet</span>(params, key)
  break

// setting these can be disabled by ignore_server_configuration
case &#x27;ssl&#x27;:
case &#x27;apdex_t&#x27;:
case &#x27;web_transactions_apdex&#x27;:
case &#x27;data_report_period&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._fromEnvironment" id="apidoc.element.newrelic.config.prototype._fromEnvironment">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromEnvironment
        <span class="apidocSignatureSpan">(metadata, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fromEnvironment(metadata, data) {
  if (!metadata) metadata = ENV_MAPPING
  if (!data) data = this

  Object.keys(metadata).forEach(function cb_forEach(value) {
    // if it&#x27;s not in the config, it doesn&#x27;t exist
    if (data[value] === undefined) return

    var node = metadata[value]
    if (typeof node === &#x27;string&#x27;) {
      var setting = process.env[node]
      if (setting) {
        if (LIST_VARS.indexOf(node) &#x3e; -1) {
          data[value] = setting.split(&#x27;,&#x27;).map(function cb_map(k) {
            return k.trim()
          })
        } else if (OBJECT_LIST_VARS.indexOf(node) &#x3e; -1) {
          data[value] = fromObjectList(setting)
        } else if (BOOLEAN_VARS.indexOf(node) &#x3e; -1) {
          data[value] = isTruthular(setting)
        } else if (FLOAT_VARS.indexOf(node) &#x3e; -1) {
          data[value] = parseFloat(setting, 10)
        } else if (INT_VARS.indexOf(node) &#x3e; -1) {
          data[value] = parseInt(setting, 10)
        } else {
          data[value] = setting
        }
      }
    } else {
      // don&#x27;t crash if the mapping has config keys the current config doesn&#x27;t.
      if (!data[value]) data[value] = {}
      this._fromEnvironment(node, data[value])
    }
  }, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3. override defaults with values from the loaded / passed configuration
this._fromPassed(config)

// 3.5. special values (only Azure environment APP_POOL_ID for now)
this._fromSpecial()

// 4. override config with environment variables
this.<span class="apidocCodeKeywordSpan">_fromEnvironment</span>()

// 5. clean up anything that requires postprocessing
this._canonicalize()

// 6. put the version in the config
this.version = require(&#x27;../package.json&#x27;).version
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._fromPassed" id="apidoc.element.newrelic.config.prototype._fromPassed">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromPassed
        <span class="apidocSignatureSpan">(external, internal, arbitrary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fromPassed(external, internal, arbitrary) {
  if (!external) return
  if (!internal) internal = this

  Object.keys(external).forEach(function cb_forEach(key) {
    // if it&#x27;s not in the defaults, it doesn&#x27;t exist
    if (!arbitrary &#x26;&#x26; internal[key] === undefined) return

    try {
      var node = external[key]
    } catch (err) {
      logger.warn(&#x27;Error thrown on access of user config for key: %s&#x27;, key)
      return
    }

    if (Array.isArray(node)) {
      internal[key] = node
    } else if (typeof node === &#x27;object&#x27;) {
      // is top level and can have arbitrary keys
      if (internal === this &#x26;&#x26; HAS_ARBITRARY_KEYS.indexOf(key) !== -1) {
        this._fromPassed(node, internal[key], true)
      } else {
        this._fromPassed(node, internal[key], false)
      }
    } else {
      internal[key] = node
    }
  }, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Settings to play nice with DLPs (see NODE-1044).
this.compressed_content_encoding = &#x22;deflate&#x22;  // Deflate or gzip
this.simple_compression = false               // Disables subcomponent compression
this.put_for_data_send = false                // Changes http verb for harvest


// 3. override defaults with values from the loaded / passed configuration
this.<span class="apidocCodeKeywordSpan">_fromPassed</span>(config)

// 3.5. special values (only Azure environment APP_POOL_ID for now)
this._fromSpecial()

// 4. override config with environment variables
this._fromEnvironment()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._fromServer" id="apidoc.element.newrelic.config.prototype._fromServer">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromServer
        <span class="apidocSignatureSpan">(params, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fromServer(params, key) {
  switch (key) {
    // handled by the connection
    case &#x27;messages&#x27;:
      break

    // *sigh* Xzibit, etc.
    case &#x27;agent_config&#x27;:
      this.onConnect(params[key], true)
      break

    // if it&#x27;s undefined or null, so be it
    case &#x27;agent_run_id&#x27;:
      this.run_id = params.agent_run_id
      break

    // handled by config.onConnect
    case &#x27;high_security&#x27;:
      break

    // always accept these settings
    case &#x27;cross_process_id&#x27;:
    case &#x27;encoding_key&#x27;:
      this._alwaysUpdateIfChanged(params, key)
      if (this.cross_process_id &#x26;&#x26; this.encoding_key) {
        this.obfuscatedId = hashes.obfuscateNameUsingKey(this.cross_process_id,
                                                         this.encoding_key)
      }
      break

    // always accept these settings
    case &#x27;collect_traces&#x27;:
    case &#x27;collect_errors&#x27;:
    case &#x27;product_level&#x27;:
    case &#x27;application_id&#x27;:
    case &#x27;trusted_account_ids&#x27;:
      this._alwaysUpdateIfChanged(params, key)
      break

    case &#x27;collect_error_events&#x27;:
      if (params.collect_error_events === false) {
        this._updateNestedIfChanged(
          params,
          this.error_collector,
          key,
          &#x27;capture_events&#x27;
        )
      }
      break

    // also accept these settings
    case &#x27;url_rules&#x27;:
    case &#x27;metric_name_rules&#x27;:
    case &#x27;transaction_name_rules&#x27;:
    case &#x27;transaction_segment_terms&#x27;:
      this._emitIfSet(params, key)
      break

    // setting these can be disabled by ignore_server_configuration
    case &#x27;ssl&#x27;:
    case &#x27;apdex_t&#x27;:
    case &#x27;web_transactions_apdex&#x27;:
    case &#x27;data_report_period&#x27;:
    case &#x27;ignored_params&#x27;:
      this._updateIfChanged(params, key)
      break
    case &#x27;transaction_tracer.enabled&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_tracer,
        &#x27;transaction_tracer.enabled&#x27;,
        &#x27;enabled&#x27;
      )
      break
    case &#x27;transaction_tracer.transaction_threshold&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_tracer,
        &#x27;transaction_tracer.transaction_threshold&#x27;,
        &#x27;transaction_threshold&#x27;
      )
      break
    case &#x27;error_collector.enabled&#x27;:
      this._updateNestedIfChanged(
        params,
        this.error_collector,
        &#x27;error_collector.enabled&#x27;,
        &#x27;enabled&#x27;
      )
      break
    case &#x27;error_collector.ignore_status_codes&#x27;:
      this._updateNestedIfChanged(
        params,
        this.error_collector,
        &#x27;error_collector.ignore_status_codes&#x27;,
        &#x27;ignore_status_codes&#x27;
      )
      this._canonicalize()
      break

    case &#x27;error_collector.capture_events&#x27;:
      this._updateNestedIfChanged(
        params,
        this.error_collector,
        &#x27;error_collector.capture_events&#x27;,
        &#x27;capture_events&#x27;
      )
      break

    case &#x27;error_collector.max_event_samples_stored&#x27;:
      this._updateNestedIfChanged(
        params,
        this.error_collector,
        &#x27;error_collector.max_event_samples_stored&#x27;,
        &#x27;max_event_samples_stored&#x27;
      )
      break

    case &#x27;collect_analytics_events&#x27;:
      // never enable from server-side
      // but we allow the server to disable
      if (params.collect_analytics_events === false)
        this.transaction_events.enabled = false
      break

    case &#x27;collect_custom_events&#x27;:
      // never enable from server-side
      // but we allow the server to disable
      if (params.collect_custom_events === false)
        this.custom_insights_events.enabled = false
      break

    case &#x27;transaction_events.max_samples_stored&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_events,
        key,
        &#x27;max_samples_stored&#x27;
      )
      break

    case &#x27;transaction_events.max_samples_per_minute&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_events,
        key,
        &#x27;max_samples_per_minute&#x27;
      )
      break

    case &#x27;transaction_events.enabled&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_events,
        key,
        &#x27;enabled&#x27;
      ) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.agent_enabled = false
   this.emit(&#x27;agent_enabled&#x27;, false)
   return
 }
 if (Object.keys(json).length === 0) return

 Object.keys(json).forEach(function cb_forEach(key) {
   this.<span class="apidocCodeKeywordSpan">_fromServer</span>(json, key)
 }, this)

 this.emit(&#x27;change&#x27;, this)
}

/**
* The guts of the logic about how to deal with server-side configuration.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._fromSpecial" id="apidoc.element.newrelic.config.prototype._fromSpecial">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromSpecial
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fromSpecial() {
  var name = this.app_name
  if (name === null || name === undefined || name === &#x27;&#x27; ||
      (Array.isArray(name) &#x26;&#x26; name.length === 0)) {
    var azureName = process.env[AZURE_APP_NAME]
    if (azureName) this.app_name = azureName.split(&#x27;,&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.put_for_data_send = false                // Changes http verb for harvest


// 3. override defaults with values from the loaded / passed configuration
this._fromPassed(config)

// 3.5. special values (only Azure environment APP_POOL_ID for now)
this.<span class="apidocCodeKeywordSpan">_fromSpecial</span>()

// 4. override config with environment variables
this._fromEnvironment()

// 5. clean up anything that requires postprocessing
this._canonicalize()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._updateIfChanged" id="apidoc.element.newrelic.config.prototype._updateIfChanged">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateIfChanged
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _updateIfChanged(json, key) {
  this._updateNestedIfChanged(json, this, key, key)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// setting these can be disabled by ignore_server_configuration
case &#x27;ssl&#x27;:
case &#x27;apdex_t&#x27;:
case &#x27;web_transactions_apdex&#x27;:
case &#x27;data_report_period&#x27;:
case &#x27;ignored_params&#x27;:
  this.<span class="apidocCodeKeywordSpan">_updateIfChanged</span>(params, key)
  break
case &#x27;transaction_tracer.enabled&#x27;:
  this._updateNestedIfChanged(
    params,
    this.transaction_tracer,
    &#x27;transaction_tracer.enabled&#x27;,
    &#x27;enabled&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._updateNestedIfChanged" id="apidoc.element.newrelic.config.prototype._updateNestedIfChanged">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateNestedIfChanged
        <span class="apidocSignatureSpan">(remote, local, remoteKey, localKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _updateNestedIfChanged(remote, local, remoteKey, localKey) {
  if (this.ignore_server_configuration) return this.logDisabled(remote, remoteKey)
  // if high-sec mode is enabled, we do not accept server changes to high-sec
  if (this.high_security &#x26;&#x26; HIGH_SECURITY_KEYS.indexOf(localKey) !== -1) {
    return this.logDisabled(remote, remoteKey)
  }
  return this._updateNestedIfChangedRaw(remote, local, remoteKey, localKey)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;application_id&#x27;:
case &#x27;trusted_account_ids&#x27;:
  this._alwaysUpdateIfChanged(params, key)
  break

case &#x27;collect_error_events&#x27;:
  if (params.collect_error_events === false) {
    this.<span class="apidocCodeKeywordSpan">_updateNestedIfChanged</span>(
      params,
      this.error_collector,
      key,
      &#x27;capture_events&#x27;
    )
  }
  break
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._updateNestedIfChangedRaw" id="apidoc.element.newrelic.config.prototype._updateNestedIfChangedRaw">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateNestedIfChangedRaw
        <span class="apidocSignatureSpan">( remote, local, remoteKey, localKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _updateNestedIfChangedRaw( remote, local, remoteKey, localKey) {
  var value = remote[remoteKey]
  if (value !== null &#x26;&#x26; value !== undefined &#x26;&#x26; local[localKey] !== value) {
    if (Array.isArray(value) &#x26;&#x26; Array.isArray(local[localKey])) {
      value.forEach(function cb_forEach(element) {
        if (local[localKey].indexOf(element) === -1) local[localKey].push(element)
      })
    } else {
      local[localKey] = value
    }
    this.emit(remoteKey, value)
    logger.debug(&#x22;Configuration of %s was changed to %s by New Relic.&#x22;, remoteKey, value)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// and the api.getRUMHeader() method
case &#x27;js_agent_file&#x27;:
case &#x27;js_agent_loader_file&#x27;:
case &#x27;beacon&#x27;:
case &#x27;error_beacon&#x27;:
case &#x27;browser_key&#x27;:
case &#x27;js_agent_loader&#x27;:
  this.<span class="apidocCodeKeywordSpan">_updateNestedIfChangedRaw</span>(
    params,
    this.browser_monitoring,
    key,
    key
  )
  break
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.applications" id="apidoc.element.newrelic.config.prototype.applications">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>applications
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applications() {
  var apps = this.app_name

  if (Array.isArray(apps) &#x26;&#x26; apps.length &#x3e; 0) {
    return apps
  }

  if (apps &#x26;&#x26; typeof apps === &#x27;string&#x27;) {
    return [apps]
  }

  return []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * The agent must be a singleton, or else module loading will be patched
 * multiple times, with undefined results. New Relic&#x27;s instrumentation
 * can&#x27;t be enabled or disabled without an application restart.
 */
var Agent = require(&#x27;./lib/agent.js&#x27;)
agent = new Agent(config)
var appNames = agent.config.<span class="apidocCodeKeywordSpan">applications</span>()

if (config.logging.diagnostics) {
  logger.warn(
    &#x27;Diagnostics logging is enabled, this may cause significant overhead.&#x27;
  )
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.clearDisplayHostCache" id="apidoc.element.newrelic.config.prototype.clearDisplayHostCache">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>clearDisplayHostCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearDisplayHostCache() {
  this.getDisplayHost = getDisplayHost
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.clearHostnameCache" id="apidoc.element.newrelic.config.prototype.clearHostnameCache">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>clearHostnameCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearHostnameCache() {
  this.getHostnameSafe = getHostnameSafe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.getDisplayHost" id="apidoc.element.newrelic.config.prototype.getDisplayHost">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getDisplayHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDisplayHost() {
  var _displayHost
  this.getDisplayHost = function getCachedDisplayHost() {
    return _displayHost
  }
  if (this.process_host.display_name === &#x27;&#x27;) {
    _displayHost = this.getHostnameSafe()
    return _displayHost
  }
  var stringBuffer = new Buffer(this.process_host.display_name, &#x27;utf8&#x27;)
  var numBytes = stringBuffer.length

  if (numBytes &#x3e; 255) {
    logger.warn(&#x27;Custom host display name must be less than 255 bytes&#x27;)
    _displayHost = this.getHostnameSafe()
    return _displayHost
  }

  _displayHost = this.process_host.display_name
  return _displayHost
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  metadata_version: 2,
  logical_processors: systemInfo.logicalProcessors,
  total_ram_mib: systemInfo.memory,
  hostname: hostname
},
pid: process.pid,
host: hostname,
display_host: agent.config.<span class="apidocCodeKeywordSpan">getDisplayHost</span>() || hostname,
language: &#x27;nodejs&#x27;,
app_name: agent.config.applications(),
agent_version: agent.version,
environment: agent.environment,
settings: agent.config.publicSettings(),
high_security: agent.config.high_security,
labels: parse_labels(agent.config.labels)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.getHostnameSafe" id="apidoc.element.newrelic.config.prototype.getHostnameSafe">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getHostnameSafe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHostnameSafe() {
  var _hostname
  this.getHostnameSafe = function getCachedHostname() {
    return _hostname
  }
  try {
    _hostname = os.hostname()
    return _hostname
  } catch (e) {
    var addresses = this.getIPAddresses()

    if (this.process_host.ipv_preference === &#x27;6&#x27; &#x26;&#x26; addresses.ipv6) {
      _hostname = addresses.ipv6
    } else if (addresses.ipv4) {
      logger.info(&#x27;Defaulting to ipv4 address for host name&#x27;)
      _hostname = addresses.ipv4
    } else if (addresses.ipv6) {
      logger.info(&#x27;Defaulting to ipv6 address for host name&#x27;)
      _hostname = addresses.ipv6
    } else {
      logger.info(&#x27;No hostname, ipv4, or ipv6 address found for machine&#x27;)
      _hostname = &#x27;UNKNOWN_BOX&#x27;
    }

    return _hostname
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getDisplayHost() {
var _displayHost
this.getDisplayHost = function getCachedDisplayHost() {
  return _displayHost
}
if (this.process_host.display_name === &#x27;&#x27;) {
  _displayHost = this.<span class="apidocCodeKeywordSpan">getHostnameSafe</span>()
  return _displayHost
}
var stringBuffer = new Buffer(this.process_host.display_name, &#x27;utf8&#x27;)
var numBytes = stringBuffer.length

if (numBytes &#x3e; 255) {
  logger.warn(&#x27;Custom host display name must be less than 255 bytes&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.getIPAddresses" id="apidoc.element.newrelic.config.prototype.getIPAddresses">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getIPAddresses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIPAddresses() {
  var addresses = {}
  var interfaces = os.networkInterfaces()

  for (var interfaceKey in interfaces) {
    if (interfaceKey.match(/^lo/)) continue

    var interfaceDescriptions = interfaces[interfaceKey]
    for (var i = 0; i &#x3c; interfaceDescriptions.length; i++) {
      var description = interfaceDescriptions[i]
      var family = description.family.toLowerCase()
      addresses[family] = description.address
    }
  }
  return addresses
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.getHostnameSafe = function getCachedHostname() {
return _hostname
  }
  try {
_hostname = os.hostname()
return _hostname
  } catch (e) {
var addresses = this.<span class="apidocCodeKeywordSpan">getIPAddresses</span>()

if (this.process_host.ipv_preference === &#x27;6&#x27; &#x26;&#x26; addresses.ipv6) {
  _hostname = addresses.ipv6
} else if (addresses.ipv4) {
  logger.info(&#x27;Defaulting to ipv4 address for host name&#x27;)
  _hostname = addresses.ipv4
} else if (addresses.ipv6) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.logDisabled" id="apidoc.element.newrelic.config.prototype.logDisabled">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logDisabled
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function logDisabled(json, key) {
  var value = json[key]
  if (value !== null &#x26;&#x26; value !== undefined) {
    logger.debug(
      &#x22;Server-side configuration of %s is currently disabled by local configuration. &#x22; +
      &#x22;(Server sent value of %s.)&#x22;,
      key,
      value
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} local     A portion of this configuration object.
 * @param {string} remoteKey The name sent by New Relic.
 * @param {string} localKey  The local name.
 */
Config.prototype._updateNestedIfChanged = _updateNestedIfChanged

function _updateNestedIfChanged(remote, local, remoteKey, localKey) {
  if (this.ignore_server_configuration) return this.<span class="apidocCodeKeywordSpan">logDisabled</span>(remote, remoteKey)
  // if high-sec mode is enabled, we do not accept server changes to high-sec
  if (this.high_security &#x26;&#x26; HIGH_SECURITY_KEYS.indexOf(localKey) !== -1) {
    return this.logDisabled(remote, remoteKey)
  }
  return this._updateNestedIfChangedRaw(remote, local, remoteKey, localKey)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.logUnknown" id="apidoc.element.newrelic.config.prototype.logUnknown">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logUnknown
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function logUnknown(json, key) {
  var value = json[key]
  logger.debug(
    &#x22;New Relic sent unknown configuration parameter %s with value %s.&#x22;,
    key,
    value
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   case &#x27;transaction_tracer.record_sql&#x27;:
   case &#x27;slow_sql.enabled&#x27;:
   case &#x27;rum.load_episodes_file&#x27;:
     this.logUnsupported(params, key)
     break

   default:
     this.<span class="apidocCodeKeywordSpan">logUnknown</span>(params, key)
 }
}

/**
* Change a value sent by the collector if and only if it&#x27;s different from the
* value we already have. Emit an event with the key name and the new value,
* and log that the value has changed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.logUnsupported" id="apidoc.element.newrelic.config.prototype.logUnsupported">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logUnsupported
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function logUnsupported(json, key) {
  var flavor
  if (this.ignore_server_configuration) {
    flavor = &#x22;ignored&#x22;
  } else {
    flavor = &#x22;not supported by the Node.js agent&#x22;
  }

  var value = json[key]
  if (value !== null &#x26;&#x26; value !== undefined) {
    logger.debug(
      &#x22;Server-side configuration of %s is currently %s. (Server sent value of %s.)&#x22;,
      key,
      flavor,
      value
    )
    this.emit(key, value)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case &#x27;sampling_rate&#x27;:
    case &#x27;episodes_file&#x27;:
    case &#x27;episodes_url&#x27;:
    case &#x27;cross_application_tracing&#x27;:
    case &#x27;transaction_tracer.record_sql&#x27;:
    case &#x27;slow_sql.enabled&#x27;:
    case &#x27;rum.load_episodes_file&#x27;:
      this.<span class="apidocCodeKeywordSpan">logUnsupported</span>(params, key)
      break

    default:
      this.logUnknown(params, key)
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.measureInternal" id="apidoc.element.newrelic.config.prototype.measureInternal">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>measureInternal
        <span class="apidocSignatureSpan">(suffix, duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function measureInternal(suffix, duration) {
  if (this.debug.supportability) {
    var internal = this.debug.supportability
    internal.measureMilliseconds(NAMES.SUPPORTABILITY.PREFIX + suffix, null, duration)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.onConnect" id="apidoc.element.newrelic.config.prototype.onConnect">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>onConnect
        <span class="apidocSignatureSpan">(json, recursion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onConnect(json, recursion) {
  json = json || {}
  if (this.high_security === true &#x26;&#x26; recursion !== true &#x26;&#x26; json.high_security !== true) {
    this.agent_enabled = false
    this.emit(&#x27;agent_enabled&#x27;, false)
    return
  }
  if (Object.keys(json).length === 0) return

  Object.keys(json).forEach(function cb_forEach(key) {
    this._fromServer(json, key)
  }, this)

  this.emit(&#x27;change&#x27;, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* decoupled.
*
* @param {object} configuration New config JSON from the collector.
*/
Agent.prototype.reconfigure = function reconfigure(configuration) {
 if (!configuration) throw new TypeError(&#x22;must pass configuration&#x22;)

 this.config.<span class="apidocCodeKeywordSpan">onConnect</span>(configuration)
}

/**
* Make it easier to determine what state the agent thinks it&#x27;s in (needed
* for a few tests, but fragile).
*
* FIXME: remove the need for this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.publicSettings" id="apidoc.element.newrelic.config.prototype.publicSettings">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>publicSettings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publicSettings() {
  var settings = {}

  for (var key in this) {
    if (this.hasOwnProperty(key)) {
      var item = this[key]

      if (REDACT_BEFORE_SEND.indexOf(key) &#x3e; -1) {
        item = &#x27;****&#x27;
      }

      if (REMOVE_BEFORE_SEND.indexOf(key) === -1) {
        settings[key] = item
      }
    }
  }

  // Agent-side setting is &#x27;enable&#x27;, but collector-side setting is
  // &#x27;auto_instrument&#x27;. Send both values up.
  settings.browser_monitoring.auto_instrument = settings.browser_monitoring.enable

  // Remove simple circular references
  parse(stringifySync(settings), function cb_parse(err, settingsCopy) {
    if (err === null) {
      settings = flatten({}, &#x27;&#x27;, settingsCopy)
    } else {
      logger.warn(&#x27;Error while creating deep copy: %s&#x27;, err)
    }
  })

  return settings
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pid: process.pid,
  host: hostname,
  display_host: agent.config.getDisplayHost() || hostname,
  language: &#x27;nodejs&#x27;,
  app_name: agent.config.applications(),
  agent_version: agent.version,
  environment: agent.environment,
  settings: agent.config.<span class="apidocCodeKeywordSpan">publicSettings</span>(),
  high_security: agent.config.high_security,
  labels: parse_labels(agent.config.labels)
}

// TODO:  After reconfiguring agent startup to wait for the server to start
//        or for the first transaction, add the `port` for the server too.
// NOTE: The concat is necessary to prevent sort from happening in-place.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.setLogger" id="apidoc.element.newrelic.config.prototype.setLogger">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>setLogger
        <span class="apidocSignatureSpan">(bootstrapped)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLogger(bootstrapped) {
  logger = bootstrapped
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          /* eslint-enable no-console */
        })
    }
    module.exports.pipe(stream)
  }

  // now tell the config module to switch to the real logger
  config.<span class="apidocCodeKeywordSpan">setLogger</span>(module.exports)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.validateFlags" id="apidoc.element.newrelic.config.prototype.validateFlags">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>validateFlags
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateFlags() {
  Object.keys(this.feature_flag).forEach(function cb_forEach(key) {
    if (feature_flag.released.indexOf(key) &#x3e; -1) {
      logger.warn(&#x27;Feature flag &#x27; + key + &#x27; has been released&#x27;)
    }
    if (feature_flag.unreleased.indexOf(key) &#x3e; -1) {
      logger.warn(&#x27;Feature flag &#x27; + key + &#x27; has been deprecated&#x27;)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  try {
config = new Config(require(filepath).config)
config.config_file_path = filepath
logger.debug(&#x22;Using configuration file %s.&#x22;, filepath)

config.<span class="apidocCodeKeywordSpan">validateFlags</span>()

return config
  } catch (error) {
logger.error(error)

throw new Error(
  &#x22;Unable to read configuration file &#x22; + filepath + &#x22;. A default\n&#x22; +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.copy" id="apidoc.module.newrelic.copy">module newrelic.copy</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.copy.shallow" id="apidoc.element.newrelic.copy.shallow">
        function <span class="apidocSignatureSpan">newrelic.copy.</span>shallow
        <span class="apidocSignatureSpan">(source, dest)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shallowCopy(source, dest) {
  dest = dest || {}
  for (var k in source) {
    if (source.hasOwnProperty(k)) {
      dest[k] = source[k]
    }
  }
  return dest
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // deep copy and only remove it from this data.
  //
  // In order to save cycles, we perform a smart deep copy in the form of a
  // series of shallow copies down just the path that needs to change.
  if (this.config.feature_flag.send_request_uri_attribute) {
    var err = []
    err.push.apply(err, error)
    err[4] = copy.<span class="apidocCodeKeywordSpan">shallow</span>(err[4])
    err[4].agentAttributes = copy.shallow(err[4].agentAttributes)
    delete err[4].agentAttributes.request_uri
    this.errors.push(err)
  } else {
    this.errors.push(error)
  }
} else {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.environment" id="apidoc.module.newrelic.environment">module newrelic.environment</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.environment.clearDispatcher" id="apidoc.element.newrelic.environment.clearDispatcher">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>clearDispatcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearDispatcher() {
  clearSetting(&#x27;Dispatcher&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.clearFramework" id="apidoc.element.newrelic.environment.clearFramework">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>clearFramework
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearFramework() {
  clearSetting(&#x27;Framework&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.get" id="apidoc.element.newrelic.environment.get">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSetting(name) {
  return settings[name] || []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var newrelic = require(&#x27;newrelic&#x27;);
var app = require(&#x27;express&#x27;)();

// In Express, this lets you call newrelic from within a template.
app.locals.newrelic = newrelic;

app.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/user/:id&#x27;, function (req, res) {
  res.render(&#x27;user&#x27;);
});
app.listen(process.env.PORT);
```

*layout.jade:*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.listPackages" id="apidoc.element.newrelic.environment.listPackages">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>listPackages
        <span class="apidocSignatureSpan">(root, packages)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listPackages(root, packages) {
  if (!packages) {
    packages = []
  }

  try {
    fs.readdirSync(root).forEach(function forEachReadDirSync(dir) {
      // Skip npm&#x27;s binary directory where it stores executables.
      if (dir === &#x27;.bin&#x27;) {
        return
      }

      var version = null
      try {
        var pck = path.resolve(root, dir, &#x27;package.json&#x27;)
        version = JSON.parse(fs.readFileSync(pck)).version
      } catch (e) {
        logger.debug(&#x27;Could not load %s for environment scan&#x27;, pck || dir)
      }

      packages.push([dir, version || &#x27;&#x3c;unknown&#x3e;&#x27;])
    })
  } catch (e) {
    logger.trace(e, &#x27;Failed to list packages in %s&#x27;, root)
  }

  return packages
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.refresh" id="apidoc.element.newrelic.environment.refresh">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>refresh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refresh() {
  // gather persisted settings
  var framework = getSetting(&#x27;Framework&#x27;)
  var dispatcher = getSetting(&#x27;Dispatcher&#x27;)
  var packages = getSetting(&#x27;Packages&#x27;)
  var dependencies = getSetting(&#x27;Dependencies&#x27;)

  // clearing and rebuilding a global variable
  settings = {}
  // add persisted settings
  if (framework.length) {
    framework.forEach(function addFrameworks(fw) {
      addSetting(&#x27;Framework&#x27;, fw)
    })
  }

  if (dispatcher.length) {
    dispatcher.forEach(function addDispatchers(d) {
      addSetting(&#x27;Dispatcher&#x27;, d)
    })
  }

  gatherEnv()
  remapConfigSettings()

  if (packages.length &#x26;&#x26; dependencies.length) {
    settings.Packages = packages
    settings.Dependencies = dependencies
  } else {
    findPackages()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.setDispatcher" id="apidoc.element.newrelic.environment.setDispatcher">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>setDispatcher
        <span class="apidocSignatureSpan">(dispatcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setDispatcher(dispatcher) {
  addSetting(&#x27;Dispatcher&#x27;, dispatcher)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!registered) {
  agent.on(&#x27;transactionFinished&#x27;, onTransactionFinished)
}

function setDispatcher(app) {
  return function wrappedCreateServer() {
    agent.environment.<span class="apidocCodeKeywordSpan">setDispatcher</span>(&#x27;express&#x27;)
    agent.environment.setFramework(&#x27;express&#x27;)

    return app.apply(this, arguments)
  }
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.setFramework" id="apidoc.element.newrelic.environment.setFramework">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>setFramework
        <span class="apidocSignatureSpan">(framework)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setFramework(framework) {
  addSetting(&#x27;Framework&#x27;, framework)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!registered) {
  agent.on(&#x27;transactionFinished&#x27;, onTransactionFinished)
}

function setDispatcher(app) {
  return function wrappedCreateServer() {
    agent.environment.setDispatcher(&#x27;express&#x27;)
    agent.environment.<span class="apidocCodeKeywordSpan">setFramework</span>(&#x27;express&#x27;)

    return app.apply(this, arguments)
  }
}

/**
 * This needs to be kept up to date with Express to ensure that it&#x27;s using
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.toJSON" id="apidoc.element.newrelic.environment.toJSON">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
  // TODO:  Do not refresh when JSON-ifying. This takes a _long_ time and blocks
  //        the event loop. Currently, removing this causes a couple of tests to
  //        fail (ironically from timing out).
  refresh()
  var items = []
  Object.keys(settings).forEach(function settingKeysForEach(key) {
    settings[key].forEach(function settingsValuesForEach(setting) {
      items.push([key, setting])
    })
  })

  return items
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this._processCustomEvents()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.<span class="apidocCodeKeywordSpan">toJSON</span>().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}

var metrics = this.metrics
var beginSeconds = metrics.started * FROM_MILLIS
var endSeconds = Date.now() * FROM_MILLIS
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.express_2" id="apidoc.module.newrelic.express_2">module newrelic.express_2</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.express_2.wrapMatchRequest" id="apidoc.element.newrelic.express_2.wrapMatchRequest">
        function <span class="apidocSignatureSpan">newrelic.express_2.</span>wrapMatchRequest
        <span class="apidocSignatureSpan">(tracer, version, original)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapMatchRequest(tracer, version, original) {
  return function cls_wrapMatchRequest() {
    if (!tracer.getTransaction()) {
      logger.trace(
        &#x27;Express %d router called outside transaction (wrapMatchRequest).&#x27;,
        version
      )
      return original.apply(this, arguments)
    }
    var route = original.apply(this, arguments)

    nameFromRoute(tracer.getSegment(), route)
    return route
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.hashes" id="apidoc.module.newrelic.hashes">module newrelic.hashes</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.hashes.calculatePathHash" id="apidoc.element.newrelic.hashes.calculatePathHash">
        function <span class="apidocSignatureSpan">newrelic.hashes.</span>calculatePathHash
        <span class="apidocSignatureSpan">(appName, pathName, referingPathHash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function calculatePathHash(appName, pathName, referingPathHash) {
  if (typeof referingPathHash === &#x27;string&#x27;) {
    referingPathHash = parseInt(referingPathHash, 16)
  }
  var rotated = ((referingPathHash &#x3c;&#x3c; 1) | (referingPathHash &#x3e;&#x3e;&#x3e; 31)) &#x3e;&#x3e;&#x3e; 0
  var hash = getHash(appName, pathName)

  var result = (rotated ^ hash) &#x3e;&#x3e;&#x3e; 0

  // This is a trick to pad it out to 8 chars regardless of length.
  var retval = (&#x27;00000000&#x27; + result.toString(16)).substr(-8)

  return retval
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   (
     transaction.referringTransactionGuid ||
     transaction.includesOutboundRequests()
   )
 ) {
intrinsicAttributes[&#x27;nr.guid&#x27;] = transaction.id
intrinsicAttributes[&#x27;nr.tripId&#x27;] = transaction.tripId || transaction.id
intrinsicAttributes[&#x27;nr.pathHash&#x27;] = hashes.<span class="apidocCodeKeywordSpan">calculatePathHash</span>(
  this.config.applications()[0],
  transaction.name || transaction.nameState.getName(),
  transaction.referringPathHash
)
if (transaction.referringPathHash) {
  intrinsicAttributes[&#x27;nr.referringPathHash&#x27;] = transaction.referringPathHash
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.hashes.deobfuscateNameUsingKey" id="apidoc.element.newrelic.hashes.deobfuscateNameUsingKey">
        function <span class="apidocSignatureSpan">newrelic.hashes.</span>deobfuscateNameUsingKey
        <span class="apidocSignatureSpan">(name, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deobfuscateNameUsingKey(name, key) {
  var bytes = new Buffer(name, &#x27;base64&#x27;)
  var keyBytes = new Buffer(key)

  return encode(bytes, keyBytes).toString(&#x22;utf-8&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports.handleCatHeaders = handleCatHeaders
module.exports.parsedHeadersToTrans = parsedHeadersToTrans

function handleCatHeaders(incomingCatId, obfTransaction, encKey, transaction) {
var parsedCatId = null
if (incomingCatId) {
  parsedCatId = hashes.<span class="apidocCodeKeywordSpan">deobfuscateNameUsingKey</span>(
    incomingCatId,
    encKey
  )
}

var externalTrans = null
if (obfTransaction) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.hashes.getHash" id="apidoc.element.newrelic.hashes.getHash">
        function <span class="apidocSignatureSpan">newrelic.hashes.</span>getHash
        <span class="apidocSignatureSpan">(appName, txName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHash(appName, txName) {
  var md5sum = crypto.createHash(&#x27;md5&#x27;)
  md5sum.update(new Buffer(appName + &#x27;;&#x27; + txName), &#x27;utf8&#x27;)
  var buf = new Buffer(md5sum.digest(&#x27;base64&#x27;), &#x27;base64&#x27;)
  // pull the low 4 bytes in network byte order
  return buf.slice(buf.length - 4, buf.length).readUInt32BE(0)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.hashes.obfuscateNameUsingKey" id="apidoc.element.newrelic.hashes.obfuscateNameUsingKey">
        function <span class="apidocSignatureSpan">newrelic.hashes.</span>obfuscateNameUsingKey
        <span class="apidocSignatureSpan">(name, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function obfuscateNameUsingKey(name, key) {
  var encodedBytes = new Buffer(name, &#x27;utf-8&#x27;)
  var keyBytes = new Buffer(key)
  return encode(encodedBytes, keyBytes).toString(&#x27;base64&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var rum_hash = {
  agent: browser_monitoring.js_agent_file,
  beacon: browser_monitoring.beacon,
  errorBeacon: browser_monitoring.error_beacon,
  licenseKey: licenseKey,
  applicationID: appid,
  applicationTime: time,
  transactionName: hashes.<span class="apidocCodeKeywordSpan">obfuscateNameUsingKey</span>(name, key),
  queueTime: trans.queueTime,
  ttGuid: trans.id,

  // we don&#x27;t use these parameters yet
  agentToken: null
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.http_agents" id="apidoc.module.newrelic.http_agents">module newrelic.http_agents</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.http_agents.proxyAgent" id="apidoc.element.newrelic.http_agents.proxyAgent">
        function <span class="apidocSignatureSpan">newrelic.http_agents.</span>proxyAgent
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function proxyAgent(config) {
  var opts = proxyOptions(config)
  var proxy_url = opts.proxy_url

  var proxy_opts = {
    host: proxy_url.host,
    port: proxy_url.port,
    protocol: proxy_url.protocol,
    secureEndpoint: config.ssl,
    auth: proxy_url.auth,
    ca: opts.certificates
  }

  logger.info({
    host: proxy_opts.host,
    port: proxy_opts.port,
    auth: !!proxy_opts.auth,
    protocol: proxy_url.protocol
  }, &#x27;using proxy&#x27;)

  var proxy = new ProxyAgent(proxy_opts)

  return proxy
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._config.proxy ||
this._config.proxy_port ||
this._config.proxy_host
  )

  if (isProxy) {
// proxy
requestOptions.agent = agents.<span class="apidocCodeKeywordSpan">proxyAgent</span>(this._config)
request = https.request(requestOptions)

// FIXME: The agent keeps this connection open when using the proxy.
// This will prevent the application from shutting down correctly.
// Explicitly destroy the socket when the response is completed.
//
// This goes against keep-alive, but for now letting the application die
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.label_parser" id="apidoc.module.newrelic.label_parser">module newrelic.label_parser</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.label_parser.label_parser" id="apidoc.element.newrelic.label_parser.label_parser">
        function <span class="apidocSignatureSpan">newrelic.</span>label_parser
        <span class="apidocSignatureSpan">(labels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(labels) {
  var results

  if (!labels) {
    return []
  } else if (typeof labels === &#x27;string&#x27;) {
    results = fromString(labels)
  } else if (labels) {
    results = fromMap(labels)
  }

  results.warnings.forEach(function logWarnings(messaage) {
    logger.warn(messaage)
  })

  return results.labels
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.label_parser.fromMap" id="apidoc.element.newrelic.label_parser.fromMap">
        function <span class="apidocSignatureSpan">newrelic.label_parser.</span>fromMap
        <span class="apidocSignatureSpan">(map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromMap(map) {
  var warnings = []
  var labels = []

  Object.keys(map).forEach(function processKeys(key) {
    var type = truncate(key, 255)

    if (!map[key] || typeof map[key] !== &#x27;string&#x27;) {
      return warnings.push(
        &#x27;Label value for &#x27; + type +
        &#x27;should be a string with a length between 1 and 255 characters&#x27;
      )
    }

    var value = truncate(map[key], 255)

    if (type !== key) {
      warnings.push(&#x27;Label key too long: &#x27; + type)
    }

    if (value !== map[key]) {
      warnings.push(&#x27;Label value too long: &#x27; + value)
    }

    labels.push({label_type: type, label_value: value})
  })

  if (labels.length &#x3e; 64) {
    warnings.push(&#x27;Too many Labels, list truncated to 64&#x27;)
    labels = labels.slice(0, 64)
  }

  if (warnings.length) {
    warnings.unshift(&#x27;Partially Invalid Label Setting: &#x27; + stringifySync(map))
  }

  return {labels: labels, warnings: warnings}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.label_parser.fromString" id="apidoc.element.newrelic.label_parser.fromString">
        function <span class="apidocSignatureSpan">newrelic.label_parser.</span>fromString
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromString(raw) {
  var map = {}

  if (!raw) {
    return {labels: [], warnings: []}
  }

  var pairs = raw.split(&#x27;;&#x27;).map(trim)
  var parts


  while (!pairs[pairs.length - 1]) {
    pairs.pop()
  }

  while (!pairs[0]) {
    pairs.shift()
  }

  for (var i = 0, l = pairs.length; i &#x3c; l; ++i) {
    parts = pairs[i].split(&#x27;:&#x27;).map(trim)

    if (parts.length !== 2) {
      return warn(&#x27;Could not create a Label pair from &#x27; + parts[i])
    } else if (!parts[0]) {
      return warn(&#x27;Label key can not be empty&#x27;)
    } else if (!parts[1]) {
      return warn(&#x27;Label value can not be empty&#x27;)
    }

    map[parts[0]] = parts[1]
  }

  return fromMap(map)

  function warn(message) {
    return {labels: [], warnings: [
      &#x27;Invalid Label String: &#x27; + raw,
       message
    ]}
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.mapper" id="apidoc.module.newrelic.mapper">module newrelic.mapper</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.mapper.mapper" id="apidoc.element.newrelic.mapper.mapper">
        function <span class="apidocSignatureSpan">newrelic.</span>mapper
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MetricMapper(raw) {
  this.unscoped = {}
  this.scoped = {}
  this.length = 0

  this.load(raw)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.mapper.prototype" id="apidoc.module.newrelic.mapper.prototype">module newrelic.mapper.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.mapper.prototype.load" id="apidoc.element.newrelic.mapper.prototype.load">
        function <span class="apidocSignatureSpan">newrelic.mapper.prototype.</span>load
        <span class="apidocSignatureSpan">(raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(raw) {
  if (!(raw &#x26;&#x26; raw.length)) {
    logger.debug(&#x22;No new metric mappings from server.&#x22;)
    return
  }

  for (var i = 0; i &#x3c; raw.length; i++) {
    var spec = raw[i][0]
    var scope = spec.scope
    var name = spec.name
    var id = raw[i][1]
    var resolved


    if (scope) {
      if (!this.scoped[scope]) this.scoped[scope] = {}
      resolved = this.scoped[scope]
    } else {
      resolved = this.unscoped
    }

    if (!resolved[name]) this.length++
    resolved[name] = id
    logger.trace(&#x22;Metric spec %s has been mapped to ID %s.&#x22;, spec, id)
  }
  logger.debug(&#x22;Parsed %d metric ids (%d total).&#x22;, raw.length, this.length)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.config.apdex_t,
    this.mapper,
    this.metricNameNormalizer
  )

  this.collector.metricData(payload, function cb_metricData(error, rules) {
    if (error) agent.metrics.merge(metrics)
    if (rules) agent.mapper.<span class="apidocCodeKeywordSpan">load</span>(rules)

    callback(error)
  })
} else {
  process.nextTick(function cb_nextTick() {
    callback(new Error(&#x22;not connected to New Relic (metrics will be held)&#x22;))
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.mapper.prototype.map" id="apidoc.element.newrelic.mapper.prototype.map">
        function <span class="apidocSignatureSpan">newrelic.mapper.prototype.</span>map
        <span class="apidocSignatureSpan">(name, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(name, scope) {
  if (scope) {
    if (this.scoped[scope] &#x26;&#x26; this.scoped[scope][name]) {
      return this.scoped[scope][name]
    }
    return {name: name, scope: scope}
  }

  if (this.unscoped[name]) {
    return this.unscoped[name]
  }

  return {name: name}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (err) {
  console.log(
    &#x27;Skipping install of @newrelic/native-metrics, could not determine NPM version.&#x27;
  )
  return
}

var npmVersion = (npmVersionStr || &#x27;&#x27;).split(&#x27;.&#x27;).<span class="apidocCodeKeywordSpan">map</span>(function versionMap
(a) {
  return parseInt(a, 10)
})

if (npmVersion.length &#x3e;= 3 &#x26;&#x26; npmVersion[0] &#x3e;= 2) {
  cp.exec(&#x27;node --version&#x27;, function nodeVersionCB(err, nodeVersionStr) {
    if (err) {
      console.log(
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.name_state" id="apidoc.module.newrelic.name_state">module newrelic.name_state</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.name_state.name_state" id="apidoc.element.newrelic.name_state.name_state">
        function <span class="apidocSignatureSpan">newrelic.</span>name_state
        <span class="apidocSignatureSpan">(prefix, verb, delimiter, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NameState(prefix, verb, delimiter, path) {
  this.setName(prefix, verb, delimiter, path)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.name_state.prototype" id="apidoc.module.newrelic.name_state.prototype">module newrelic.name_state.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.appendPath" id="apidoc.element.newrelic.name_state.prototype.appendPath">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>appendPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function appendPath(path) {
  if (path) {
    var strPath = path instanceof RegExp ? path.source : String(path)
    this.pathStack.push(strPath)
    logger.trace(&#x27;Appended %s to path stack&#x27;, strPath)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var transaction = segment.transaction
  var nameState = transaction.nameState

  if (res.__NR_directored) { // not first route
    nameState.pathStack.pop() // replace latest path name, preserving the last path name
  }
  nameState.<span class="apidocCodeKeywordSpan">appendPath</span>(partialName)

  nameState.setVerb(transaction.verb)
  nameState.setDelimiter(NAMES.ACTION_DELIMITER)
  res.__NR_directored = true
}

module.exports = function initialize(agent, director) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.appendPathIfEmpty" id="apidoc.element.newrelic.name_state.prototype.appendPathIfEmpty">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>appendPathIfEmpty
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function appendPathIfEmpty(path) {
  if (path &#x26;&#x26; this.pathStack.length === 0) {
    var strPath = path instanceof RegExp ? path.source : String(path)
    this.pathStack.push(strPath)
    logger.trace(&#x27;Appended %s to path stack&#x27;, strPath)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.getName" id="apidoc.element.newrelic.name_state.prototype.getName">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>getName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getName() {
  if (this.pathStack.length === 0) return null // nameState initialized but never set

  var path = this.pathStack.join(&#x27;/&#x27;).replace(/[/]{2,}/g, &#x27;/&#x27;)
  if (path &#x26;&#x26; path[0] !== &#x27;/&#x27;) {
    path = &#x27;/&#x27; + path
  } // path now looks like /one/two/three

  return _getName(this, path)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var trans = this.agent.getTransaction()

// bail gracefully outside a transaction
if (!trans) return _gracefail(1)

var name = trans.<span class="apidocCodeKeywordSpan">getName</span>()

/* If we&#x27;re in an unnamed transaction, add a friendly warning this is to
 * avoid people going crazy, trying to figure out why browser monitoring is
 * not working when they&#x27;re missing a transaction name.
 */
if (!name) return _gracefail(3)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.getNameNotFound" id="apidoc.element.newrelic.name_state.prototype.getNameNotFound">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>getNameNotFound
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNameNotFound() {
  return _getName(this, &#x27;(not found)&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.popPath" id="apidoc.element.newrelic.name_state.prototype.popPath">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>popPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function popPath(path) {
  if (this.pathStack.length === 0) {
    return
  }

  if (path) {
    var idx = arrayUtil.findLastIndex(this.pathStack, function pathMatch(a) {
      return a === path
    })
    if (idx !== -1) {
      this.pathStack.splice(idx)
    }
  } else {
    this.pathStack.pop()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  args[last] = function wrappedHandleCallback(err) {
    // if an error is passed to the next function, we do not want
    // to mutate the name path so the transaction will be named
    // after the location the error was generated.
    if (err &#x26;&#x26; err !== &#x27;route&#x27;) {
      transactionInfo.error = err
    } else if (!transactionInfo.responded) {
      transaction.nameState.<span class="apidocCodeKeywordSpan">popPath</span>(path)
    }
    return cb.apply(this, arguments)
  }
}

// wrap res.end to mark the transaction as responded
var res = args[1]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.reset" id="apidoc.element.newrelic.name_state.prototype.reset">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
  logger.trace(&#x27;Reset called on name state, path stack was %j&#x27;, this.pathStack)
  this.prefix = null
  this.verb = null
  this.delimiter = null
  this.pathStack = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.mapper = null
this.metricNameNormalizer = null
this.metrics = null
this.transactionNameNormalizer = null
this.urlNormalizer = null
this.txSegmentNormalizer = null
this.userNormalizer = null
this.<span class="apidocCodeKeywordSpan">reset</span>()

// Transaction tracing.
this.tracer = this._setupTracer()
this.traces = new TraceAggregator(this.config)

// Query tracing.
this.queries = new QueryTracer(this.config)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.setDelimiter" id="apidoc.element.newrelic.name_state.prototype.setDelimiter">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>setDelimiter
        <span class="apidocSignatureSpan">(delimiter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setDelimiter(delimiter) {
  this.delimiter = delimiter
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (res.__NR_directored) { // not first route
  nameState.pathStack.pop() // replace latest path name, preserving the last path name
}
nameState.appendPath(partialName)

nameState.setVerb(transaction.verb)
nameState.<span class="apidocCodeKeywordSpan">setDelimiter</span>(NAMES.ACTION_DELIMITER)
res.__NR_directored = true
}

module.exports = function initialize(agent, director) {
var tracer = agent.tracer

shimmer.wrapMethod(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.setName" id="apidoc.element.newrelic.name_state.prototype.setName">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>setName
        <span class="apidocSignatureSpan">(prefix, verb, delimiter, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setName(prefix, verb, delimiter, path) {
  this.setPrefix(prefix)
  this.verb = verb
  this.delimiter = delimiter
  this.pathStack = path ? [path] : []
  logger.trace(&#x27;setName called on name state, path stack now %j&#x27;, this.pathStack)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  logger.debug(
    &#x27;creating web transaction %s (%s) with transaction id: %s&#x27;,
    url,
    handle &#x26;&#x26; handle.name,
    tx.id
  )
  tx.nameState.<span class="apidocCodeKeywordSpan">setName</span>(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url)
  tx.url = url
  tx.applyUserNamingRules(tx.url)
  tx.webSegment = tracer.createSegment(url, recordWeb)
  tx.webSegment.start()

  return tracer.bindFunction(handle, tx.webSegment).apply(this, arguments)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.setPrefix" id="apidoc.element.newrelic.name_state.prototype.setPrefix">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>setPrefix
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setPrefix(prefix) {
  if (prefix === null) {
    this.prefix = null
    return
  }
  this.prefix = (prefix[prefix.length - 1] === &#x27;/&#x27;) ?
    prefix.substring(0, prefix.length - 1) : prefix
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @constructor
 */
function NameState(prefix, verb, delimiter, path) {
  this.setName(prefix, verb, delimiter, path)
}

NameState.prototype.setName = function setName(prefix, verb, delimiter, path) {
  this.<span class="apidocCodeKeywordSpan">setPrefix</span>(prefix)
  this.verb = verb
  this.delimiter = delimiter
  this.pathStack = path ? [path] : []
  logger.trace(&#x27;setName called on name state, path stack now %j&#x27;, this.pathStack)
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.name_state.prototype.setVerb" id="apidoc.element.newrelic.name_state.prototype.setVerb">
        function <span class="apidocSignatureSpan">newrelic.name_state.prototype.</span>setVerb
        <span class="apidocSignatureSpan">(verb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setVerb(verb) {
  this.verb = verb
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var nameState = transaction.nameState

if (res.__NR_directored) { // not first route
  nameState.pathStack.pop() // replace latest path name, preserving the last path name
}
nameState.appendPath(partialName)

nameState.<span class="apidocCodeKeywordSpan">setVerb</span>(transaction.verb)
nameState.setDelimiter(NAMES.ACTION_DELIMITER)
res.__NR_directored = true
}

module.exports = function initialize(agent, director) {
var tracer = agent.tracer
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.normalizer" id="apidoc.module.newrelic.normalizer">module newrelic.normalizer</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.normalizer.normalizer" id="apidoc.element.newrelic.normalizer.normalizer">
        function <span class="apidocSignatureSpan">newrelic.</span>normalizer
        <span class="apidocSignatureSpan">(config, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MetricNormalizer(config, type) {
  if (!config) throw new Error(&#x22;normalizer must be created with configuration.&#x22;)
  if (!type) throw new Error(&#x22;normalizer must be created with a type.&#x22;)

  EventEmitter.call(this)

  this.config = config
  this.type = type
  // some mildly cheesy polymorphism to make normalizers work generically
  if (type === &#x27;URL&#x27;) {
    this.formatter = url
  } else {
    this.formatter = plain
  }

  this.rules = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.normalizer.super_" id="apidoc.element.newrelic.normalizer.super_">
        function <span class="apidocSignatureSpan">newrelic.normalizer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.normalizer.prototype" id="apidoc.module.newrelic.normalizer.prototype">module newrelic.normalizer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.normalizer.prototype.addSimple" id="apidoc.element.newrelic.normalizer.prototype.addSimple">
        function <span class="apidocSignatureSpan">newrelic.normalizer.prototype.</span>addSimple
        <span class="apidocSignatureSpan">(pattern, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addSimple(pattern, name) {
  if (!pattern) return logger.error(&#x22;Simple naming rules require a pattern.&#x22;)

  var json = {
    match_expression: pattern,
    eval_order: 0,
    terminate_chain: true,
    replace_all: false,
    replacement: null,
    ignore: false
  }

  if (name) {
    json.replacement = name
  } else {
    json.ignore = true
  }

  this.rules.unshift(new Rule(json))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   NAMES.SUPPORTABILITY.API + &#x27;/addNamingRule&#x27;
 )
 metric.incrementCallCount()


 if (!name) return logger.error(&#x22;Simple naming rules require a replacement name.&#x22;)

 this.agent.userNormalizer.<span class="apidocCodeKeywordSpan">addSimple</span>(pattern, &#x27;/&#x27; + name)
}

/**
* If the URL for a transaction matches the provided pattern, ignore the
* transaction attached to that URL. Useful for filtering socket.io connections
* and other long-polling requests out of your agents to keep them from
* distorting an app&#x27;s apdex or mean response time. Pattern may be a (standard
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.normalizer.prototype.load" id="apidoc.element.newrelic.normalizer.prototype.load">
        function <span class="apidocSignatureSpan">newrelic.normalizer.prototype.</span>load
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(json) {
  if (json) {
    this.rules = []
    logger.debug(&#x22;Received %s %s normalization rule(s) from the server&#x22;,
      json.length, this.type)

    json.forEach(function cb_forEach(ruleJSON) {
      // no need to add the same rule twice
      var rule = new Rule(ruleJSON)
      if (!arrUtil.find(this.rules, deepEqual.bind(null, rule))) {
        this.rules.push(rule)
        logger.trace(&#x22;Loaded %s normalization rule: %s&#x22;, this.type, rule)
      }
    }, this)

<span class="apidocCodeCommentSpan">    /* I (FLN) always forget this, so making a note: JS sort is always
     * IN-PLACE, even though it returns the sorted array.
     */
</span>    this.rules.sort(function cb_sort(a, b) {
      return a.precedence - b.precedence
    })

    logger.debug(&#x22;Loaded %s %s normalization rule(s).&#x22;,
                 this.rules.length, this.type)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.config.apdex_t,
    this.mapper,
    this.metricNameNormalizer
  )

  this.collector.metricData(payload, function cb_metricData(error, rules) {
    if (error) agent.metrics.merge(metrics)
    if (rules) agent.mapper.<span class="apidocCodeKeywordSpan">load</span>(rules)

    callback(error)
  })
} else {
  process.nextTick(function cb_nextTick() {
    callback(new Error(&#x22;not connected to New Relic (metrics will be held)&#x22;))
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.normalizer.prototype.loadFromConfig" id="apidoc.element.newrelic.normalizer.prototype.loadFromConfig">
        function <span class="apidocSignatureSpan">newrelic.normalizer.prototype.</span>loadFromConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadFromConfig() {
  var rules = this.config.rules

  if (rules &#x26;&#x26; rules.name &#x26;&#x26; rules.name.length &#x3e; 0) {
    rules.name.forEach(function cb_forEach(rule) {
      if (!rule.pattern) {
        return logger.error(
          {rule: rule},
          &#x22;Simple naming rules require a pattern.&#x22;
        )
      }
      if (!rule.name) {
        return logger.error(
          {rule: rule},
          &#x22;Simple naming rules require a replacement name.&#x22;
        )
      }

      var precedence = rule.precedence
      var terminal = rule.terminate_chain
      var json = {
        match_expression: rule.pattern,
        eval_order: (typeof precedence === &#x27;number&#x27;) ? precedence : 500,
        terminate_chain: (typeof terminal === &#x27;boolean&#x27;) ? terminal : true,
        replace_all: rule.replace_all,
        replacement: rule.name,
        ignore: false
      }

      // Find where the rule should be inserted and do so.
      var reverse = this.config.feature_flag.reverse_naming_rules
      var insert = arrUtil.findIndex(this.rules, function findRule(r) {
        return reverse
          ? r.precedence &#x3e;= json.eval_order
          : r.precedence &#x3e; json.eval_order
      })
      if (insert === -1) {
        this.rules.push(new Rule(json))
      } else {
        this.rules.splice(insert, 0, new Rule(json))
      }
    }, this)
  }

  if (rules &#x26;&#x26; rules.ignore &#x26;&#x26; rules.ignore.length &#x3e; 0) {
    rules.ignore.forEach(function cb_forEach(pattern) {
      this.addSimple(pattern)
    }, this)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.urlNormalizer = new MetricNormalizer(this.config, &#x27;URL&#x27;)

// Segment term based tx renaming for MGI mitigation.
this.txSegmentNormalizer = new TxSegmentNormalizer()

// User naming and ignoring rules.
this.userNormalizer = new MetricNormalizer(this.config, &#x27;user&#x27;)
this.userNormalizer.<span class="apidocCodeKeywordSpan">loadFromConfig</span>()

// Supportability.
if (this.config.debug.internal_metrics) {
  this.config.debug.supportability = new Metrics(
    this.config.apdex_t,
    this.mapper,
    this.metricNameNormalizer
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.normalizer.prototype.normalize" id="apidoc.element.newrelic.normalizer.prototype.normalize">
        function <span class="apidocSignatureSpan">newrelic.normalizer.prototype.</span>normalize
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalize(path) {
  var last = path
  var length = this.rules.length
  var normalized
  var matched = false
  var ignored = false

  // Apply each of our rules in turn.
  for (var i = 0; i &#x3c; length; i++) {
    var rule = this.rules[i]
    var applied = rule.apply(last)
    if (!rule.matched) {
      continue
    }

    if (rule.ignore) {
      ignored = true
    } else {
      matched = true
      normalized = applied

      // emit event when a rule is matched
      // we could also include an array of matched rules in the returned map, but
      // that would increase memory overhead by creating additional array
      this.emit(&#x27;appliedRule&#x27;, rule, normalized, last)

      logger.trace({rule: rule, type: this.type},
        &#x22;Normalized %s to %s.&#x22;, last, normalized)
      last = normalized
    }

    if (rule.isTerminal) {
      logger.trace({rule: rule}, &#x22;Terminating normalization.&#x22;)
      break
    }
  }

  // Return the normalized path.
  return {
    matched: matched,
    ignore: ignored,
    value: this.formatter(normalized, path, this.config)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.parsed_statement" id="apidoc.module.newrelic.parsed_statement">module newrelic.parsed_statement</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.parsed_statement.parsed_statement" id="apidoc.element.newrelic.parsed_statement.parsed_statement">
        function <span class="apidocSignatureSpan">newrelic.</span>parsed_statement
        <span class="apidocSignatureSpan">(type, operation, model, raw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ParsedStatement(type, operation, model, raw) {
  this.type = type
  this.operation = operation
  this.model = model
  this.trace = null
  this.raw = &#x27;&#x27;

  if (typeof raw === &#x27;string&#x27;) {
    this.trace = new Error()
    this.raw = raw
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.parsed_statement.prototype" id="apidoc.module.newrelic.parsed_statement.prototype">module newrelic.parsed_statement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.parsed_statement.prototype.recordMetrics" id="apidoc.element.newrelic.parsed_statement.prototype.recordMetrics">
        function <span class="apidocSignatureSpan">newrelic.parsed_statement.prototype.</span>recordMetrics
        <span class="apidocSignatureSpan">(segment, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordMetrics(segment, scope) {
  var duration = segment.getDurationInMillis()
  var exclusive = segment.getExclusiveDurationInMillis()
  var transaction = segment.transaction
  var type = transaction.isWeb() ? DB.WEB : DB.OTHER
  var thisTypeSlash = this.type + &#x27;/&#x27;
  var operation = DB.OPERATION + &#x27;/&#x27; + thisTypeSlash + this.operation

  // Rollups
  transaction.measure(operation, null, duration, exclusive)
  transaction.measure(DB.PREFIX + type, null, duration, exclusive)
  transaction.measure(DB.PREFIX + thisTypeSlash + type, null, duration, exclusive)
  transaction.measure(DB.PREFIX + thisTypeSlash + ALL, null, duration, exclusive)
  transaction.measure(DB.ALL, null, duration, exclusive)

  // If we can parse the SQL statement, create a &#x27;statement&#x27; metric, and use it
  // as the scoped metric for transaction breakdowns. Otherwise, skip the
  // &#x27;statement&#x27; metric and use the &#x27;operation&#x27; metric as the scoped metric for
  // transaction breakdowns.
  if (this.model) {
    var model = DB.STATEMENT + &#x27;/&#x27; + thisTypeSlash + this.model + &#x27;/&#x27; + this.operation
    transaction.measure(model, null, duration, exclusive)
    if (scope) transaction.measure(model, scope, duration, exclusive)
  } else if (scope) {
    transaction.measure(operation, scope, duration, exclusive)
  }

  // This recorder is side-effectful Because we are depending on the recorder
  // setting the transaction name, recorders must always be run before generating
  // the final transaction trace
  segment.name = model || operation

  // Datastore instance metrics.
  if (segment.parameters.hasOwnProperty(&#x27;host&#x27;) &#x26;&#x26;
      segment.parameters.hasOwnProperty(&#x27;port_path_or_id&#x27;)) {
    var instanceName = DB.INSTANCE + &#x27;/&#x27; + thisTypeSlash + segment.parameters.host +
      &#x27;/&#x27; + segment.parameters.port_path_or_id
    transaction.measure(instanceName, null, duration, exclusive)
  }

  if (this.raw) {
    transaction.agent.queries.addQuery(
      segment,
      this.type.toLowerCase(),
      this.raw,
      this.trace
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.remote_method" id="apidoc.module.newrelic.remote_method">module newrelic.remote_method</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.remote_method.remote_method" id="apidoc.element.newrelic.remote_method.remote_method">
        function <span class="apidocSignatureSpan">newrelic.</span>remote_method
        <span class="apidocSignatureSpan">(name, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RemoteMethod(name, config) {
  if (!name) {
    throw new TypeError(&#x22;Must include name of method to invoke on collector.&#x22;)
  }

  this.name = name
  this._config = config
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.remote_method.prototype" id="apidoc.module.newrelic.remote_method.prototype">module newrelic.remote_method.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype._headers" id="apidoc.element.newrelic.remote_method.prototype._headers">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_headers
        <span class="apidocSignatureSpan">(body, compressed)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _headers(body, compressed) {
  var agent = this._userAgent()

  var headers = {
    // select the virtual host on the server end
    &#x27;Host&#x27;: this._config.host,
    &#x27;User-Agent&#x27;: agent,
    &#x27;Connection&#x27;: &#x27;Keep-Alive&#x27;,
    &#x27;Content-Length&#x27;: byteLength(body)
  }

  if (compressed) {
    headers[ENCODING_HEADER] = this._config.compressed_content_encoding
    headers[CONTENT_TYPE_HEADER] = COMPRESSED_CONTENT_TYPE
  } else {
    headers[ENCODING_HEADER] = DEFAULT_ENCODING
    headers[CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE
  }

  return headers
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
RemoteMethod.prototype._request = function _request(options) {
var requestOptions = {
  method: this._config.put_for_data_send ? &#x27;PUT&#x27; : &#x27;POST&#x27;,
  setHost: false,         // See below
  host: options.host,     // Set explicitly in the headers
  port: options.port,
  path: options.path,
  headers: this.<span class="apidocCodeKeywordSpan">_headers</span>(options.body, options.compressed),
  __NR__connection: true  // Who measures the metrics measurer?
}
var request

var isProxy = !!(
  this._config.proxy ||
  this._config.proxy_port ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype._path" id="apidoc.element.newrelic.remote_method.prototype._path">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_path
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _path() {
  var query = {
      marshal_format: &#x27;json&#x27;,
      protocol_version: PROTOCOL_VERSION,
      license_key: this._config.license_key,
      method: this.name
  }

  if (this._config.run_id) query[RUN_ID_NAME] = this._config.run_id

  var formatted = url.format({
    pathname: RAW_METHOD_PATH,
    query: query
  })

  return formatted
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  response.pipe(new Sink(parse(method.name, response, callback)))
}

var options = {
  port: this._config.port,
  host: this._config.host,
  compressed: this._shouldCompress(data),
  path: this.<span class="apidocCodeKeywordSpan">_path</span>(),
  onError: callback,
  onResponse: onResponse
}

if (options.compressed) {
  logger.trace({data: data}, &#x22;Sending %s on collector API with (COMPRESSED)&#x22;, this.name)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype._post" id="apidoc.element.newrelic.remote_method.prototype._post">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_post
        <span class="apidocSignatureSpan">(data, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _post(data, callback) {
  var method = this

  // set up standard response handling
  function onResponse(response) {
    response.on(&#x27;end&#x27;, function handle_end() {
      logger.debug(
        &#x22;Finished receiving data back from the collector for %s.&#x22;,
        method.name
      )
    })

    response.setEncoding(&#x27;utf8&#x27;)
    response.pipe(new Sink(parse(method.name, response, callback)))
  }

  var options = {
    port: this._config.port,
    host: this._config.host,
    compressed: this._shouldCompress(data),
    path: this._path(),
    onError: callback,
    onResponse: onResponse
  }

  if (options.compressed) {
    logger.trace({data: data}, &#x22;Sending %s on collector API with (COMPRESSED)&#x22;, this.name)

    var useGzip = this._config.compressed_content_encoding === &#x27;gzip&#x27;
    var compressor = useGzip ? zlib.gzip : zlib.deflate
    compressor(data, function cb_compressor(err, compressed) {
      if (err) {
        logger.warn(err, &#x22;Error compressing JSON for delivery. Not sending.&#x22;)
        return callback(err)
      }

      options.body = compressed
      method._safeRequest(options)
    })
  } else {
    logger.debug({data: data}, &#x22;Calling %s on collector API&#x22;, this.name)

    options.body = data
    this._safeRequest(options)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param Function callback   What to do next. Gets passed any error.
*/
RemoteMethod.prototype.invoke = function call(payload, callback) {
 if (!payload) payload = []

 this.serialize(payload, function cb_serialize(err, serialized) {
   if (err) return callback(err)
   this.<span class="apidocCodeKeywordSpan">_post</span>(serialized, callback)
 }.bind(this))
}

/**
* Take a serialized payload and create a response wrapper for it before
* invoking the method on the collector.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype._request" id="apidoc.element.newrelic.remote_method.prototype._request">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_request
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _request(options) {
  var requestOptions = {
    method: this._config.put_for_data_send ? &#x27;PUT&#x27; : &#x27;POST&#x27;,
    setHost: false,         // See below
    host: options.host,     // Set explicitly in the headers
    port: options.port,
    path: options.path,
    headers: this._headers(options.body, options.compressed),
    __NR__connection: true  // Who measures the metrics measurer?
  }
  var request

  var isProxy = !!(
    this._config.proxy ||
    this._config.proxy_port ||
    this._config.proxy_host
  )

  if (isProxy) {
    // proxy
    requestOptions.agent = agents.proxyAgent(this._config)
    request = https.request(requestOptions)

    // FIXME: The agent keeps this connection open when using the proxy.
    // This will prevent the application from shutting down correctly.
    // Explicitly destroy the socket when the response is completed.
    //
    // This goes against keep-alive, but for now letting the application die
    // gracefully is more important.
    request.on(&#x27;response&#x27;, function cb_on_response(sock) {
      sock.on(&#x27;end&#x27;, function cb_on_end() {
        sock.destroy()
      })
    })
  } else if (this._config.ssl) {
    if (this._config.certificates &#x26;&#x26; this._config.certificates.length &#x3e; 0) {
      logger.debug(
        &#x27;Adding custom certificate to the cert bundle.&#x27;
      )
      requestOptions.ca = this._config.certificates.concat(certificates)
    }
    request = https.request(requestOptions)
  } else {
    request = http.request(requestOptions)
  }

  request.on(&#x27;error&#x27;, options.onError)
  request.on(&#x27;response&#x27;, options.onResponse)

  request.end(options.body)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     logger.info(logevent)
   }
 } else {
   logger.trace(logevent)
 }


 this.<span class="apidocCodeKeywordSpan">_request</span>(options)
}

/**
* Generate the request headers and wire up the request. There are many
* parameters used to make a request:
*
* @param string   options.host       Hostname (or proxy hostname) for collector.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype._safeRequest" id="apidoc.element.newrelic.remote_method.prototype._safeRequest">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_safeRequest
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _safeRequest(options) {
  if (!options) throw new Error(&#x22;Must include options to make request!&#x22;)
  if (!options.host) throw new Error(&#x22;Must include collector hostname!&#x22;)
  if (!options.port) throw new Error(&#x22;Must include collector port!&#x22;)
  if (!options.onError) throw new Error(&#x22;Must include error handler!&#x22;)
  if (!options.onResponse) throw new Error(&#x22;Must include response handler!&#x22;)
  if (!options.body) throw new Error(&#x22;Must include body to send to collector!&#x22;)
  if (!options.path) throw new Error(&#x22;Must include URL to request!&#x22;)

  var protocol = this._config.ssl ? &#x27;https&#x27; : &#x27;http&#x27;
  var logconfig = this._config.logging
  var audit_log = this._config.audit_log
  var logevent = util.format({
    body: Buffer.isBuffer(options.body) ? &#x27;Buffer &#x27; + options.body.length : options.body
  }, &#x22;Posting to %s://%s:%s%s&#x22;,
    protocol,
    options.host,
    options.port,
    options.path
  )
  // if trace level is not explicity enabled
  // check to see if the audit log is enabled
  if ((typeof logconfig !== &#x27;undefined&#x27;) &#x26;&#x26; logconfig.level !== &#x27;trace&#x27;) {
    if (audit_log.enabled &#x26;&#x26;
          // if the filter property is empty, then always log the event
          // otherwise check to see if the filter includes this method
          (audit_log.endpoints.length &#x3e; 0 ?
           audit_log.endpoints.indexOf(this.name) &#x3e; -1 : true)) {
      logger.info(logevent)
    }
  } else {
    logger.trace(logevent)
  }


  this._request(options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  compressor(data, function cb_compressor(err, compressed) {
    if (err) {
      logger.warn(err, &#x22;Error compressing JSON for delivery. Not sending.&#x22;)
      return callback(err)
    }

    options.body = compressed
    method.<span class="apidocCodeKeywordSpan">_safeRequest</span>(options)
  })
} else {
  logger.debug({data: data}, &#x22;Calling %s on collector API&#x22;, this.name)

  options.body = data
  this._safeRequest(options)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype._shouldCompress" id="apidoc.element.newrelic.remote_method.prototype._shouldCompress">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_shouldCompress
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _shouldCompress(data) {
  return data &#x26;&#x26; byteLength(data) &#x3e; 65536
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  response.setEncoding(&#x27;utf8&#x27;)
  response.pipe(new Sink(parse(method.name, response, callback)))
}

var options = {
  port: this._config.port,
  host: this._config.host,
  compressed: this.<span class="apidocCodeKeywordSpan">_shouldCompress</span>(data),
  path: this._path(),
  onError: callback,
  onResponse: onResponse
}

if (options.compressed) {
  logger.trace({data: data}, &#x22;Sending %s on collector API with (COMPRESSED)&#x22;, this.name)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype._userAgent" id="apidoc.element.newrelic.remote_method.prototype._userAgent">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>_userAgent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _userAgent() {
  return util.format(USER_AGENT_FORMAT,
                     this._config.version,
                     process.versions.node,
                     process.platform,
                     process.arch)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
 * @param {number}  length      - Length of data to be sent.
 * @param {bool}    compressed  - The compression method used, if any.
 */
RemoteMethod.prototype._headers = function _headers(body, compressed) {
var agent = this.<span class="apidocCodeKeywordSpan">_userAgent</span>()

var headers = {
  // select the virtual host on the server end
  &#x27;Host&#x27;: this._config.host,
  &#x27;User-Agent&#x27;: agent,
  &#x27;Connection&#x27;: &#x27;Keep-Alive&#x27;,
  &#x27;Content-Length&#x27;: byteLength(body)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype.invoke" id="apidoc.element.newrelic.remote_method.prototype.invoke">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>invoke
        <span class="apidocSignatureSpan">(payload, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function call(payload, callback) {
  if (!payload) payload = []

  this.serialize(payload, function cb_serialize(err, serialized) {
    if (err) return callback(err)
    this._post(serialized, callback)
  }.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.remote_method.prototype.serialize" id="apidoc.element.newrelic.remote_method.prototype.serialize">
        function <span class="apidocSignatureSpan">newrelic.remote_method.prototype.</span>serialize
        <span class="apidocSignatureSpan">(payload, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serialize(payload, callback) {
  try {
    var res = safeJSON.stringifySync(payload)
  } catch (error) {
    logger.error(error, &#x22;Unable to serialize payload for method %s.&#x22;, this.name)
    return process.nextTick(function cb_nextTick() {
      return callback(error)
    })
  }
  return callback(null, res)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param object   payload    Serializable payload.
* @param Function callback   What to do next. Gets passed any error.
*/
RemoteMethod.prototype.invoke = function call(payload, callback) {
 if (!payload) payload = []

 this.<span class="apidocCodeKeywordSpan">serialize</span>(payload, function cb_serialize(err, serialized) {
   if (err) return callback(err)
   this._post(serialized, callback)
 }.bind(this))
}

/**
* Take a serialized payload and create a response wrapper for it before
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.reservoir" id="apidoc.module.newrelic.reservoir">module newrelic.reservoir</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.reservoir.reservoir" id="apidoc.element.newrelic.reservoir.reservoir">
        function <span class="apidocSignatureSpan">newrelic.</span>reservoir
        <span class="apidocSignatureSpan">(limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reservoir(limit) {
  this.limit = limit || 10
  this.seen = 0
  this._data = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.reservoir.prototype" id="apidoc.module.newrelic.reservoir.prototype">module newrelic.reservoir.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.add" id="apidoc.element.newrelic.reservoir.prototype.add">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>add
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(item) {
  if (this.seen &#x3c; this.limit) {
    this._data.push(item)
  } else {
    // Take a number between 0 and n + 1, drop the element at that index
    // from the array. If the element to drop is the (n + 1)th, the new item is
    // not added, otherwise the new item replaces the item that was
    // dropped.
    // This is effectively the same as adding the new element to the
    // end, swapping the last element (the new one) with a random element in the list,
    // then dropping the last element (the potentially swapped one) in the list.
    var toReplace = Math.floor(Math.random() * (this.seen + 2))
    if (toReplace &#x3c; this.limit) this._data[toReplace] = item
  }
  this.seen++
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 var instrinics = {
   type: eventType,
   timestamp: Date.now()
 }

 this.agent.customEvents.<span class="apidocCodeKeywordSpan">add</span>([instrinics, attributes])
}

/**
* Shuts down the agent.
*
* @param {object}  [options]                           object with shut down options
* @param {boolean} [options.collectPendingData=false]  If true, the agent will send any
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.merge" id="apidoc.element.newrelic.reservoir.prototype.merge">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>merge
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(items) {
  if (!items || !items.length) return
  if (items === this._data) return
  for (var i = 0; i &#x3c; items.length; i++) {
    this.add(items[i])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof value.totalExclusive === &#x27;number&#x27;) {
  stats.totalExclusive = value.totalExclusive
} else {
  stats.totalExclusive = value.total
}

metric.<span class="apidocCodeKeywordSpan">merge</span>(stats)
}

API.prototype.incrementMetric = function incrementMetric(name, value) {
var metric = this.agent.metrics.getOrCreateMetric(
  NAMES.SUPPORTABILITY.API + &#x27;/incrementMetric&#x27;
)
metric.incrementCallCount()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.overflow" id="apidoc.element.newrelic.reservoir.prototype.overflow">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>overflow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function overflow() {
  var diff = this.seen - this.limit
  return diff &#x3e;= 0 ? diff : 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Bail out if there are no events
  if (this.customEventsPool.length === 0) {
return
  }

  if (this.config.custom_insights_events.enabled) {
// Record their values
var diff = this.customEvents.<span class="apidocCodeKeywordSpan">overflow</span>()
dropped.incrementCallCount(diff)
seen.incrementCallCount(this.customEvents.seen)
sent.incrementCallCount(this.customEvents.seen - diff)

// Log any warnings about dropping events
if (diff) {
  logger.warn(&#x27;Dropped %s custom events out of %s.&#x27;, diff, this.customEvents.seen)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.setLimit" id="apidoc.element.newrelic.reservoir.prototype.setLimit">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>setLimit
        <span class="apidocSignatureSpan">(newLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLimit(newLimit) {
  this.limit = newLimit
  if (this._data.length &#x3e; newLimit) {
    this._data = this._data.slice(0, newLimit)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Builds all of the sub-properties of the agent that rely on configurations.
 */
Agent.prototype.reset = function reset() {
// Insights events.
if (!this.events) {
  this.events = new Reservoir()
}
this.events.<span class="apidocCodeKeywordSpan">setLimit</span>(this.config.transaction_events.max_samples_per_minute)
if (!this.customEvents) {
  this.customEvents = new Reservoir()
}
this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)

// Error tracing.
if (!this.errors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.toArray" id="apidoc.element.newrelic.reservoir.prototype.toArray">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toArray() {
  return this._data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * This function takes the custom events reservoir, gets stats on it for
 * metric purposes, then instantiates a new custom events reservoir. This is
 * so the stats are consistent with what actually gets pushed by the later
 * call to _sendCustomEvents.
 */
Agent.prototype._processCustomEvents = function _processCustomEvents() {
this.customEventsPool = this.customEvents.<span class="apidocCodeKeywordSpan">toArray</span>()

// Create the metrics so they are at least set to 0
var dropped = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.DROPPED)
var seen = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SEEN)
var sent = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SENT)

// Bail out if there are no events
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.rule" id="apidoc.module.newrelic.rule">module newrelic.rule</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.rule.rule" id="apidoc.element.newrelic.rule.rule">
        function <span class="apidocSignatureSpan">newrelic.</span>rule
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NormalizerRule(json) {
  if (!json) {
    logger.debug(
      &#x22;Received incompletely specified metric normalization rule from collector.&#x22;
    )
    json = {}
  }

  this.eachSegment = json.each_segment || false
  this.precedence = json.eval_order || 0
  this.isTerminal = json.terminate_chain || false
  this.replacement = replaceReplacer(json.replacement || &#x27;$0&#x27;)
  this.replaceAll = json.replace_all || false
  this.ignore = json.ignore || false
  this.matched = false

  var modifiers = &#x27;i&#x27;
  if (this.replaceAll) modifiers += &#x27;g&#x27;

  // don&#x27;t allow this to fail
  if (json.match_expression instanceof RegExp) {
    this.pattern = _addRegExpFlags(json.match_expression, modifiers)
  } else {
    try {
      this.pattern = new RegExp(json.match_expression || &#x27;^$&#x27;, modifiers)
    } catch (error) {
      logger.warn(error, &#x22;Problem compiling metric normalization rule pattern.&#x22;)
      this.pattern = /^$/
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.rule.prototype" id="apidoc.module.newrelic.rule.prototype">module newrelic.rule.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.rule.prototype.apply" id="apidoc.element.newrelic.rule.prototype.apply">
        function <span class="apidocSignatureSpan">newrelic.rule.prototype.</span>apply
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply(input) {
  // For ignore rules, just see if we match and return either `null` or the
  // original input.
  if (this.ignore) {
    return (this.matched = this.matches(input)) ? null : input
  }

  this.matched = false
  var result = this.getSegments(input)
    .map(function applyMap(segment) {
      // Discussion of why we use `lastIndex` in function documentation to
      // prevent de-opt due to long function.
      this.pattern.lastIndex = 0
      if (segment &#x26;&#x26; this.pattern.test(segment)) {
        this.matched = true
        return segment.replace(this.pattern, this.replacement)
      }
      return segment
    }, this)
    .join(&#x27;/&#x27;)
  return input[0] === &#x27;/&#x27; &#x26;&#x26; result[0] !== &#x27;/&#x27; ? &#x27;/&#x27; + result : result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   )
   tx.nameState.setName(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url)
   tx.url = url
   tx.applyUserNamingRules(tx.url)
   tx.webSegment = tracer.createSegment(url, recordWeb)
   tx.webSegment.start()

   return tracer.bindFunction(handle, tx.webSegment).<span class="apidocCodeKeywordSpan">apply</span>(this, arguments)
 })
}

/**
* Creates a function that represents a background transaction. It does not start the
* transaction automatically - the returned function needs to be invoked to start it.
* Inside the handler function, the transaction must be ended by calling endTransaction().
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.rule.prototype.getSegments" id="apidoc.element.newrelic.rule.prototype.getSegments">
        function <span class="apidocSignatureSpan">newrelic.rule.prototype.</span>getSegments
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSegments(input) {
  if (this.eachSegment) {
    return input.split(&#x27;/&#x27;)
  }

  return [input]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Does not set {NormalizerRule#matched}.
 *
 * @param {string} input - URL to match.
 *
 * @return {bool} - True if this rule matches the given input, otherwise false.
 */
NormalizerRule.prototype.matches = function matches(input) {
var segments = this.<span class="apidocCodeKeywordSpan">getSegments</span>(input)

for (var i = 0; i &#x3c; segments.length; ++i) {
  if (this.pattern.test(segments[i])) {
    return true
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.rule.prototype.matches" id="apidoc.element.newrelic.rule.prototype.matches">
        function <span class="apidocSignatureSpan">newrelic.rule.prototype.</span>matches
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matches(input) {
  var segments = this.getSegments(input)

  for (var i = 0; i &#x3c; segments.length; ++i) {
    if (this.pattern.test(segments[i])) {
      return true
    }
  }

  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {string?} - The normalized url, or `null` if this is an ignore rule
 *  that matched this url.
 */
NormalizerRule.prototype.apply = function apply(input) {
// For ignore rules, just see if we match and return either `null` or the
// original input.
if (this.ignore) {
  return (this.matched = this.<span class="apidocCodeKeywordSpan">matches</span>(input)) ? null : input
}

this.matched = false
var result = this.getSegments(input)
  .map(function applyMap(segment) {
    // Discussion of why we use `lastIndex` in function documentation to
    // prevent de-opt due to long function.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.rule.prototype.toJSON" id="apidoc.element.newrelic.rule.prototype.toJSON">
        function <span class="apidocSignatureSpan">newrelic.rule.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
  return {
    eachSegment: this.eachSegment,
    precedence: this.precedence,
    isTerminal: this.isTerminal,
    replacement: this.replacement,
    replaceAll: this.replaceAll,
    ignore: this.ignore,
    pattern: this.pattern.source
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this._processCustomEvents()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.<span class="apidocCodeKeywordSpan">toJSON</span>().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}

var metrics = this.metrics
var beginSeconds = metrics.started * FROM_MILLIS
var endSeconds = Date.now() * FROM_MILLIS
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.safe_json" id="apidoc.module.newrelic.safe_json">module newrelic.safe_json</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.safe_json.parse" id="apidoc.element.newrelic.safe_json.parse">
        function <span class="apidocSignatureSpan">newrelic.safe_json.</span>parse
        <span class="apidocSignatureSpan">(str, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseAsync(str, cb) {
  try {
    cb(null, JSON.parse(str))
  } catch (err) {
    cb(err, null)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    default:
      return true
  }
}

function fromObjectList(setting) {
  try {
    return JSON.<span class="apidocCodeKeywordSpan">parse</span>(&#x27;[&#x27; + setting + &#x27;]&#x27;)
  } catch (error) {
    logger.error(&#x22;New Relic configurator could not deserialize object list:&#x22;)
    logger.error(error.stack)
  }
}

function _findConfigFile() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.safe_json.stringify" id="apidoc.element.newrelic.safe_json.stringify">
        function <span class="apidocSignatureSpan">newrelic.safe_json.</span>stringify
        <span class="apidocSignatureSpan">(obj, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringifyAsync(obj, cb) {
  try {
    cb(null, stringifySafe(obj))
  } catch (err) {
    cb(err, &#x27;[UNPARSABLE OBJECT]&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // we don&#x27;t use these parameters yet
  agentToken: null
}

// if debugging, do pretty format of JSON
var tabs = config.browser_monitoring.debug ? 2 : 0
var json = JSON.<span class="apidocCodeKeywordSpan">stringify</span>(rum_hash, null, tabs)


// the complete header to be written to the browser
var out = util.format(
  RUM_STUB,
  json,
  js_agent_loader
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.safe_json.stringifySync" id="apidoc.element.newrelic.safe_json.stringifySync">
        function <span class="apidocSignatureSpan">newrelic.safe_json.</span>stringifySync
        <span class="apidocSignatureSpan">(obj, returnVal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stringifySync(obj, returnVal) {
  try {
    return stringifySafe(obj)
  } catch (err) {
    return returnVal || &#x27;[UNPARSABLE OBJECT]&#x27;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.name = name
this._config = config
}

RemoteMethod.prototype.serialize = function serialize(payload, callback) {
try {
  var res = safeJSON.<span class="apidocCodeKeywordSpan">stringifySync</span>(payload)
} catch (error) {
  logger.error(error, &#x22;Unable to serialize payload for method %s.&#x22;, this.name)
  return process.nextTick(function cb_nextTick() {
    return callback(error)
  })
}
return callback(null, res)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.sampler" id="apidoc.module.newrelic.sampler">module newrelic.sampler</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.sampler.checkEvents" id="apidoc.element.newrelic.sampler.checkEvents">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>checkEvents
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkEvents(agent) {
  return function eventSampler() {
    var timer = new Timer()
    timer.begin()
    setTimeout(recordQueueTime.bind(null, agent, timer), 0)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.sampleCpu" id="apidoc.element.newrelic.sampler.sampleCpu">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleCpu
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleCpu(agent) {
  var lastSample
  var recordCPU = generateCPUMetricRecorder(agent)
  return function cpuSampler() {
    var cpuSample = getCpuSample(lastSample)
    lastSample = getCpuSample()

    if (lastSample == null) {
      return
    }

    recordCPU(cpuSample.user / MICROS, cpuSample.system / MICROS)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.sampleGc" id="apidoc.element.newrelic.sampler.sampleGc">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleGc
        <span class="apidocSignatureSpan">(agent, nativeMetrics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleGc(agent, nativeMetrics) {
  // Hook into the stats event to accumulate total pause time and record per-run
  // pause time metric.
  nativeMetrics.on(&#x27;gc&#x27;, function onGCStatsEvent(stats) {
    var duration = stats.duration / NANOS
    recordValue(agent, NAMES.GC.PAUSE_TIME, duration)

    if (stats.type) {
      recordValue(agent, NAMES.GC.PREFIX + stats.type, duration)
    } else {
      logger.debug(stats, &#x27;Unknown GC type %j&#x27;, stats.typeId)
    }
  })

  return function gcSampler() {
    // NOOP?
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.sampleLoop" id="apidoc.element.newrelic.sampler.sampleLoop">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleLoop
        <span class="apidocSignatureSpan">(agent, nativeMetrics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleLoop(agent, nativeMetrics) {
  return function loopSampler() {
    var loopMetrics = nativeMetrics.getLoopMetrics()

    // convert from microseconds to seconds
    loopMetrics.usage.min = loopMetrics.usage.min / MICROS
    loopMetrics.usage.max = loopMetrics.usage.max / MICROS
    loopMetrics.usage.total = loopMetrics.usage.total / MICROS
    loopMetrics.usage.sumOfSquares = loopMetrics.usage.sumOfSquares / (MICROS * MICROS)

    recordCompleteMetric(agent, NAMES.LOOP.USAGE, loopMetrics.usage)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.sampleMemory" id="apidoc.element.newrelic.sampler.sampleMemory">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleMemory
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleMemory(agent) {
  return function memorySampler() {
    try {
      var mem = process.memoryUsage()
      agent.metrics.measureBytes(NAMES.MEMORY.PHYSICAL, mem.rss)
      agent.metrics.measureBytes(NAMES.MEMORY.USED_HEAP, mem.heapUsed)
      agent.metrics.measureBytes(NAMES.MEMORY.MAX_HEAP, mem.heapTotal)
      agent.metrics.measureBytes(NAMES.MEMORY.FREE_HEAP, mem.heapTotal - mem.heapUsed)
      agent.metrics.measureBytes(NAMES.MEMORY.USED_NONHEAP, mem.rss - mem.heapTotal)
      logger.trace(&#x27;Recorded memory:&#x27;, mem)
    } catch (e) {
      logger.debug(&#x27;Could not record memory usage&#x27;, e)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.start" id="apidoc.element.newrelic.sampler.start">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>start
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start(agent) {
  samplers.push(new Sampler(sampleMemory(agent), 5 * MILLIS))
  samplers.push(new Sampler(checkEvents(agent), SAMPLE_INTERVAL))
  var metricFeatureFlag = agent.config.feature_flag.native_metrics

  // This requires a native module which may have failed to build.
  if (!this.nativeMetrics) {
    if (metricFeatureFlag) {
      try {
        this.nativeMetrics = require(&#x27;@newrelic/native-metrics&#x27;)({
          timeout: SAMPLE_INTERVAL
        })
      } catch (err) {
        logger.info(
          {error: {message: err.message, stack: err.stack}},
          &#x27;Not adding native metric sampler.&#x27;
        )
        agent.metrics.getOrCreateMetric(
          NAMES.SUPPORTABILITY.DEPENDENCIES + &#x27;/NoNativeMetricsModule&#x27;
        ).incrementCallCount()
      }
    } else {
      logger.info(&#x27;Feature flag for native metrics is false&#x27;)
    }
  }

  if (this.nativeMetrics) {
    if (!this.nativeMetrics.bound) {
      this.nativeMetrics.bind(SAMPLE_INTERVAL)
    }

    // Add GC events if available.
    if (this.nativeMetrics.gcEnabled) {
      samplers.push(new Sampler(sampleGc(agent, this.nativeMetrics), SAMPLE_INTERVAL))
    }

    // Add loop metrics if available.
    if (this.nativeMetrics.loopEnabled) {
      samplers.push(new Sampler(sampleLoop(agent, this.nativeMetrics), SAMPLE_INTERVAL))
    }
  }

  // Add CPU sampling using the built-in data if available, otherwise pulling
  // from the native module.
  if (process.cpuUsage) { // introduced in 6.1.0
    samplers.push(new Sampler(sampleCpu(agent), SAMPLE_INTERVAL))
  } else if (this.nativeMetrics &#x26;&#x26; this.nativeMetrics.usageEnabled) {
    samplers.push(
      new Sampler(sampleCpuNative(agent, this.nativeMetrics), SAMPLE_INTERVAL)
    )
  } else {
    logger.debug(&#x27;Not adding CPU metric sampler.&#x27;)
  }

  sampler.state = &#x27;running&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error(message)
      }

      var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
      shimmer.patchModule(agent)
      shimmer.bootstrapInstrumentation(agent)

      agent.<span class="apidocCodeKeywordSpan">start</span>(function cb_start(error) {
if (!error) {
  return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
}

var errorMessage = &#x22;New Relic for Node.js halted startup due to an error:&#x22;
logger.error(error, errorMessage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.stop" id="apidoc.element.newrelic.sampler.stop">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stop() {
  samplers.forEach(function forEachSampler(s) {
    s.stop()
  })
  samplers = []
  sampler.state = &#x27;stopped&#x27;
  if (this.nativeMetrics) {
    this.nativeMetrics.unbind()
    this.nativeMetrics.removeAllListeners()

    // Setting this.nativeMetrics to null allows us to config a new
    // nativeMetrics object after the first start call.
    this.nativeMetrics = null
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function cb_harvest(error) {
  if (error) {
    logger.error(
      error,
      &#x27;An error occurred while running last harvest before shutdown.&#x27;
    )
  }
  agent.<span class="apidocCodeKeywordSpan">stop</span>(callback)
}

if (options &#x26;&#x26; options.collectPendingData &#x26;&#x26; agent._state !== &#x27;started&#x27;) {
  if (typeof options.timeout === &#x27;number&#x27;) {
    var shutdownTimeout = setTimeout(function shutdownTimeout() {
      agent.stop(callback)
    }, options.timeout)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.segment" id="apidoc.module.newrelic.segment">module newrelic.segment</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.segment.segment" id="apidoc.element.newrelic.segment.segment">
        function <span class="apidocSignatureSpan">newrelic.</span>segment
        <span class="apidocSignatureSpan">(transaction, name, recorder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TraceSegment(transaction, name, recorder) {
  if (!transaction) throw new Error(&#x27;All segment must be associated with a transaction.&#x27;)
  if (!name) throw new Error(&#x27;All segment must be named&#x27;)

  this.name = name
  this.transaction = transaction

  transaction.numSegments++
  transaction.agent.totalActiveSegments++
  transaction.agent.segmentsCreatedInHarvest++

  if (recorder) {
    transaction.addRecorder(recorder.bind(null, this))
  }

  this.parameters = {nr_exclusive_duration_millis: null}
  this.children = []

  this.timer = new Timer()

  // hidden class optimization
  this.partialName = null
  this._exclusiveDuration = null
  this._collect = true
  this.host = null
  this.port = null
  this.state = STATE.EXTERNAL
  this.async = true
  this.ignore = false

  this.probe(&#x27;new TraceSegment&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.segment.prototype" id="apidoc.module.newrelic.segment.prototype">module newrelic.segment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype._getChildPairs" id="apidoc.element.newrelic.segment.prototype._getChildPairs">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>_getChildPairs
        <span class="apidocSignatureSpan">(end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getChildPairs(end) {
  // quick optimization
  if (this.children.length &#x3c; 1) return []
  if (!end) end = Infinity

  var children = this.getChildren()
  var childPairs = []
  while (children.length) {
    var child = children.pop()
    var pair = child.timer.toRange()

    if (pair[0] &#x3e;= end) continue

    children = children.concat(child.getChildren())

    pair[1] = Math.min(pair[1], end)
    childPairs.push(pair)
  }

  return childPairs
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this._exclusiveDuration) return this._exclusiveDuration

var total = this.getDurationInMillis()
var end = this.timer.toRange()[1]

if (this.children.length &#x3e; 0) {
  // convert the list of start, duration pairs to start, end pairs
  total -= sumChildren(this.<span class="apidocCodeKeywordSpan">_getChildPairs</span>(end), end)
}

return total
}

TraceSegment.prototype.getChildren = function getChildren() {
var children = []
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype._isEnded" id="apidoc.element.newrelic.segment.prototype._isEnded">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>_isEnded
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _isEnded() {
  return !this.timer.isActive() || this.timer.touched
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype._setExclusiveDurationInMillis" id="apidoc.element.newrelic.segment.prototype._setExclusiveDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>_setExclusiveDurationInMillis
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _setExclusiveDurationInMillis(duration) {
  this._exclusiveDuration = duration
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype._updateRootTimer" id="apidoc.element.newrelic.segment.prototype._updateRootTimer">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>_updateRootTimer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _updateRootTimer() {
  var root = this.transaction.trace.root
  if (this.timer.endsAfter(root.timer)) {
    var newDuration = (
      this.timer.start +
      this.getDurationInMillis() -
      root.timer.start
    )
    root.overwriteDurationInMillis(newDuration)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * A segment attached to something evented (such as a database
 * cursor) just finished an action, so set the timer to mark
 * the timer as having a stop time.
 */
TraceSegment.prototype.touch = function touch() {
  this.probe(&#x27;Touched&#x27;)
  this.timer.touch()
  this.<span class="apidocCodeKeywordSpan">_updateRootTimer</span>()
}

TraceSegment.prototype.overwriteDurationInMillis = overwriteDurationInMillis
function overwriteDurationInMillis(duration, start) {
  this.timer.overwriteDurationInMillis(duration, start)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.add" id="apidoc.element.newrelic.segment.prototype.add">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>add
        <span class="apidocSignatureSpan">(childName, recorder)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(childName, recorder) {
  logger.trace(&#x27;Adding segment %s to %s&#x27;, childName, this.name)
  var segment = new TraceSegment(this.transaction, childName, recorder)
  var config = this.transaction.agent.config

  if (this.transaction.trace.segmentsSeen++ &#x3e;= config.max_trace_segments) {
    segment._collect = false
  }
  this.children.push(segment)

  if (config.debug &#x26;&#x26; config.debug.double_linked_transactions) {
    segment.parent = this
  }

  return segment
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 var instrinics = {
   type: eventType,
   timestamp: Date.now()
 }

 this.agent.customEvents.<span class="apidocCodeKeywordSpan">add</span>([instrinics, attributes])
}

/**
* Shuts down the agent.
*
* @param {object}  [options]                           object with shut down options
* @param {boolean} [options.collectPendingData=false]  If true, the agent will send any
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.captureDBInstanceAttributes" id="apidoc.element.newrelic.segment.prototype.captureDBInstanceAttributes">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>captureDBInstanceAttributes
        <span class="apidocSignatureSpan">(host, port, database)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureDBInstanceAttributes(host, port, database) {
  var config = this.transaction.agent.config
  var dsTracerConf = config.datastore_tracer

  // Add database name if provided and enabled.
  if (database !== false &#x26;&#x26; dsTracerConf.database_name_reporting.enabled) {
    this.parameters.database_name =
      typeof database === &#x27;number&#x27; ? database : (database || INSTANCE_UNKNOWN)
  }

  // Add instance information if enabled.
  if (dsTracerConf.instance_reporting.enabled) {
    // Determine appropriate defaults for host and port.
    port = port || INSTANCE_UNKNOWN
    if (host &#x26;&#x26; urltils.isLocalhost(host)) {
      host = config.getHostnameSafe(host)
    }
    if (!host || host === &#x27;UNKNOWN_BOX&#x27;) { // Config&#x27;s default name of a host.
      host = INSTANCE_UNKNOWN
    }
    this.parameters.host = host
    this.parameters.port_path_or_id = String(port)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var location = null
if (typeof server === &#x27;string&#x27;) {
  location = server.split(&#x27;:&#x27;)
} else if (this.HashRing &#x26;&#x26; this.HashRing.get &#x26;&#x26; metacall.key) {
  location = this.HashRing.get(metacall.key).split(&#x27;:&#x27;)
}
if (location) {
  segment.<span class="apidocCodeKeywordSpan">captureDBInstanceAttributes</span>(location[0], location[1], false)
}

urltils.copyParameters(
  agent.config,
  {
    key: stringifySync(keys[0], &#x27;Unknown&#x27;)
  },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.end" id="apidoc.element.newrelic.segment.prototype.end">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end() {
  if (!this.timer.isActive()) return
  this.probe(&#x27;Ended&#x27;)
  this.timer.end()
  this._updateRootTimer()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tracer = this.agent.tracer
var tx = tracer.getTransaction()

if (tx) {
  if (tx.webSegment) {
    tx.setName(tx.url, 0)
    tx.webSegment.markAsWeb(tx.url)
    tx.webSegment.<span class="apidocCodeKeywordSpan">end</span>()
  } else if (tx.bgSegment) {
    tx.bgSegment.end()
  }
  logger.debug(&#x27;ending transaction with id: %s and name: %s&#x27;, tx.id, tx.name)
  tx.end()
} else {
  logger.debug(&#x27;endTransaction() called while not in a transaction.&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.getChildren" id="apidoc.element.newrelic.segment.prototype.getChildren">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>getChildren
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getChildren() {
  var children = []
  for (var i = 0, len = this.children.length; i &#x3c; len; ++i) {
    if (!this.children[i].ignore) {
      children.push(this.children[i])
    }
  }
  return children
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *                  having an end greater than the passed in end time.
 */
TraceSegment.prototype._getChildPairs = function _getChildPairs(end) {
  // quick optimization
  if (this.children.length &#x3c; 1) return []
  if (!end) end = Infinity

  var children = this.<span class="apidocCodeKeywordSpan">getChildren</span>()
  var childPairs = []
  while (children.length) {
var child = children.pop()
var pair = child.timer.toRange()

if (pair[0] &#x3e;= end) continue
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.getCollectedChildren" id="apidoc.element.newrelic.segment.prototype.getCollectedChildren">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>getCollectedChildren
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCollectedChildren() {
  var children = []
  for (var i = 0, len = this.children.length; i &#x3c; len; ++i) {
    if (this.children[i]._collect &#x26;&#x26; !this.children[i].ignore) {
      children.push(this.children[i])
    }
  }
  return children
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  segment.parameters.nr_exclusive_duration_millis =
    segment.getExclusiveDurationInMillis()
}

var start = segment.timer.startedRelativeTo(segment.transaction.trace.root.timer)
var duration = segment.getDurationInMillis()

var segmentChildren = segment.<span class="apidocCodeKeywordSpan">getCollectedChildren</span>()

var serializedSegment = [
  start,
  start + duration,
  segment.name,
  segment.parameters,
  new Array(segmentChildren.length)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.getDurationInMillis" id="apidoc.element.newrelic.segment.prototype.getDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>getDurationInMillis
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDurationInMillis() {
  return this.timer.getDurationInMillis()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* If we&#x27;re in an unnamed transaction, add a friendly warning this is to
 * avoid people going crazy, trying to figure out why browser monitoring is
 * not working when they&#x27;re missing a transaction name.
 */
if (!name) return _gracefail(3)

var time = trans.timer.<span class="apidocCodeKeywordSpan">getDurationInMillis</span>()

/*
 * Only the first 13 chars of the license should be used for hashing with
 * the transaction name.
 */
var key = config.license_key.substr(0, 13)
var appid = config.application_id
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.getExclusiveDurationInMillis" id="apidoc.element.newrelic.segment.prototype.getExclusiveDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>getExclusiveDurationInMillis
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExclusiveDurationInMillis() {
  if (this._exclusiveDuration) return this._exclusiveDuration

  var total = this.getDurationInMillis()
  var end = this.timer.toRange()[1]

  if (this.children.length &#x3e; 0) {
    // convert the list of start, duration pairs to start, end pairs
    total -= sumChildren(this._getChildPairs(end), end)
  }

  return total
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.trace = new Error()
  this.raw = raw
}
}

ParsedStatement.prototype.recordMetrics = function recordMetrics(segment, scope) {
var duration = segment.getDurationInMillis()
var exclusive = segment.<span class="apidocCodeKeywordSpan">getExclusiveDurationInMillis</span>()
var transaction = segment.transaction
var type = transaction.isWeb() ? DB.WEB : DB.OTHER
var thisTypeSlash = this.type + &#x27;/&#x27;
var operation = DB.OPERATION + &#x27;/&#x27; + thisTypeSlash + this.operation

// Rollups
transaction.measure(operation, null, duration, exclusive)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.isInCallbackState" id="apidoc.element.newrelic.segment.prototype.isInCallbackState">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>isInCallbackState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isInCallbackState() {
  return this.state === STATE.CALLBACK
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.markAsWeb" id="apidoc.element.newrelic.segment.prototype.markAsWeb">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>markAsWeb
        <span class="apidocSignatureSpan">(rawURL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function markAsWeb(rawURL) {
  var transaction = this.transaction

  // transaction name and web segment name must match
  this.name = transaction.name
  // partialName is used to name apdex metrics when recording
  this.partialName = transaction._partialName

  var config = transaction.agent.config

  // Copy params object so we can modify it before applying it
  // multiple params places. It eventually runs through copyParameters
  // so I&#x27;m not worried about `ignored_params` or `capture_params`.
  var params = util._extend({}, this.parameters)

  // This shouldn&#x27;t be moved from the segment to the trace, so remove it.
  delete params.nr_exclusive_duration_millis

  // Because we are assured we have the URL here, lets grab query
  // params. We want to opt for keeping the keys that are already on
  // params, so we use copyParameters
  urltils.copyParameters(config, urltils.parseParameters(rawURL), params)

  urltils.copyParameters(config, params, this.parameters)
  urltils.copyParameters(config, params, this.transaction.trace.parameters)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var tracer = this.agent.tracer
var tx = tracer.getTransaction()

if (tx) {
  if (tx.webSegment) {
    tx.setName(tx.url, 0)
    tx.webSegment.<span class="apidocCodeKeywordSpan">markAsWeb</span>(tx.url)
    tx.webSegment.end()
  } else if (tx.bgSegment) {
    tx.bgSegment.end()
  }
  logger.debug(&#x27;ending transaction with id: %s and name: %s&#x27;, tx.id, tx.name)
  tx.end()
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.moveToCallbackState" id="apidoc.element.newrelic.segment.prototype.moveToCallbackState">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>moveToCallbackState
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveToCallbackState() {
  this.state = STATE.CALLBACK
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.overwriteDurationInMillis" id="apidoc.element.newrelic.segment.prototype.overwriteDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>overwriteDurationInMillis
        <span class="apidocSignatureSpan">(duration, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function overwriteDurationInMillis(duration, start) {
  this.timer.overwriteDurationInMillis(duration, start)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.probe(&#x27;Touched&#x27;)
  this.timer.touch()
  this._updateRootTimer()
}

TraceSegment.prototype.overwriteDurationInMillis = overwriteDurationInMillis
function overwriteDurationInMillis(duration, start) {
  this.timer.<span class="apidocCodeKeywordSpan">overwriteDurationInMillis</span>(duration, start)
}


TraceSegment.prototype.start = function start() {
  this.timer.begin()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.probe" id="apidoc.element.newrelic.segment.prototype.probe">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>probe
        <span class="apidocSignatureSpan">(action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function probe(action) {
  if (this.transaction.traceStacks) {
    this.transaction.probe(action, {segment: this.name})
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this._collect = true
 this.host = null
 this.port = null
 this.state = STATE.EXTERNAL
 this.async = true
 this.ignore = false

 this.<span class="apidocCodeKeywordSpan">probe</span>(&#x27;new TraceSegment&#x27;)
}

/**
* @param {string} host
*  The name of the host of the database. This will be normalized if the string
*  represents localhost.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.setDurationInMillis" id="apidoc.element.newrelic.segment.prototype.setDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>setDurationInMillis
        <span class="apidocSignatureSpan">(duration, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setDurationInMillis(duration, start) {
  this.timer.setDurationInMillis(duration, start)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Set the duration of the segment explicitly.
 *
 * @param {Number} duration Duration in milliseconds.
 */
TraceSegment.prototype.setDurationInMillis = setDurationInMillis

function setDurationInMillis(duration, start) {
  this.timer.<span class="apidocCodeKeywordSpan">setDurationInMillis</span>(duration, start)
}

TraceSegment.prototype.getDurationInMillis = function getDurationInMillis() {
  return this.timer.getDurationInMillis()
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.start" id="apidoc.element.newrelic.segment.prototype.start">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start() {
  this.timer.begin()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error(message)
      }

      var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
      shimmer.patchModule(agent)
      shimmer.bootstrapInstrumentation(agent)

      agent.<span class="apidocCodeKeywordSpan">start</span>(function cb_start(error) {
if (!error) {
  return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
}

var errorMessage = &#x22;New Relic for Node.js halted startup due to an error:&#x22;
logger.error(error, errorMessage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.toJSON" id="apidoc.element.newrelic.segment.prototype.toJSON">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
  // use depth-first search on the segment tree using stack
  var segmentsToProcess = [this]
  // used to keep track of the last parent to add child JSONs to, it will hold
  // pairs of the parent serialized segment and number of children it is expecting
  // to have added
  var parentStack = []
  var resultTreeJson = null

  while (segmentsToProcess.length !== 0) {
    var segment = segmentsToProcess.pop()

    if (!segment.parameters.nr_exclusive_duration_millis) {
      segment.parameters.nr_exclusive_duration_millis =
        segment.getExclusiveDurationInMillis()
    }

    var start = segment.timer.startedRelativeTo(segment.transaction.trace.root.timer)
    var duration = segment.getDurationInMillis()

    var segmentChildren = segment.getCollectedChildren()

    var serializedSegment = [
      start,
      start + duration,
      segment.name,
      segment.parameters,
      new Array(segmentChildren.length)
    ]

    if (resultTreeJson === null) {
      resultTreeJson = serializedSegment
    }

    if (parentStack.length !== 0) {
      // get last visited parent
      var parent = parentStack[parentStack.length - 1]

      var parentChildren = parent[0][4]
      var childIndex = --parent[1]

      parentChildren[childIndex] = serializedSegment

      // if the parent received all its children data, remove the parent from the stack
      if (childIndex === 0) {
        parentStack.pop()
      }
    }

    if (segmentChildren.length) {
      parentStack.push([serializedSegment, segmentChildren.length])
      segmentsToProcess = segmentsToProcess.concat(segmentChildren)
    }
  }
  return resultTreeJson
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this._processCustomEvents()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.<span class="apidocCodeKeywordSpan">toJSON</span>().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}

var metrics = this.metrics
var beginSeconds = metrics.started * FROM_MILLIS
var endSeconds = Date.now() * FROM_MILLIS
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.segment.prototype.touch" id="apidoc.element.newrelic.segment.prototype.touch">
        function <span class="apidocSignatureSpan">newrelic.segment.prototype.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function touch() {
  this.probe(&#x27;Touched&#x27;)
  this.timer.touch()
  this._updateRootTimer()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.state === PENDING) return 0

// only set by setDurationInMillis
if (this.durationInMillis !== null &#x26;&#x26; this.durationInMillis &#x3e;= 0) {
  return this.durationInMillis
}

// prioritize .end() and .<span class="apidocCodeKeywordSpan">touch</span>()
if (this.hrDuration) {
  return hrToMillis(this.hrDuration)
}

if (this.duration) {
  return this.duration
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.shimmer" id="apidoc.module.newrelic.shimmer">module newrelic.shimmer</a></h1>




    <h2>
        <a href="#apidoc.element.newrelic.shimmer.bootstrapInstrumentation" id="apidoc.element.newrelic.shimmer.bootstrapInstrumentation">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>bootstrapInstrumentation
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bootstrapInstrumentation(agent) {
  var globalsFilepath = path.join(__dirname, &#x27;instrumentation&#x27;, &#x27;core&#x27;, &#x27;globals.js&#x27;)
  instrument(agent, &#x27;globals&#x27;, globalsFilepath, global)

  Object.keys(CORE_INSTRUMENTATION).forEach(function cb_forEach(mojule) {
    var filename = CORE_INSTRUMENTATION[mojule]
    var filepath = path.join(__dirname, &#x27;instrumentation/core&#x27;, filename)
    var uninstrumented

    try {
      uninstrumented = require(mojule)
    } catch (err) {
      logger.trace(
        &#x27;Could not load core module %s got error %s&#x27;,
        mojule,
        err
      )
    }

    instrument(agent, filename, filepath, uninstrumented, mojule)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          &#x22;NEW_RELIC_APP_NAME. Not starting!&#x22;
logger.error(message)
throw new Error(message)
      }

      var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
      shimmer.patchModule(agent)
      shimmer.<span class="apidocCodeKeywordSpan">bootstrapInstrumentation</span>(agent)

      agent.start(function cb_start(error) {
if (!error) {
  return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
}

var errorMessage = &#x22;New Relic for Node.js halted startup due to an error:&#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.isWrapped" id="apidoc.element.newrelic.shimmer.isWrapped">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>isWrapped
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWrapped(fn) {
  return !!(fn &#x26;&#x26; fn.__NR_original)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If we wrap it, we know exactly when each handler in the chain is called. Based on
// that we can build the path from nested route handlers.
if (layer) {
  if (layer.constructor) {
    var layerProto = layer.constructor.prototype
    if (
      layerProto.handle_request &#x26;&#x26;
      !shimmer.<span class="apidocCodeKeywordSpan">isWrapped</span>(layerProto.handle_request)
    ) {
      shimmer.wrapMethod(layerProto,
                        &#x27;express.Layer&#x27;,
                        &#x27;handle_request&#x27;,
                        wrapLayerHandleRequest)
    }
    if (
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.patchModule" id="apidoc.element.newrelic.shimmer.patchModule">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>patchModule
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function patchModule(agent) {
  logger.trace(&#x22;Wrapping module loader.&#x22;)
  var Module = require(&#x27;module&#x27;)

  shimmer.wrapMethod(Module, &#x27;Module&#x27;, &#x27;_load&#x27;, function cb_wrapMethod(load) {
    return function cls_wrapMethod(file) {
      return _postLoad(agent, load.apply(this, arguments), file)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            &#x22;Set app_name in your newrelic.js file or set environment variable\n&#x22; +
            &#x22;NEW_RELIC_APP_NAME. Not starting!&#x22;
  logger.error(message)
  throw new Error(message)
}

var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
shimmer.<span class="apidocCodeKeywordSpan">patchModule</span>(agent)
shimmer.bootstrapInstrumentation(agent)

agent.start(function cb_start(error) {
  if (!error) {
    return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.reinstrument" id="apidoc.element.newrelic.shimmer.reinstrument">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>reinstrument
        <span class="apidocSignatureSpan">(agent, modulePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinstrument(agent, modulePath) {
  return _postLoad(agent, require(modulePath), modulePath)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.unpatchModule" id="apidoc.element.newrelic.shimmer.unpatchModule">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unpatchModule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unpatchModule() {
  logger.trace(&#x22;Unwrapping to previous module loader.&#x22;)
  var Module = require(&#x27;module&#x27;)

  shimmer.unwrapMethod(Module, &#x27;Module&#x27;, &#x27;_load&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.unwrapAll" id="apidoc.element.newrelic.shimmer.unwrapAll">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unwrapAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unwrapAll() {
  instrumented.forEach(function cb_forEach(wrapper) {
    wrapper.__NR_unwrap()
  })
  instrumented = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.unwrapMethod" id="apidoc.element.newrelic.shimmer.unwrapMethod">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unwrapMethod
        <span class="apidocSignatureSpan">(nodule, noduleName, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unwrapMethod(nodule, noduleName, method) {
  if (!noduleName) noduleName = &#x27;[unknown]&#x27;
  if (!method) return logger.debug(&#x22;Must include a method name to unwrap. &#x22; +
                                   &#x22;Called from: %s&#x22;, new Error().stack)

  var fqmn = noduleName + &#x27;.&#x27; + method

  if (!nodule) return logger.debug(&#x22;Can&#x27;t unwrap %s from nonexistent object.&#x22;,
                                   fqmn)
  var wrapped = nodule[method]

  // keep instrumented up to date
  var pos = instrumented.indexOf(wrapped)
  if (pos !== -1) instrumented.splice(pos, 1)

  if (!wrapped) return logger.debug(&#x22;%s not defined, so not unwrapping.&#x22;, fqmn)
  if (!wrapped.__NR_unwrap) return logger.debug(&#x22;%s isn&#x27;t unwrappable.&#x22;, fqmn)

  wrapped.__NR_unwrap()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})
  },

  unpatchModule: function unpatchModule() {
logger.trace(&#x22;Unwrapping to previous module loader.&#x22;)
var Module = require(&#x27;module&#x27;)

shimmer.<span class="apidocCodeKeywordSpan">unwrapMethod</span>(Module, &#x27;Module&#x27;, &#x27;_load&#x27;)
  },

  bootstrapInstrumentation: function bootstrapInstrumentation(agent) {
var globalsFilepath = path.join(__dirname, &#x27;instrumentation&#x27;, &#x27;core&#x27;, &#x27;globals.js&#x27;)
instrument(agent, &#x27;globals&#x27;, globalsFilepath, global)

Object.keys(CORE_INSTRUMENTATION).forEach(function cb_forEach(mojule) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.wrapDeprecated" id="apidoc.element.newrelic.shimmer.wrapDeprecated">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>wrapDeprecated
        <span class="apidocSignatureSpan">(nodule, noduleName, property, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapDeprecated(nodule, noduleName, property, options) {
  if (!property) {
    logger.warn(new Error(), &#x22;Must include a function name to wrap. Called from:&#x22;)
    return
  }

  if (!noduleName) noduleName = &#x27;[unknown]&#x27;

  var fqmn = noduleName + &#x27;.&#x27; + property
  if (!nodule) {
    logger.debug(&#x22;Can&#x27;t wrap %s from nonexistent object.&#x22;, fqmn)
    return
  }

  var original = nodule[property]
  if (!original) {
    logger.trace(&#x22;%s not defined, so not wrapping.&#x22;, fqmn)
    return
  }

  delete nodule[property]

  var descriptor = {
    configurable: true,
    enumerable: true
  }
  if (options.get) descriptor.get = options.get
  if (options.set) descriptor.set = options.set
  Object.defineProperty(nodule, property, descriptor)
  logger.trace(&#x22;Instrumented %s.&#x22;, fqmn)

  if (shimmer.debug) {
    instrumented.push({
      __NR_unwrap: function unwrapDeprecated() {
        delete nodule[property]
        nodule[property] = original
      }
    })
  }

  return original
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  if (deprecatedCreateClient) {
    delete http.createClient
    http.createClient = deprecatedCreateClient
  }
}

DeprecatedClient = shimmer.<span class="apidocCodeKeywordSpan">wrapDeprecated</span>(
  http,
  &#x27;http&#x27;,
  &#x27;Client&#x27;,
  {
    get: function get() {
      var example = new DeprecatedClient(80, &#x27;localhost&#x27;)
      wrapLegacyClient(agent, example.constructor.prototype)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.wrapMethod" id="apidoc.element.newrelic.shimmer.wrapMethod">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>wrapMethod
        <span class="apidocSignatureSpan">(nodule, noduleName, methods, wrapper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapMethod(nodule, noduleName, methods, wrapper) {
  if (!methods) {
    return logger.warn(new Error(),
                       &#x22;Must include a method name to wrap. Called from:&#x22;)
  }

  if (!noduleName) noduleName = &#x27;[unknown]&#x27;
  if (!Array.isArray(methods)) methods = [methods]

  methods.forEach(function cb_forEach(method) {
    var fqmn = noduleName + &#x27;.&#x27; + method

    if (!nodule) return logger.debug(&#x22;Can&#x27;t wrap %s from nonexistent object.&#x22;,
                                     fqmn)
    if (!wrapper) return logger.debug(&#x22;Can&#x27;t wrap %s without a wrapper generator.&#x22;,
                                      fqmn)

    var original = nodule[method]

    if (!original) return logger.trace(&#x22;%s not defined, so not wrapping.&#x22;, fqmn)
    if (original.__NR_unwrap) return logger.debug(&#x22;%s already wrapped by agent.&#x22;, fqmn)

    var wrapped = wrapper(original, method)
    wrapped.__NR_original = original
    wrapped.__NR_unwrap = function __NR_unwrap() {
      nodule[method] = original
      logger.trace(&#x22;Removed instrumentation from %s.&#x22;, fqmn)
    }

    nodule[method] = wrapped
    if (shimmer.debug) instrumented.push(wrapped)
    logger.trace(&#x22;Instrumented %s.&#x22;, fqmn)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Patch the module.load function so that we see modules loading and
 * have an opportunity to patch them with instrumentation.
 */
patchModule: function patchModule(agent) {
  logger.trace(&#x22;Wrapping module loader.&#x22;)
  var Module = require(&#x27;module&#x27;)

  shimmer.<span class="apidocCodeKeywordSpan">wrapMethod</span>(Module, &#x27;Module&#x27;, &#x27;_load&#x27;, function cb_wrapMethod
(load) {
    return function cls_wrapMethod(file) {
      return _postLoad(agent, load.apply(this, arguments), file)
    }
  })
},

unpatchModule: function unpatchModule() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.statement_matcher" id="apidoc.module.newrelic.statement_matcher">module newrelic.statement_matcher</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.statement_matcher.statement_matcher" id="apidoc.element.newrelic.statement_matcher.statement_matcher">
        function <span class="apidocSignatureSpan">newrelic.</span>statement_matcher
        <span class="apidocSignatureSpan">(operation, operationPattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StatementMatcher(operation, operationPattern) {
  this.operation = operation
  this.operationPattern = operationPattern
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.statement_matcher.prototype" id="apidoc.module.newrelic.statement_matcher.prototype">module newrelic.statement_matcher.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.statement_matcher.prototype.getParsedStatement" id="apidoc.element.newrelic.statement_matcher.prototype.getParsedStatement">
        function <span class="apidocSignatureSpan">newrelic.statement_matcher.prototype.</span>getParsedStatement
        <span class="apidocSignatureSpan">(type, sql)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getParsedStatement(type, sql) {
  this.operationPattern.lastIndex = 0

  var match = new RegExp(&#x22;^\\s*&#x22; + this.operation, &#x22;ig&#x22;).test(sql)
  if (match) {
    var queryMatch = this.operationPattern.exec(sql)
    var model = queryMatch ? queryMatch[1] : &#x27;unknown&#x27;

    return new ParsedStatement(type, this.operation, model, sql)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  sql = sql.replace(COMMENT_PATTERN, &#x27;&#x27;).trim()


  var parsedStatement

  for (var i = 0, l = OPERATIONS.length; i &#x3c; l; i++) {
    parsedStatement = OPERATIONS[i].<span class="apidocCodeKeywordSpan">getParsedStatement</span>(type, sql)
    if (parsedStatement) {
      return parsedStatement
    }
  }

  return new ParsedStatement(type, &#x27;other&#x27;, null, sql)
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.stream_sink" id="apidoc.module.newrelic.stream_sink">module newrelic.stream_sink</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.stream_sink.stream_sink" id="apidoc.element.newrelic.stream_sink.stream_sink">
        function <span class="apidocSignatureSpan">newrelic.</span>stream_sink
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StreamSink(callback) {
  EventEmitter.call(this)

  this.callback = callback
  this.sink = &#x27;&#x27;
  this.writable = true

  var sink = this
  this.on(&#x27;error&#x27;, function handle_error(error) {
    sink.writable = false
    callback(error)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stream_sink.super_" id="apidoc.element.newrelic.stream_sink.super_">
        function <span class="apidocSignatureSpan">newrelic.stream_sink.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.stream_sink.prototype" id="apidoc.module.newrelic.stream_sink.prototype">module newrelic.stream_sink.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.stream_sink.prototype.destroy" id="apidoc.element.newrelic.stream_sink.prototype.destroy">
        function <span class="apidocSignatureSpan">newrelic.stream_sink.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroy() {
  this.emit(&#x27;close&#x27;)
  this.writable = false

  delete this.sink
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // This will prevent the application from shutting down correctly.
  // Explicitly destroy the socket when the response is completed.
  //
  // This goes against keep-alive, but for now letting the application die
  // gracefully is more important.
  request.on(&#x27;response&#x27;, function cb_on_response(sock) {
    sock.on(&#x27;end&#x27;, function cb_on_end() {
      sock.<span class="apidocCodeKeywordSpan">destroy</span>()
    })
  })
} else if (this._config.ssl) {
  if (this._config.certificates &#x26;&#x26; this._config.certificates.length &#x3e; 0) {
    logger.debug(
      &#x27;Adding custom certificate to the cert bundle.&#x27;
    )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stream_sink.prototype.end" id="apidoc.element.newrelic.stream_sink.prototype.end">
        function <span class="apidocSignatureSpan">newrelic.stream_sink.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end() {
  this.writable = false

  this.callback(null, this.sink)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tracer = this.agent.tracer
var tx = tracer.getTransaction()

if (tx) {
  if (tx.webSegment) {
    tx.setName(tx.url, 0)
    tx.webSegment.markAsWeb(tx.url)
    tx.webSegment.<span class="apidocCodeKeywordSpan">end</span>()
  } else if (tx.bgSegment) {
    tx.bgSegment.end()
  }
  logger.debug(&#x27;ending transaction with id: %s and name: %s&#x27;, tx.id, tx.name)
  tx.end()
} else {
  logger.debug(&#x27;endTransaction() called while not in a transaction.&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stream_sink.prototype.write" id="apidoc.element.newrelic.stream_sink.prototype.write">
        function <span class="apidocSignatureSpan">newrelic.stream_sink.prototype.</span>write
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(string) {
  if (!this.writable) {
    this.emit(&#x27;error&#x27;, new Error(&#x22;Sink no longer writable!&#x22;))
    return false
  }

  // Explicitly copy buffer contents so we are sure to release references to
  // the TLS slab buffer region.
  this.sink += string.toString()

  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Usage:
*
*     var newrelic = require(&#x27;newrelic&#x27;);
*
*     router.get(&#x27;/&#x27;, function (req, res) {
*       var header = newrelic.getBrowserTimingHeader();
*       res.<span class="apidocCodeKeywordSpan">write</span>(header)
*       // write the rest of the page
*     });
*
* This generates the &#x3c;script&#x3e;...&#x3c;/script&#x3e; header necessary for Browser Monitoring
* This script must be manually injected into your templates, as high as possible
* in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.
* Otherwise you may hurt IE!
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.stub_api" id="apidoc.module.newrelic.stub_api">module newrelic.stub_api</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.stub_api.stub_api" id="apidoc.element.newrelic.stub_api.stub_api">
        function <span class="apidocSignatureSpan">newrelic.</span>stub_api
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stub() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.stub_api.prototype" id="apidoc.module.newrelic.stub_api.prototype">module newrelic.stub_api.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.addCustomParameter" id="apidoc.element.newrelic.stub_api.prototype.addCustomParameter">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addCustomParameter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addCustomParameter() {logger.debug(&#x27;Not calling addCustomParameter because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Programmatic version of `rules.ignore` above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. The pattern is mandatory.

### Other API calls

#### newrelic.<span class="apidocCodeKeywordSpan">addCustomParameter</span>(name, value)

Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

#### newrelic.addCustomParameters(params)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.addCustomParameters" id="apidoc.element.newrelic.stub_api.prototype.addCustomParameters">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addCustomParameters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addCustomParameters() {logger.debug(&#x27;Not calling addCustomParameters because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### newrelic.addCustomParameter(name, value)

Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

#### newrelic.<span class="apidocCodeKeywordSpan">addCustomParameters</span>(params)

Set multiple custom parameter values to be attached to a transaction trace and/or
error in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

Example of setting multiple custom parameters at once:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.addIgnoringRule" id="apidoc.element.newrelic.stub_api.prototype.addIgnoringRule">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addIgnoringRule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addIgnoringRule() {logger.debug(&#x27;Not calling addIgnoringRule because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### newrelic.addNamingRule(pattern, name)

Programmatic version of `rules.name` above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. Both parameters are mandatory.

#### newrelic.<span class="apidocCodeKeywordSpan">addIgnoringRule</span>(pattern)

Programmatic version of `rules.ignore` above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. The pattern is mandatory.

### Other API calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.addNamingRule" id="apidoc.element.newrelic.stub_api.prototype.addNamingRule">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addNamingRule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addNamingRule() {logger.debug(&#x27;Not calling addNamingRule because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Can also be set via the environment variable `NEW_RELIC_IGNORING_RULES`, with
multiple rules passed in as a list of comma-delimited patterns:
`NEW_RELIC_IGNORING_RULES=&#x27;^/socket\.io/\*/xhr-polling,ignore_me&#x27;` Note that
currently there is no way to escape commas in patterns.

### API for adding naming and ignoring rules

#### newrelic.<span class="apidocCodeKeywordSpan">addNamingRule</span>(pattern, name)

Programmatic version of `rules.name` above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. Both parameters are mandatory.

#### newrelic.addIgnoringRule(pattern)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.createBackgroundTransaction" id="apidoc.element.newrelic.stub_api.prototype.createBackgroundTransaction">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createBackgroundTransaction
        <span class="apidocSignatureSpan">(name, group, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBackgroundTransaction(name, group, callback) {
  logger.debug(&#x27;Not calling createBackgroundTransaction because New Relic is disabled.&#x27;)
  return (callback === undefined) ? group : callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
independent transaction and any calls within the `handle` will be bound to the
new web transaction.

Custom transactions **must** be ended manually by calling `endTransaction()`.
Timing for custom transaction starts from when the returned wrapped function is
called until `endTransaction()` is called.

#### newrelic.<span class="apidocCodeKeywordSpan">createBackgroundTransaction</span>(name, [group], handle)

`name` is the name of the job. It should be pretty static, and not include job
ids or anything very specific to that run of the job. `group` is optional, and
allows you to group types of jobs together. This should follow similar rules as
the `name`. `handle` is a function that encompases your background job. Both
custom and auto instrumentation will be captured as part of the transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.createTracer" id="apidoc.element.newrelic.stub_api.prototype.createTracer">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createTracer
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTracer(name, callback) {
  logger.debug(&#x27;Not calling createTracer because New Relic is disabled.&#x27;)
  return callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
called until `endTransaction()` is called.

#### newrelic.endTransaction()

This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.

#### newrelic.<span class="apidocCodeKeywordSpan">createTracer</span>(name, handle)

`name` is the name of the tracer. It will show up as a segment in your
transaction traces and create its own metric. `handle` is the function to be
bound to the tracer.

Timing is from when `createTracer` is called until the `handle` done executing.
This should be called inside of a transaction to get data. If it is called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.createWebTransaction" id="apidoc.element.newrelic.stub_api.prototype.createWebTransaction">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createWebTransaction
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createWebTransaction(url, callback) {
  logger.debug(&#x27;Not calling createWebTransaction because New Relic is disabled.&#x27;)
  return callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
varieties of socket servers, and background jobs. These are things that the
agent can&#x27;t automatically instrument because without your knowledge of your
application, the agent can&#x27;t tell when they should begin and end.

Read more at:
https://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/nodejs-custom-instrumentation

#### newrelic.<span class="apidocCodeKeywordSpan">createWebTransaction</span>(url, handle)

`url` is the name of the web transaction. It should be pretty static, not
including anything like user ids or any other data that is very specific to the
request. `handle` is the function you&#x27;d like to wrap in the web transaction.
Both custom and auto instrumentation will be captured as part of the
transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.endTransaction" id="apidoc.element.newrelic.stub_api.prototype.endTransaction">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>endTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endTransaction() {logger.debug(&#x27;Not calling endTransaction because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
transaction and any calls within the `handle` will be bound to the new,
independent background transaction.

Custom transactions **must** be ended manually by calling `endTransaction()`.
Timing for custom transaction starts from when the returned wrapped function is
called until `endTransaction()` is called.

#### newrelic.<span class="apidocCodeKeywordSpan">endTransaction</span>()

This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.

#### newrelic.createTracer(name, handle)

`name` is the name of the tracer. It will show up as a segment in your
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.getBrowserTimingHeader" id="apidoc.element.newrelic.stub_api.prototype.getBrowserTimingHeader">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>getBrowserTimingHeader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getBrowserTimingHeader() {
  logger.debug(&#x27;Not calling getBrowserTimingHeader because New Relic is disabled.&#x27;)
  return &#x27;&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
times.

Headers must be manually injected, but no extra configuration is necessary to
enable browser timings.

### Basics

- Insert the result of `newrelic.<span class="apidocCodeKeywordSpan">getBrowserTimingHeader</span>()`
into your html page.
- The browser timing headers should be placed in the beginning of your `&#x3c;head&#x3e;` tag.
  - As an exception to the above, for maximum IE compatability, the results of `getBrowserTimingHeader()`
should be placed *after* any `X-UA-COMPATIBLE HTTP-EQUIV` meta tags.
- Do *not* cache the header, call it once for every request.

### Example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.incrementMetric" id="apidoc.element.newrelic.stub_api.prototype.incrementMetric">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>incrementMetric
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function incrementMetric() {logger.debug(&#x27;Not calling incrementMetric because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`value` is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If `value` is
an object, it must include keys for `count`, `total`, `min`, `max`, and
`sumOfSquares`.

#### newrelic.<span class="apidocCodeKeywordSpan">incrementMetric</span>(name[, amount])

`name` is the metric name to record, it must be a string that beings with
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`amount` is optional, but must be an integer if provided.  `amount` is
the number of times to increment the metrics `count`, it defaults to 1.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.noticeError" id="apidoc.element.newrelic.stub_api.prototype.noticeError">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>noticeError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noticeError() {logger.debug(&#x27;Not calling noticeError because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you **must**
pass `false` as the parameter  in this case `null` or `undefined` will be
ignored.

#### newrelic.<span class="apidocCodeKeywordSpan">noticeError</span>(error, customParameters)

If your app is doing its own error handling with domains or try/catch clauses,
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.recordCustomEvent" id="apidoc.element.newrelic.stub_api.prototype.recordCustomEvent">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>recordCustomEvent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordCustomEvent() {logger.debug(&#x27;Not calling recordCustomEvent because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Custom Insights Events
 *
 * Custom insights events are JSON object that are sent to New Relic
 * Insights. You can tell the agent to send your custom events via the
 * `newrelic.<span class="apidocCodeKeywordSpan">recordCustomEvent</span>()` API. These events are sampled once the max
 * reservoir size is reached. You can tune this setting below.
 *
 * Read more here: http://newrelic.com/insights
 */
custom_insights_events: {
  /**
   * If this is disabled, the agent does not collect, nor try to send, custom
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.recordMetric" id="apidoc.element.newrelic.stub_api.prototype.recordMetric">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>recordMetric
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordMetric() {logger.debug(&#x27;Not calling recordMetric because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
transaction traces and create its own metric. `handle` is the function to be
bound to the tracer.

Timing is from when `createTracer` is called until the `handle` done executing.
This should be called inside of a transaction to get data. If it is called
outside of a transaction it will just pass through.

#### newrelic.<span class="apidocCodeKeywordSpan">recordMetric</span>(name, value)

`name` is the metric name to record, it must be a string that begins with
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`value` is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If `value` is
an object, it must include keys for `count`, `total`, `min`, `max`, and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.setControllerName" id="apidoc.element.newrelic.stub_api.prototype.setControllerName">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setControllerName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setControllerName() {logger.debug(&#x27;Not calling setControllerName because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.

Explicitly calling `newrelic.setTransactionName()` will override any names set
by Express, Restify or Hapi routes. Calls to `newrelic.setTransactionName()` and
`newrelic.<span class="apidocCodeKeywordSpan">setControllerName</span>()` will overwrite each other. The last call made
before the request ends wins.

**VERY IMPORTANT NOTE:** Do not include highly variable information like GUIDs,
numerical IDs, or timestamps in the request names you create. If your request
is slow enough to generate a transaction trace, that trace will contain the
original URL. If you enable parameter capture, the parameters will also be
attached to the trace. The request names are used to group requests for New
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.setIgnoreTransaction" id="apidoc.element.newrelic.stub_api.prototype.setIgnoreTransaction">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setIgnoreTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setIgnoreTransaction() {logger.debug(&#x27;Not calling setIgnoreTransaction because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example of setting multiple custom parameters at once:

```javascript
newrelic.addCustomParameters({test: &#x27;value&#x27;, test2: &#x27;value2&#x27;});
```

#### newrelic.<span class="apidocCodeKeywordSpan">setIgnoreTransaction</span>(ignored)

Tell the module explicitly whether or not a given request should be ignored.
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you **must**
pass `false` as the parameter  in this case `null` or `undefined` will be
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.setTransactionName" id="apidoc.element.newrelic.stub_api.prototype.setTransactionName">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setTransactionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTransactionName() {logger.debug(&#x27;Not calling setTransactionName because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

is all you need. Please note that you still need to ensure that loading the New
Relic module is the first thing your application does, as it needs to bootstrap
itself before the rest of your application loads, but you can safely require
the module from multiple modules in your application it will only initialize
itself once.

#### newrelic.<span class="apidocCodeKeywordSpan">setTransactionName</span>(name)

Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.

Explicitly calling `newrelic.setTransactionName()` will override any names set
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.shutdown" id="apidoc.element.newrelic.stub_api.prototype.shutdown">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>shutdown
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shutdown(options, cb) {
  logger.debug(&#x27;Not calling shutdown because New Relic is disabled.&#x27;)

  var callback = cb
  if (!callback) {
    if (typeof options === &#x27;function&#x27;) {
      callback = options
    } else {
      callback = new Function()
    }
  }

  process.nextTick(callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
display.

#### newrelic.<span class="apidocCodeKeywordSpan">shutdown</span>([options], callback)

Use this method to gracefully shut down the agent.  When called with
`options.collectPendingData` set to true, the agent will send any pending data to
the New Relic servers before shutting down.  This is useful when you want to shut down
the Node process and make sure that all transactions and/or errors are captured by
New Relic.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.system_info" id="apidoc.module.newrelic.system_info">module newrelic.system_info</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.system_info.system_info" id="apidoc.element.newrelic.system_info.system_info">
        function <span class="apidocSignatureSpan">newrelic.</span>system_info
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchSystemInfo(agent, callback) {
  var config = agent.config
  var systemInfo = {
    processorArch: os.arch()
  }

  var utilizationConfig = {}
  if (config.utilization) {
    var configProcessors = config.utilization.logical_processors
    var configRam = config.utilization.total_ram_mib
    var configHostname = config.utilization.billing_hostname

    if (configProcessors) {
      var parsedConfigProcessors = parseFloat(configProcessors, 10)
      if (!isNaN(parsedConfigProcessors) &#x26;&#x26; isInteger(parsedConfigProcessors)) {
        utilizationConfig.logical_processors = parsedConfigProcessors
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.logical_processors, expected a number&#x27;,
          configProcessors
        )
      }
    }

    if (configRam) {
      var parsedConfigRam = parseFloat(configRam, 10)
      if (!isNaN(parsedConfigRam) &#x26;&#x26; isInteger(parsedConfigRam)) {
        utilizationConfig.total_ram_mib = parsedConfigRam
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.total_ram_mib, expected a number&#x27;,
          configRam
        )
      }
    }

    if (configHostname) {
      if (typeof configHostname === &#x27;string&#x27;) {
        utilizationConfig.hostname = configHostname
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.Hostname, expected a string&#x27;,
          configHostname
        )
      }
    }

    if (Object.keys(utilizationConfig).length &#x3e; 0) {
      systemInfo.config = utilizationConfig
    }
  }

  var tasksDone = 0
  var numTasks = 5
  function finishedResponse() {
    if (++tasksDone === numTasks) return callback(systemInfo)
  }

  module.exports._getProcessorStats(function getProcessCB(processorStats) {
    systemInfo.packages = processorStats.packages
    systemInfo.logicalProcessors = processorStats.logical
    systemInfo.cores = processorStats.cores
    finishedResponse()
  })
  module.exports._getMemoryStats(function getMemCB(memory) {
    systemInfo.memory = memory
    finishedResponse()
  })
  getKernelVersion(function getVersionCB(kernelVersion) {
    systemInfo.kernelVersion = kernelVersion
    finishedResponse()
  })
  module.exports._getDockerContainerId(agent, function getContainerId(containerId) {
    if (containerId) {
      systemInfo.docker = {
        id: containerId
      }
    }
    finishedResponse()
  })
  fetchAWSInfo(agent, function getAWSInfo(aws) {
    systemInfo.aws = aws
    finishedResponse()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.system_info._getDockerContainerId" id="apidoc.element.newrelic.system_info._getDockerContainerId">
        function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getDockerContainerId
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDockerContainerId(agent, callback) {
  if (!platform.match(/linux/i)) {
    logger.debug(&#x27;Platform is not a flavor of linux, omitting docker info&#x27;)
    callback(null)
  } else {
    readProc(&#x27;/proc/self/cgroup&#x27;, function getCGroup(data) {
      if (!data) callback(null)
      else callback(parseDockerInfo(agent, data))
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  systemInfo.memory = memory
  finishedResponse()
})
getKernelVersion(function getVersionCB(kernelVersion) {
  systemInfo.kernelVersion = kernelVersion
  finishedResponse()
})
module.exports.<span class="apidocCodeKeywordSpan">_getDockerContainerId</span>(agent, function getContainerId(containerId) {
  if (containerId) {
    systemInfo.docker = {
      id: containerId
    }
  }
  finishedResponse()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.system_info._getMemoryStats" id="apidoc.element.newrelic.system_info._getMemoryStats">
        function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getMemoryStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMemoryStats(callback) {
  if (platform.match(/darwin/i)) {
    getSysctlValue([&#x27;hw.memsize&#x27;], function getMem(memory) {
      callback(parseInt(memory, 10) / (1024 * 1024))
    })
  } else if (platform.match(/bsd/i)) {
    getSysctlValue([&#x27;hw.realmem&#x27;], function getMem(memory) {
      callback(parseInt(memory, 10) / (1024 * 1024))
    })
  } else if (platform.match(/linux/i)) {
    readProc(&#x27;/proc/meminfo&#x27;, function parseProc(data) {
      callback(parseMemInfo(data))
    })
  } else {
    logger.debug(&#x27;Unknown platform: &#x27; + platform + &#x27;, could not retrieve memory info&#x27;)
    callback(null)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports._getProcessorStats(function getProcessCB(processorStats) {
  systemInfo.packages = processorStats.packages
  systemInfo.logicalProcessors = processorStats.logical
  systemInfo.cores = processorStats.cores
  finishedResponse()
})
module.exports.<span class="apidocCodeKeywordSpan">_getMemoryStats</span>(function getMemCB(memory) {
  systemInfo.memory = memory
  finishedResponse()
})
getKernelVersion(function getVersionCB(kernelVersion) {
  systemInfo.kernelVersion = kernelVersion
  finishedResponse()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.system_info._getProcessorStats" id="apidoc.element.newrelic.system_info._getProcessorStats">
        function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getProcessorStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getProcessorStats(callback) {
  var processorStats = {
    logical: null,
    cores: null,
    packages: null
  }

  if (platform.match(/darwin/i)) {
    getSysctlValue([&#x27;hw.packages&#x27;], function getPackages(packages) {
      getSysctlValue([&#x27;hw.physicalcpu_max&#x27;, &#x27;hw.physicalcpu&#x27;],
      function getCores(cores) {
        getSysctlValue([&#x27;hw.logicalcpu_max&#x27;, &#x27;hw.logicalcpu&#x27;, &#x27;hw.ncpu&#x27;],
        function getLogicalCpu(logical) {
          processorStats.logical = parseFloat(logical, 10)
          processorStats.cores = parseFloat(cores, 10)
          processorStats.packages = parseFloat(packages, 10)

          for (var key in processorStats) {
            if (!processorStats[key] || !isInteger(processorStats[key])) {
              processorStats[key] = null
            }
          }

          callback(processorStats)
        })
      })
    })
  } else if (platform.match(/bsd/i)) {
    getSysctlValue([&#x27;hw.ncpu&#x27;], function getLogicalCpu(logical) {
      processorStats.logical = logical
      callback(processorStats)
    })
  } else if (platform.match(/linux/i)) {
    readProc(&#x27;/proc/cpuinfo&#x27;, function parseProc(data) {
      callback(parseCpuInfo(data))
    })
  } else {
    logger.debug(&#x27;Unknown platform: &#x27; + platform + &#x27;, could not retrieve processor info&#x27;)
    callback(processorStats)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var tasksDone = 0
var numTasks = 5
function finishedResponse() {
  if (++tasksDone === numTasks) return callback(systemInfo)
}

module.exports.<span class="apidocCodeKeywordSpan">_getProcessorStats</span>(function getProcessCB(processorStats) {
  systemInfo.packages = processorStats.packages
  systemInfo.logicalProcessors = processorStats.logical
  systemInfo.cores = processorStats.cores
  finishedResponse()
})
module.exports._getMemoryStats(function getMemCB(memory) {
  systemInfo.memory = memory
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.timer" id="apidoc.module.newrelic.timer">module newrelic.timer</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.timer.timer" id="apidoc.element.newrelic.timer.timer">
        function <span class="apidocSignatureSpan">newrelic.</span>timer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timer() {
  this.state = PENDING
  this.touched = false
  this.duration = null
  this.hrDuration = null
  this.hrstart = null
  this.durationInMillis = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.timer.prototype" id="apidoc.module.newrelic.timer.prototype">module newrelic.timer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.begin" id="apidoc.element.newrelic.timer.prototype.begin">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>begin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function begin() {
  if (this.state &#x3e; PENDING) return

  this.start = Date.now()
  // need to put a guard on this for compatibility with Node &#x3c; 0.8
  if (process.hrtime) this.hrstart = process.hrtime()
  this.state = RUNNING
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
}

function checkEvents(agent) {
return function eventSampler() {
  var timer = new Timer()
  timer.<span class="apidocCodeKeywordSpan">begin</span>()
  setTimeout(recordQueueTime.bind(null, agent, timer), 0)
}
}

function getCpuSample(lastSample) {
try {
  return process.cpuUsage(lastSample)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.end" id="apidoc.element.newrelic.timer.prototype.end">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end() {
  if (this.state &#x3e; RUNNING) return
  if (this.state === PENDING) this.begin()
  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
  this.touched = true
  this.duration = Date.now() - this.start
  this.state = STOPPED
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tracer = this.agent.tracer
var tx = tracer.getTransaction()

if (tx) {
  if (tx.webSegment) {
    tx.setName(tx.url, 0)
    tx.webSegment.markAsWeb(tx.url)
    tx.webSegment.<span class="apidocCodeKeywordSpan">end</span>()
  } else if (tx.bgSegment) {
    tx.bgSegment.end()
  }
  logger.debug(&#x27;ending transaction with id: %s and name: %s&#x27;, tx.id, tx.name)
  tx.end()
} else {
  logger.debug(&#x27;endTransaction() called while not in a transaction.&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.endsAfter" id="apidoc.element.newrelic.timer.prototype.endsAfter">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>endsAfter
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(other) {
  return (this.getDurationInMillis() + this.start) &#x3e;
    (other.getDurationInMillis() + other.start)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Helper to set the end of the root timer to this segment&#x27;s root if it is later
 * in time.
 */
TraceSegment.prototype._updateRootTimer = function _updateRootTimer() {
var root = this.transaction.trace.root
if (this.timer.<span class="apidocCodeKeywordSpan">endsAfter</span>(root.timer)) {
  var newDuration = (
    this.timer.start +
    this.getDurationInMillis() -
    root.timer.start
  )
  root.overwriteDurationInMillis(newDuration)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.getDurationInMillis" id="apidoc.element.newrelic.timer.prototype.getDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>getDurationInMillis
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDurationInMillis() {
  if (this.state === PENDING) return 0

  // only set by setDurationInMillis
  if (this.durationInMillis !== null &#x26;&#x26; this.durationInMillis &#x3e;= 0) {
    return this.durationInMillis
  }

  // prioritize .end() and .touch()
  if (this.hrDuration) {
    return hrToMillis(this.hrDuration)
  }

  if (this.duration) {
    return this.duration
  }

  if (process.hrtime) {
    return hrToMillis(process.hrtime(this.hrstart))
  }

  return Date.now() - this.start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* If we&#x27;re in an unnamed transaction, add a friendly warning this is to
 * avoid people going crazy, trying to figure out why browser monitoring is
 * not working when they&#x27;re missing a transaction name.
 */
if (!name) return _gracefail(3)

var time = trans.timer.<span class="apidocCodeKeywordSpan">getDurationInMillis</span>()

/*
 * Only the first 13 chars of the license should be used for hashing with
 * the transaction name.
 */
var key = config.license_key.substr(0, 13)
var appid = config.application_id
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.hasEnd" id="apidoc.element.newrelic.timer.prototype.hasEnd">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>hasEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasEnd() {
  return !!this.hrDuration
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.isActive" id="apidoc.element.newrelic.timer.prototype.isActive">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>isActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isActive() {
  return this.state &#x3c; STOPPED
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var segment = null
if (!parent) {
  return handleError.apply(this, arguments)
}

var transaction = parent.transaction

if (!transaction.<span class="apidocCodeKeywordSpan">isActive</span>()) {
  return handleError.apply(this, arguments)
}

var transactionInfo = getTransactionInfo(transaction)

if (agent.config.feature_flag.express_segments) {
  var handlerName = (this.handle.name || &#x27;anonymous&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.isRunning" id="apidoc.element.newrelic.timer.prototype.isRunning">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>isRunning
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRunning() {
  return this.state === RUNNING
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.overwriteDurationInMillis" id="apidoc.element.newrelic.timer.prototype.overwriteDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>overwriteDurationInMillis
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function overwriteDurationInMillis(duration) {
  this.touched = true
  this.durationInMillis = duration
  this.state = STOPPED
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.probe(&#x27;Touched&#x27;)
  this.timer.touch()
  this._updateRootTimer()
}

TraceSegment.prototype.overwriteDurationInMillis = overwriteDurationInMillis
function overwriteDurationInMillis(duration, start) {
  this.timer.<span class="apidocCodeKeywordSpan">overwriteDurationInMillis</span>(duration, start)
}


TraceSegment.prototype.start = function start() {
  this.timer.begin()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.setDurationInMillis" id="apidoc.element.newrelic.timer.prototype.setDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>setDurationInMillis
        <span class="apidocSignatureSpan">(duration, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setDurationInMillis(duration, start) {
  if (this.state &#x3e; RUNNING) return
  if (this.state === PENDING)
  if (!start &#x26;&#x26; start !== 0) this.begin()

  this.state = STOPPED
  this.durationInMillis = duration

  // this assignment is incorrect, process.hrtime doesn&#x27;t time from epoch, which
  // is the assumption being made here.  since hrstart isn&#x27;t used
  // anywhere except to calculate duration, and we are setting duration
  // this is fine.
  this.hrstart = [Math.floor(start / 1e3), start % 1e3 * 1e6]
  this.start = start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Set the duration of the segment explicitly.
 *
 * @param {Number} duration Duration in milliseconds.
 */
TraceSegment.prototype.setDurationInMillis = setDurationInMillis

function setDurationInMillis(duration, start) {
  this.timer.<span class="apidocCodeKeywordSpan">setDurationInMillis</span>(duration, start)
}

TraceSegment.prototype.getDurationInMillis = function getDurationInMillis() {
  return this.timer.getDurationInMillis()
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.softEnd" id="apidoc.element.newrelic.timer.prototype.softEnd">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>softEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function softEnd() {
  if (this.state &#x3e; RUNNING) return false
  if (this.state === PENDING) this.begin()

  this.state = STOPPED

  if (this.touched) return false
  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
  this.touched = true
  this.duration = Date.now() - this.start
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.startedRelativeTo" id="apidoc.element.newrelic.timer.prototype.startedRelativeTo">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>startedRelativeTo
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startedRelativeTo(other) {
  if (this.hrstart &#x26;&#x26; other.hrstart &#x26;&#x26; process.hrtime) {
    var s = this.hrstart[0] - other.hrstart[0]
    var ns = this.hrstart[1] - other.hrstart[1]


    return hrToMillis([s, ns])
  }

  return this.start - other.start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var segment = segmentsToProcess.pop()

if (!segment.parameters.nr_exclusive_duration_millis) {
  segment.parameters.nr_exclusive_duration_millis =
    segment.getExclusiveDurationInMillis()
}

var start = segment.timer.<span class="apidocCodeKeywordSpan">startedRelativeTo</span>(segment.transaction.trace.root.timer)
var duration = segment.getDurationInMillis()

var segmentChildren = segment.getCollectedChildren()

var serializedSegment = [
  start,
  start + duration,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.toRange" id="apidoc.element.newrelic.timer.prototype.toRange">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>toRange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toRange() {
  return [this.start, this.start + this.getDurationInMillis()]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
TraceSegment.prototype.getExclusiveDurationInMillis = getExclusiveDurationInMillis

function getExclusiveDurationInMillis() {
if (this._exclusiveDuration) return this._exclusiveDuration

var total = this.getDurationInMillis()
var end = this.timer.<span class="apidocCodeKeywordSpan">toRange</span>()[1]

if (this.children.length &#x3e; 0) {
  // convert the list of start, duration pairs to start, end pairs
  total -= sumChildren(this._getChildPairs(end), end)
}

return total
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.touch" id="apidoc.element.newrelic.timer.prototype.touch">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function touch() {
  this.touched = true
  if (this.state &#x3e; RUNNING) return
  if (this.state === PENDING) this.begin()

  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
  this.duration = Date.now() - this.start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.state === PENDING) return 0

// only set by setDurationInMillis
if (this.durationInMillis !== null &#x26;&#x26; this.durationInMillis &#x3e;= 0) {
  return this.durationInMillis
}

// prioritize .end() and .<span class="apidocCodeKeywordSpan">touch</span>()
if (this.hrDuration) {
  return hrToMillis(this.hrDuration)
}

if (this.duration) {
  return this.duration
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.tracer" id="apidoc.module.newrelic.tracer">module newrelic.tracer</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.tracer.tracer" id="apidoc.element.newrelic.tracer.tracer">
        function <span class="apidocSignatureSpan">newrelic.</span>tracer
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryTracer(config) {
  if (!(this instanceof QueryTracer)) {
    return new QueryTracer(config)
  }
  this.samples = {}
  this.config = config
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.tracer.prototype" id="apidoc.module.newrelic.tracer.prototype">module newrelic.tracer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.tracer.prototype.addQuery" id="apidoc.element.newrelic.tracer.prototype.addQuery">
        function <span class="apidocSignatureSpan">newrelic.tracer.prototype.</span>addQuery
        <span class="apidocSignatureSpan">(segment, type, query, trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addQuery(segment, type, query, trace) {
  var duration = segment.getDurationInMillis()

  if (duration &#x3c; this.config.transaction_tracer.explain_threshold) return

  var slowQuery = new SlowQuery(segment, type, query, trace)

  switch (this.config.transaction_tracer.record_sql) {
    case &#x27;raw&#x27;:
      logger.info(&#x27;recording raw sql&#x27;)
      segment.parameters.sql = slowQuery.query
      break
    case &#x27;obfuscated&#x27;:
      logger.info(&#x27;recording obfuscated sql&#x27;)
      segment.parameters.sql_obfuscated = slowQuery.obfuscated
      break
    default:
      logger.info(
        &#x27;not collecting slow-query because transaction_tracer.record_sql was set to %s&#x27;,
        this.config.transaction_tracer.record_sql
      )
      return
  }
  segment.parameters.backtrace = slowQuery.trace

  if (!this.config.slow_sql.enabled) return

  if (this.samples[slowQuery.normalized]) {
    return this.samples[slowQuery.normalized].aggregate(slowQuery)
  }

  this.samples[slowQuery.normalized] = new QuerySample(this, slowQuery)

  if (Object.keys(this.samples).length &#x3e; this.config.slow_sql.max_samples) {
    this.removeShortest()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      segment.parameters.hasOwnProperty(&#x27;port_path_or_id&#x27;)) {
    var instanceName = DB.INSTANCE + &#x27;/&#x27; + thisTypeSlash + segment.parameters.host +
      &#x27;/&#x27; + segment.parameters.port_path_or_id
    transaction.measure(instanceName, null, duration, exclusive)
  }

  if (this.raw) {
    transaction.agent.queries.<span class="apidocCodeKeywordSpan">addQuery</span>(
      segment,
      this.type.toLowerCase(),
      this.raw,
      this.trace
    )
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.tracer.prototype.merge" id="apidoc.element.newrelic.tracer.prototype.merge">
        function <span class="apidocSignatureSpan">newrelic.tracer.prototype.</span>merge
        <span class="apidocSignatureSpan">(tracer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(tracer) {
  var keys = Object.keys(tracer.samples)

  for (var i = 0, len = keys.length; i &#x3c; len; ++i) {
    if (this.samples[keys[i]]) {
      this.samples[keys[i]].merge(tracer.samples[keys[i]])
    } else {
      this.samples[keys[i]] = tracer.samples[keys[i]]
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof value.totalExclusive === &#x27;number&#x27;) {
  stats.totalExclusive = value.totalExclusive
} else {
  stats.totalExclusive = value.total
}

metric.<span class="apidocCodeKeywordSpan">merge</span>(stats)
}

API.prototype.incrementMetric = function incrementMetric(name, value) {
var metric = this.agent.metrics.getOrCreateMetric(
  NAMES.SUPPORTABILITY.API + &#x27;/incrementMetric&#x27;
)
metric.incrementCallCount()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.tracer.prototype.prepareJSON" id="apidoc.element.newrelic.tracer.prototype.prepareJSON">
        function <span class="apidocSignatureSpan">newrelic.tracer.prototype.</span>prepareJSON
        <span class="apidocSignatureSpan">(done)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prepareJSON(done) {
  var keys = Object.keys(this.samples)
  var remaining = keys.length
  var data = []

  if (!remaining) return done(null, data)

  for (var i = 0; i &#x3c; keys.length; ++i) {
    this.samples[keys[i]].prepareJSON(collect)
  }

  function collect(err, json) {
    if (err) {
      done(err)
      // turn callback into a noop so it can&#x27;t be called more than once
      done = noop
      return
    }

    data.push(json)
    if (!--remaining) done(null, data)
  }

  function noop() {}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  if (Object.keys(queries.samples).length &#x3c; 1) {
logger.debug(&#x27;No queries to send.&#x27;)
return process.nextTick(callback)
  }

  queries.<span class="apidocCodeKeywordSpan">prepareJSON</span>(function gotJSON(err, data) {
if (err) {
  this.queries.merge(queries)
  logger.debug(&#x27;Error while serializing query data: %s&#x27;, err.message)
  return callback(err)
}

agent.collector.queryData([data], function handleResponse(error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.tracer.prototype.removeShortest" id="apidoc.element.newrelic.tracer.prototype.removeShortest">
        function <span class="apidocSignatureSpan">newrelic.tracer.prototype.</span>removeShortest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeShortest() {
  var keys = Object.keys(this.samples)
  var shortest


  for (var i = 0, len = keys.length; i &#x3c; len; ++i) {
    var sample = this.samples[keys[i]].trace
    if (!shortest || shortest.duration &#x3e; sample.duration) {
      shortest = sample
    }
  }

  delete this.samples[shortest.normalized]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.samples[slowQuery.normalized]) {
  return this.samples[slowQuery.normalized].aggregate(slowQuery)
}

this.samples[slowQuery.normalized] = new QuerySample(this, slowQuery)

if (Object.keys(this.samples).length &#x3e; this.config.slow_sql.max_samples) {
  this.<span class="apidocCodeKeywordSpan">removeShortest</span>()
}
}

QueryTracer.prototype.prepareJSON = function prepareJSON(done) {
var keys = Object.keys(this.samples)
var remaining = keys.length
var data = []
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.tx_segment" id="apidoc.module.newrelic.tx_segment">module newrelic.tx_segment</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.tx_segment.tx_segment" id="apidoc.element.newrelic.tx_segment.tx_segment">
        function <span class="apidocSignatureSpan">newrelic.</span>tx_segment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TxSegmentNormalizer() {
  this.terms = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.tx_segment.prototype" id="apidoc.module.newrelic.tx_segment.prototype">module newrelic.tx_segment.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.tx_segment.prototype.load" id="apidoc.element.newrelic.tx_segment.prototype.load">
        function <span class="apidocSignatureSpan">newrelic.tx_segment.prototype.</span>load
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function load(json) {
  if (Array.isArray(json)) {
    this.terms = filterRules(json)
  } else {
    logger.warn(
      &#x27;transaction_segment_terms was not an array got: %s (%s)&#x27;,
      typeof json,
      json
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.config.apdex_t,
    this.mapper,
    this.metricNameNormalizer
  )

  this.collector.metricData(payload, function cb_metricData(error, rules) {
    if (error) agent.metrics.merge(metrics)
    if (rules) agent.mapper.<span class="apidocCodeKeywordSpan">load</span>(rules)

    callback(error)
  })
} else {
  process.nextTick(function cb_nextTick() {
    callback(new Error(&#x22;not connected to New Relic (metrics will be held)&#x22;))
  })
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.tx_segment.prototype.normalize" id="apidoc.element.newrelic.tx_segment.prototype.normalize">
        function <span class="apidocSignatureSpan">newrelic.tx_segment.prototype.</span>normalize
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalize(path) {
  var currentTerm
  var prefix
  for (var i = 0; i &#x3c; this.terms.length; i++) {
    currentTerm = this.terms[i]
    prefix = currentTerm.prefix
    if (path.lastIndexOf(prefix, 0) === -1) {
      continue
    }
    var fragment = path.slice(prefix.length)
    var parts = fragment.split(&#x27;/&#x27;)
    var result = []
    var prev

    var segment
    for (var j = 0; j &#x3c; parts.length; j++) {
      segment = parts[j]

      if (segment === &#x27;&#x27; &#x26;&#x26; j + 1 === parts.length) break

      if (currentTerm.terms.indexOf(segment) === -1) {
        if (prev === &#x27;*&#x27;) continue
        result.push(prev = &#x27;*&#x27;)
      } else {
        result.push(prev = segment)
      }
    }
    logger.trace(&#x27;Normalizing %s because of rule: %s&#x27;, path, currentTerm)
    return {
      matched: true, // To match MetricNormalizer
      ignore: false, // ^^
      value: prefix + result.join(&#x27;/&#x27;)
    }
  }

  return {
    matched: false, // To match MetricNormalizer
    ignore: false,  // ^^
    value: path
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.uninstrumented" id="apidoc.module.newrelic.uninstrumented">module newrelic.uninstrumented</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.uninstrumented.check" id="apidoc.element.newrelic.uninstrumented.check">
        function <span class="apidocSignatureSpan">newrelic.uninstrumented.</span>check
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check() {
  for (var filename in require.cache) {
    if (!require.cache.hasOwnProperty(filename)) {
      continue
    }
    var name = moduleNameFromFilename(filename)

    if (INSTRUMENTATIONS.indexOf(name) !== -1) {
      uninstrumented.push({name: name, filename: filename})
    }
  }

  logUninstrumented()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// just to make clear what&#x27;s going on
var TO_MILLIS = 1e3
var FROM_MILLIS = 1e-3

// Check for already loaded modules and warn about them. This must be executed
// only once, at the first require of this file, or else we have problems in
// unit tests.
uninstrumented.<span class="apidocCodeKeywordSpan">check</span>()

/**
* There&#x27;s a lot of stuff in this constructor, due to Agent acting as the
* orchestrator for New Relic within instrumented applications.
*
* This constructor can throw if, for some reason, the configuration isn&#x27;t
* available. Don&#x27;t try to recover here, because without configuration the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.uninstrumented.createMetrics" id="apidoc.element.newrelic.uninstrumented.createMetrics">
        function <span class="apidocSignatureSpan">newrelic.uninstrumented.</span>createMetrics
        <span class="apidocSignatureSpan">(metrics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMetrics(metrics) {
  if (uninstrumented.length &#x3e; 0) {
    metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.UNINSTRUMENTED).incrementCallCount()
  }

  uninstrumented.forEach(function addMetrics(module) {
    metrics.getOrCreateMetric(
      NAMES.SUPPORTABILITY.UNINSTRUMENTED + &#x27;/&#x27; + module.name
    ).incrementCallCount()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (this.config.debug.supportability) {
  this.metrics.merge(this.config.debug.supportability)
}

// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.<span class="apidocCodeKeywordSpan">createMetrics</span>(this.metrics)

this._processCustomEvents()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.toJSON().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.urltils" id="apidoc.module.newrelic.urltils">module newrelic.urltils</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.urltils.copyParameters" id="apidoc.element.newrelic.urltils.copyParameters">
        function <span class="apidocSignatureSpan">newrelic.urltils.</span>copyParameters
        <span class="apidocSignatureSpan">(config, source, destination)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyParameters(config, source, destination) {
  if (!(config &#x26;&#x26; config.capture_params &#x26;&#x26; source &#x26;&#x26; destination)) return

  var keys = Object.keys(source)
  for (var i = 0; i &#x3c; keys.length; i++) {
    var key = keys[i]
    if (config.ignored_params.indexOf(key) === -1 &#x26;&#x26; !(key in destination)) {
      destination[key] = source[key]
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               this.handle.stack != null
var isRoute = this.route != null

if (req &#x26;&#x26; (isRoute || isRouter)) {
  if (req.params) {
    // Express 4.3.0 changed where params live. On newer versions of Express
    // params should be populated, on older it shouldn&#x27;t be.
    urltils.<span class="apidocCodeKeywordSpan">copyParameters</span>(
      transaction.agent.config,
      req.params,
      transaction.webSegment.parameters
    )
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.urltils.isError" id="apidoc.element.newrelic.urltils.isError">
        function <span class="apidocSignatureSpan">newrelic.urltils.</span>isError
        <span class="apidocSignatureSpan">(config, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isError(config, code) {
  return code &#x3e;= 400 &#x26;&#x26; !isIgnoredStatusCodeForErrors(config, code)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (this._collect(transaction, exception[0], exception[1], exception[2])) {
      collectedErrors++
    }
  }
}

var hasExceptions = transaction.exceptions.length &#x3e; 0
var isErroredTransaction = urltils.<span class="apidocCodeKeywordSpan">isError</span>(this.config, transaction.statusCode)
var isIgnoredErrorStatusCode = urltils.isIgnoredError(this.config,
    transaction.statusCode)

// collect other exceptions only if status code is not ignored
if (hasExceptions &#x26;&#x26; !isIgnoredErrorStatusCode) {
  for (i = 0; i &#x3c; transaction.exceptions.length; i++) {
    exception = transaction.exceptions[i]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.urltils.isIgnoredError" id="apidoc.element.newrelic.urltils.isIgnoredError">
        function <span class="apidocSignatureSpan">newrelic.urltils.</span>isIgnoredError
        <span class="apidocSignatureSpan">(config, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIgnoredError(config, code) {
  return code &#x3e;= 400 &#x26;&#x26; isIgnoredStatusCodeForErrors(config, code)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      collectedErrors++
    }
  }
}

var hasExceptions = transaction.exceptions.length &#x3e; 0
var isErroredTransaction = urltils.isError(this.config, transaction.statusCode)
var isIgnoredErrorStatusCode = urltils.<span class="apidocCodeKeywordSpan">isIgnoredError</span>(this.config,
    transaction.statusCode)

// collect other exceptions only if status code is not ignored
if (hasExceptions &#x26;&#x26; !isIgnoredErrorStatusCode) {
  for (i = 0; i &#x3c; transaction.exceptions.length; i++) {
    exception = transaction.exceptions[i]
    if (this._collect(transaction, exception[0], exception[1], exception[2])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.urltils.isLocalhost" id="apidoc.element.newrelic.urltils.isLocalhost">
        function <span class="apidocSignatureSpan">newrelic.urltils.</span>isLocalhost
        <span class="apidocSignatureSpan">(host)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLocahost(host) {
  return LOCALHOST_NAMES.hasOwnProperty(host)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    typeof database === &#x27;number&#x27; ? database : (database || INSTANCE_UNKNOWN)
}

// Add instance information if enabled.
if (dsTracerConf.instance_reporting.enabled) {
  // Determine appropriate defaults for host and port.
  port = port || INSTANCE_UNKNOWN
  if (host &#x26;&#x26; urltils.<span class="apidocCodeKeywordSpan">isLocalhost</span>(host)) {
    host = config.getHostnameSafe(host)
  }
  if (!host || host === &#x27;UNKNOWN_BOX&#x27;) { // Config&#x27;s default name of a host.
    host = INSTANCE_UNKNOWN
  }
  this.parameters.host = host
  this.parameters.port_path_or_id = String(port)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.urltils.overwriteParameters" id="apidoc.element.newrelic.urltils.overwriteParameters">
        function <span class="apidocSignatureSpan">newrelic.urltils.</span>overwriteParameters
        <span class="apidocSignatureSpan">(config, source, destination)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function overwriteParameters(config, source, destination) {
  if (!(config &#x26;&#x26; source &#x26;&#x26; destination)) return

  var keys = Object.keys(source)
  for (var i = 0; i &#x3c; keys.length; i++) {
    var key = keys[i]
    if (config.ignored_params.indexOf(key) === -1) {
      destination[key] = source[key]
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.urltils.parseParameters" id="apidoc.element.newrelic.urltils.parseParameters">
        function <span class="apidocSignatureSpan">newrelic.urltils.</span>parseParameters
        <span class="apidocSignatureSpan">(requestURL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseParameters(requestURL) {
  var parsed = requestURL

  if (typeof requestURL === &#x27;string&#x27;) {
    parsed = url.parse(requestURL, true)
  }

  var parameters = {}

  if (parsed.query) {
    var keys = Object.keys(parsed.query)

    for (var i = 0, l = keys.length; i &#x3c; l; ++i) {
      var key = keys[i]
      if (parsed.query[key] === &#x27;&#x27; &#x26;&#x26; parsed.path.indexOf(key + &#x27;=&#x27;) === -1) {
        parameters[key] = true
      } else {
        parameters[key] = parsed.query[key]
      }
    }
  }

  return parameters
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
scrubAndParseParameters: function scrubAndParseParameters(requestURL) {
  if (typeof requestURL === &#x27;string&#x27;) {
    requestURL = url.parse(requestURL, true)
  }
  return {
    path: this.scrub(requestURL),
    parameters: this.<span class="apidocCodeKeywordSpan">parseParameters</span>(requestURL)
  }
},

/**
 * Copy a set of request parameters from one object to another, following
 * a few important rules:
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.urltils.scrub" id="apidoc.element.newrelic.urltils.scrub">
        function <span class="apidocSignatureSpan">newrelic.urltils.</span>scrub
        <span class="apidocSignatureSpan">(requestURL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scrub(requestURL) {
  if (typeof requestURL === &#x27;string&#x27;) {
    requestURL = url.parse(requestURL)
  }

  var path = requestURL.pathname

  if (path) {
    path = path.split(&#x27;;&#x27;)[0]

    if (path !== &#x27;/&#x27; &#x26;&#x26; path.charAt(path.length - 1) === &#x27;/&#x27;) {
      path = path.substring(0, path.length - 1)
    }
  } else {
    path = &#x27;/&#x27;
  }

  return path
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  parsed parameters at `.parameters`.
 */
scrubAndParseParameters: function scrubAndParseParameters(requestURL) {
  if (typeof requestURL === &#x27;string&#x27;) {
    requestURL = url.parse(requestURL, true)
  }
  return {
    path: this.<span class="apidocCodeKeywordSpan">scrub</span>(requestURL),
    parameters: this.parseParameters(requestURL)
  }
},

/**
 * Copy a set of request parameters from one object to another, following
 * a few important rules:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.urltils.scrubAndParseParameters" id="apidoc.element.newrelic.urltils.scrubAndParseParameters">
        function <span class="apidocSignatureSpan">newrelic.urltils.</span>scrubAndParseParameters
        <span class="apidocSignatureSpan">(requestURL)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scrubAndParseParameters(requestURL) {
  if (typeof requestURL === &#x27;string&#x27;) {
    requestURL = url.parse(requestURL, true)
  }
  return {
    path: this.scrub(requestURL),
    parameters: this.parseParameters(requestURL)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.util" id="apidoc.module.newrelic.util">module newrelic.util</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.util.extractDatabaseChangeFromUse" id="apidoc.element.newrelic.util.extractDatabaseChangeFromUse">
        function <span class="apidocSignatureSpan">newrelic.util.</span>extractDatabaseChangeFromUse
        <span class="apidocSignatureSpan">(sql)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractDatabaseChangeFromUse(sql) {
  // The character ranges for this were pulled from
  // http://dev.mysql.com/doc/refman/5.7/en/identifiers.html
  var match = /^\s*use[^\w`]+([\w$_\u0080-\uFFFF]+|`[^`]+`)[\s;]*$/i.exec(sql)
  return match &#x26;&#x26; match[1] || null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            databaseName
          )
        }
      } else {
        logger.trace(&#x27;No query config detected, not collecting db instance data&#x27;)
      }

      databaseName = dbutil.<span class="apidocCodeKeywordSpan">extractDatabaseChangeFromUse</span>(sqlString) || databaseName
    }

    return vargs
  }
}

function getVargs(args) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
