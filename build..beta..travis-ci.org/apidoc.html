<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/newrelic/node-newrelic"

    >newrelic (v1.38.2)</a>
</h1>
<h4>New Relic agent</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic">module newrelic</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent">
            function <span class="apidocSignatureSpan">newrelic.</span>agent
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api">
            function <span class="apidocSignatureSpan">newrelic.</span>api
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aws_info">
            function <span class="apidocSignatureSpan">newrelic.</span>aws_info
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config">
            function <span class="apidocSignatureSpan">newrelic.</span>config
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir">
            function <span class="apidocSignatureSpan">newrelic.</span>reservoir
            <span class="apidocSignatureSpan">(limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api">
            function <span class="apidocSignatureSpan">newrelic.</span>stub_api
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info">
            function <span class="apidocSignatureSpan">newrelic.</span>system_info
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer">
            function <span class="apidocSignatureSpan">newrelic.</span>timer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>agent.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>api.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>config.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>environment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>reservoir.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>sampler</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>shimmer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>stub_api.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>timer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.</span>uninstrumented</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.agent">module newrelic.agent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.agent">
            function <span class="apidocSignatureSpan">newrelic.</span>agent
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.super_">
            function <span class="apidocSignatureSpan">newrelic.agent.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.agent.prototype">module newrelic.agent.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._addEventFromTransaction">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_addEventFromTransaction
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._addIntrinsicAttrsFromTransaction">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_addIntrinsicAttrsFromTransaction
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._apdexTChange">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_apdexTChange
            <span class="apidocSignatureSpan">(apdexT)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._configChange">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_configChange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._enabledChange">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_enabledChange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._harvesterIntervalChange">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_harvesterIntervalChange
            <span class="apidocSignatureSpan">(interval, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._processCustomEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_processCustomEvents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._processErrorEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_processErrorEvents
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._restartHarvester">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_restartHarvester
            <span class="apidocSignatureSpan">(harvestSeconds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendCustomEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendCustomEvents
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendErrorEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendErrorEvents
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendErrors">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendErrors
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendEvents">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendEvents
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendMetrics">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendMetrics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendQueries">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendQueries
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._sendTrace">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendTrace
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._setupTracer">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_setupTracer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._startHarvester">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_startHarvester
            <span class="apidocSignatureSpan">(harvestSeconds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._stopHarvester">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_stopHarvester
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype._transactionFinished">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_transactionFinished
            <span class="apidocSignatureSpan">(transaction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.getTransaction">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>getTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.harvest">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>harvest
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.reconfigure">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>reconfigure
            <span class="apidocSignatureSpan">(configuration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.reset">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.setState">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>setState
            <span class="apidocSignatureSpan">(newState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.start">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>start
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.agent.prototype.stop">
            function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>stop
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.api">module newrelic.api</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.api">
            function <span class="apidocSignatureSpan">newrelic.</span>api
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.api.prototype">module newrelic.api.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.addCustomParameter">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addCustomParameter
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.addCustomParameters">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addCustomParameters
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.addIgnoringRule">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addIgnoringRule
            <span class="apidocSignatureSpan">(pattern)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.addNamingRule">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addNamingRule
            <span class="apidocSignatureSpan">(pattern, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.createBackgroundTransaction">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createBackgroundTransaction
            <span class="apidocSignatureSpan">(name, group, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.createTracer">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createTracer
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.createWebTransaction">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createWebTransaction
            <span class="apidocSignatureSpan">(url, handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.endTransaction">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>endTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.getBrowserTimingHeader">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>getBrowserTimingHeader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.incrementMetric">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>incrementMetric
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.noticeError">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>noticeError
            <span class="apidocSignatureSpan">(error, customParameters)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.recordCustomEvent">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>recordCustomEvent
            <span class="apidocSignatureSpan">(eventType, attributes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.recordMetric">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>recordMetric
            <span class="apidocSignatureSpan">(name, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.setControllerName">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setControllerName
            <span class="apidocSignatureSpan">(name, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.setIgnoreTransaction">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setIgnoreTransaction
            <span class="apidocSignatureSpan">(ignored)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.setTransactionName">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setTransactionName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.api.prototype.shutdown">
            function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>shutdown
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.aws_info">module newrelic.aws_info</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aws_info.aws_info">
            function <span class="apidocSignatureSpan">newrelic.</span>aws_info
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aws_info._awsQuery">
            function <span class="apidocSignatureSpan">newrelic.aws_info.</span>_awsQuery
            <span class="apidocSignatureSpan">(key, agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.aws_info.clearCache">
            function <span class="apidocSignatureSpan">newrelic.aws_info.</span>clearCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.config">module newrelic.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.config">
            function <span class="apidocSignatureSpan">newrelic.</span>config
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.getOrCreateInstance">
            function <span class="apidocSignatureSpan">newrelic.config.</span>getOrCreateInstance
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.initialize">
            function <span class="apidocSignatureSpan">newrelic.config.</span>initialize
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.super_">
            function <span class="apidocSignatureSpan">newrelic.config.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.config.prototype">module newrelic.config.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._alwaysUpdateIfChanged">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_alwaysUpdateIfChanged
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._applyHighSecurity">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_applyHighSecurity
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._canonicalize">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_canonicalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._emitIfSet">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_emitIfSet
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._fromEnvironment">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromEnvironment
            <span class="apidocSignatureSpan">(metadata, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._fromPassed">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromPassed
            <span class="apidocSignatureSpan">(external, internal, arbitrary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._fromServer">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromServer
            <span class="apidocSignatureSpan">(params, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._fromSpecial">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromSpecial
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._updateIfChanged">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateIfChanged
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._updateNestedIfChanged">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateNestedIfChanged
            <span class="apidocSignatureSpan">(remote, local, remoteKey, localKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype._updateNestedIfChangedRaw">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateNestedIfChangedRaw
            <span class="apidocSignatureSpan">( remote, local, remoteKey, localKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.applications">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>applications
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.clearDisplayHostCache">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>clearDisplayHostCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.clearHostnameCache">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>clearHostnameCache
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.getDisplayHost">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getDisplayHost
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.getHostnameSafe">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getHostnameSafe
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.getIPAddresses">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getIPAddresses
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.logDisabled">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logDisabled
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.logUnknown">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logUnknown
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.logUnsupported">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logUnsupported
            <span class="apidocSignatureSpan">(json, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.measureInternal">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>measureInternal
            <span class="apidocSignatureSpan">(suffix, duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.onConnect">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>onConnect
            <span class="apidocSignatureSpan">(json, recursion)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.publicSettings">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>publicSettings
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.setLogger">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>setLogger
            <span class="apidocSignatureSpan">(bootstrapped)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.config.prototype.validateFlags">
            function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>validateFlags
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.environment">module newrelic.environment</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.clearDispatcher">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>clearDispatcher
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.clearFramework">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>clearFramework
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.get">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.listPackages">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>listPackages
            <span class="apidocSignatureSpan">(root, packages)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.refresh">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>refresh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.setDispatcher">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>setDispatcher
            <span class="apidocSignatureSpan">(dispatcher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.setFramework">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>setFramework
            <span class="apidocSignatureSpan">(framework)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.environment.toJSON">
            function <span class="apidocSignatureSpan">newrelic.environment.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.reservoir">module newrelic.reservoir</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.reservoir">
            function <span class="apidocSignatureSpan">newrelic.</span>reservoir
            <span class="apidocSignatureSpan">(limit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.reservoir.prototype">module newrelic.reservoir.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.add">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>add
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.merge">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>merge
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.overflow">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>overflow
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.setLimit">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>setLimit
            <span class="apidocSignatureSpan">(newLimit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.reservoir.prototype.toArray">
            function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.sampler">module newrelic.sampler</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.checkEvents">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>checkEvents
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.sampleCpu">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleCpu
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.sampleGc">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleGc
            <span class="apidocSignatureSpan">(agent, nativeMetrics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.sampleLoop">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleLoop
            <span class="apidocSignatureSpan">(agent, nativeMetrics)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.sampleMemory">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleMemory
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.start">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>start
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.sampler.stop">
            function <span class="apidocSignatureSpan">newrelic.sampler.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">newrelic.sampler.</span>nativeMetrics</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">newrelic.sampler.</span>state</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.shimmer">module newrelic.shimmer</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">newrelic.shimmer.</span>debug</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.bootstrapInstrumentation">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>bootstrapInstrumentation
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.isWrapped">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>isWrapped
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.patchModule">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>patchModule
            <span class="apidocSignatureSpan">(agent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.reinstrument">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>reinstrument
            <span class="apidocSignatureSpan">(agent, modulePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.unpatchModule">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unpatchModule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.unwrapAll">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unwrapAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.unwrapMethod">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unwrapMethod
            <span class="apidocSignatureSpan">(nodule, noduleName, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.wrapDeprecated">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>wrapDeprecated
            <span class="apidocSignatureSpan">(nodule, noduleName, property, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.shimmer.wrapMethod">
            function <span class="apidocSignatureSpan">newrelic.shimmer.</span>wrapMethod
            <span class="apidocSignatureSpan">(nodule, noduleName, methods, wrapper)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.stub_api">module newrelic.stub_api</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.stub_api">
            function <span class="apidocSignatureSpan">newrelic.</span>stub_api
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.stub_api.prototype">module newrelic.stub_api.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.addCustomParameter">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addCustomParameter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.addCustomParameters">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addCustomParameters
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.addIgnoringRule">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addIgnoringRule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.addNamingRule">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addNamingRule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.createBackgroundTransaction">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createBackgroundTransaction
            <span class="apidocSignatureSpan">(name, group, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.createTracer">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createTracer
            <span class="apidocSignatureSpan">(name, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.createWebTransaction">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createWebTransaction
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.endTransaction">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>endTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.getBrowserTimingHeader">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>getBrowserTimingHeader
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.incrementMetric">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>incrementMetric
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.noticeError">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>noticeError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.recordCustomEvent">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>recordCustomEvent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.recordMetric">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>recordMetric
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.setControllerName">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setControllerName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.setIgnoreTransaction">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setIgnoreTransaction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.setTransactionName">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setTransactionName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.stub_api.prototype.shutdown">
            function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>shutdown
            <span class="apidocSignatureSpan">(options, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.system_info">module newrelic.system_info</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info.system_info">
            function <span class="apidocSignatureSpan">newrelic.</span>system_info
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info._getDockerContainerId">
            function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getDockerContainerId
            <span class="apidocSignatureSpan">(agent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info._getMemoryStats">
            function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getMemoryStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.system_info._getProcessorStats">
            function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getProcessorStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.timer">module newrelic.timer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.timer">
            function <span class="apidocSignatureSpan">newrelic.</span>timer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.timer.prototype">module newrelic.timer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.begin">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>begin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.end">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.endsAfter">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>endsAfter
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.getDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>getDurationInMillis
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.hasEnd">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>hasEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.isActive">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>isActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.isRunning">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>isRunning
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.overwriteDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>overwriteDurationInMillis
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.setDurationInMillis">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>setDurationInMillis
            <span class="apidocSignatureSpan">(duration, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.softEnd">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>softEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.startedRelativeTo">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>startedRelativeTo
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.toRange">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>toRange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.timer.prototype.touch">
            function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>touch
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.newrelic.uninstrumented">module newrelic.uninstrumented</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.uninstrumented.check">
            function <span class="apidocSignatureSpan">newrelic.uninstrumented.</span>check
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.newrelic.uninstrumented.createMetrics">
            function <span class="apidocSignatureSpan">newrelic.uninstrumented.</span>createMetrics
            <span class="apidocSignatureSpan">(metrics)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic" id="apidoc.module.newrelic">module newrelic</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.agent" id="apidoc.element.newrelic.agent">
        function <span class="apidocSignatureSpan">newrelic.</span>agent
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(config) {
  EventEmitter.call(this)

  if (!config) throw new Error(&#x22;Agent must be created with a configuration!&#x22;)

  // The agent base attributes which last throughout its lifetime.
  this._state = &#x27;stopped&#x27;
  this.config = config
  this.environment = require(&#x27;./environment&#x27;)
  this.version = this.config.version
  this.collector = new CollectorAPI(this)

  // Reset the agent to add all the sub-objects it needs. These object are the
  // ones that get re-created if the agent is told to restart from the collector.
  this.events = null
  this.customEvents = null
  this.errors = null
  this.mapper = null
  this.metricNameNormalizer = null
  this.metrics = null
  this.transactionNameNormalizer = null
  this.urlNormalizer = null
  this.txSegmentNormalizer = null
  this.userNormalizer = null
  this.reset()

  // Transaction tracing.
  this.tracer = this._setupTracer()
  this.traces = new TraceAggregator(this.config)

  // Query tracing.
  this.queries = new QueryTracer(this.config)

  // Set up all the configuration events the agent needs to listen for.
  var self = this
  this.config.on(&#x27;apdex_t&#x27;, this._apdexTChange.bind(this))
  this.config.on(&#x27;data_report_period&#x27;, this._harvesterIntervalChange.bind(this))
  this.config.on(&#x27;agent_enabled&#x27;, this._enabledChange.bind(this))
  this.config.on(&#x27;change&#x27;, this._configChange.bind(this))
  this.config.on(&#x27;metric_name_rules&#x27;, function updateMetricNameNormalizer() {
    self.metricNameNormalizer.load.apply(self.metricNameNormalizer, arguments)
  })
  this.config.on(&#x27;transaction_name_rules&#x27;, function updateTransactionNameNormalizer() {
    self.transactionNameNormalizer.load.apply(self.transactionNameNormalizer, arguments)
  })
  this.config.on(&#x27;url_rules&#x27;, function updateUrlNormalizer() {
    self.urlNormalizer.load.apply(self.urlNormalizer, arguments)
  })
  this.config.on(&#x27;transaction_segment_terms&#x27;, function updateSegmentNormalizer() {
    self.txSegmentNormalizer.load.apply(self.txSegmentNormalizer, arguments)
  })

  // Entity tracking metrics.
  this.totalActiveSegments = 0
  this.segmentsCreatedInHarvest = 0
  this.segmentsClearedInHarvest = 0
  this.activeTransactions = 0

  // Hidden class optimizations.
  this.harvesterHandle = null

  // Finally, add listeners for the agent&#x27;s own events.
  this.on(&#x27;transactionFinished&#x27;, this._transactionFinished.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api" id="apidoc.element.newrelic.api">
        function <span class="apidocSignatureSpan">newrelic.</span>api
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function API(agent) {
  this.agent = agent
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aws_info" id="apidoc.element.newrelic.aws_info">
        function <span class="apidocSignatureSpan">newrelic.</span>aws_info
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchAWSInfo(agent, callback) {
  if (!agent.config.utilization || !agent.config.utilization.detect_aws) {
    return callback(null)
  }

  if (resultDict) {
    return callback(resultDict)
  }

  var awsQuery = module.exports._awsQuery

  awsQuery(&#x27;instance-type&#x27;, agent, function getInstanceType(type) {
    if (!type) return callback(null)
    awsQuery(&#x27;instance-id&#x27;, agent, function getInstanceId(id) {
      if (!id) return callback(null)
      awsQuery(&#x27;placement/availability-zone&#x27;, agent, function getZone(zone) {
        if (!zone) return callback(null)
        resultDict = {
          type: type,
          id: id,
          zone: zone
        }
        return callback(resultDict)
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config" id="apidoc.element.newrelic.config">
        function <span class="apidocSignatureSpan">newrelic.</span>config
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(config) {
  EventEmitter.call(this)

  // 1. start by cloning the defaults
  try {
    var basis = JSON.parse(stringifySync(DEFAULT_CONFIG))
    Object.keys(basis).forEach(function cb_forEach(key) {
      this[key] = basis[key]
    }, this)
  } catch (err) {
    logger.warn(&#x27;Unable to clone the default config, %s: %s&#x27;, DEFAULT_CONFIG_PATH, err)
  }

  if (config &#x26;&#x26;
      (process.env[ENV_MAPPING.ssl] === &#x27;false&#x27; || config.ssl === false) &#x26;&#x26;
      process.env[ENV_MAPPING.port] === undefined &#x26;&#x26; config.port === undefined ) {
    config.port = 80
  }

  // 2. initialize undocumented, internal-only default values

  // feature flags are mostly private settings for gating unreleased features
  // flags are set in the feature_flags.js file
  this.feature_flag = feature_flag.prerelease

  // set by environment
  this.newrelic_home = null
  // set by configuration file loader
  this.config_file_path = null
  // set by collector on handshake
  this.run_id = null
  this.application_id = null
  this.web_transactions_apdex = {}
  this.cross_process_id = null
  this.encoding_key = null
  this.obfuscatedId = null
  this.trusted_account_ids = null

  // how frequently harvester runs
  this.data_report_period = 60

  // this value is arbitrary
  this.max_trace_segments = 900

  // feature level of this account
  this.product_level = 0
  // product-level related
  this.collect_traces = true
  this.collect_errors = true

  // override options for utilization stats
  this.utilization.logical_processors = null
  this.utilization.total_ram_mib = null
  this.utilization.billing_hostname = null

  this.browser_monitoring.loader = &#x27;rum&#x27;
  this.browser_monitoring.loader_version = &#x27;&#x27;

  // Settings to play nice with DLPs (see NODE-1044).
  this.compressed_content_encoding = &#x22;deflate&#x22;  // Deflate or gzip
  this.simple_compression = false               // Disables subcomponent compression
  this.put_for_data_send = false                // Changes http verb for harvest


  // 3. override defaults with values from the loaded / passed configuration
  this._fromPassed(config)

  // 3.5. special values (only Azure environment APP_POOL_ID for now)
  this._fromSpecial()

  // 4. override config with environment variables
  this._fromEnvironment()

  // 5. clean up anything that requires postprocessing
  this._canonicalize()

  // 6. put the version in the config
  this.version = require(&#x27;../package.json&#x27;).version

  // 7. apply high security overrides
  if (this.high_security === true) {
    this._applyHighSecurity()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir" id="apidoc.element.newrelic.reservoir">
        function <span class="apidocSignatureSpan">newrelic.</span>reservoir
        <span class="apidocSignatureSpan">(limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reservoir(limit) {
  this.limit = limit || 10
  this.seen = 0
  this._data = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api" id="apidoc.element.newrelic.stub_api">
        function <span class="apidocSignatureSpan">newrelic.</span>stub_api
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stub() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.system_info" id="apidoc.element.newrelic.system_info">
        function <span class="apidocSignatureSpan">newrelic.</span>system_info
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchSystemInfo(agent, callback) {
  var config = agent.config
  var systemInfo = {
    processorArch: os.arch()
  }

  var utilizationConfig = {}
  if (config.utilization) {
    var configProcessors = config.utilization.logical_processors
    var configRam = config.utilization.total_ram_mib
    var configHostname = config.utilization.billing_hostname

    if (configProcessors) {
      var parsedConfigProcessors = parseFloat(configProcessors, 10)
      if (!isNaN(parsedConfigProcessors) &#x26;&#x26; isInteger(parsedConfigProcessors)) {
        utilizationConfig.logical_processors = parsedConfigProcessors
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.logical_processors, expected a number&#x27;,
          configProcessors
        )
      }
    }

    if (configRam) {
      var parsedConfigRam = parseFloat(configRam, 10)
      if (!isNaN(parsedConfigRam) &#x26;&#x26; isInteger(parsedConfigRam)) {
        utilizationConfig.total_ram_mib = parsedConfigRam
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.total_ram_mib, expected a number&#x27;,
          configRam
        )
      }
    }

    if (configHostname) {
      if (typeof configHostname === &#x27;string&#x27;) {
        utilizationConfig.hostname = configHostname
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.Hostname, expected a string&#x27;,
          configHostname
        )
      }
    }

    if (Object.keys(utilizationConfig).length &#x3e; 0) {
      systemInfo.config = utilizationConfig
    }
  }

  var tasksDone = 0
  var numTasks = 5
  function finishedResponse() {
    if (++tasksDone === numTasks) return callback(systemInfo)
  }

  module.exports._getProcessorStats(function getProcessCB(processorStats) {
    systemInfo.packages = processorStats.packages
    systemInfo.logicalProcessors = processorStats.logical
    systemInfo.cores = processorStats.cores
    finishedResponse()
  })
  module.exports._getMemoryStats(function getMemCB(memory) {
    systemInfo.memory = memory
    finishedResponse()
  })
  getKernelVersion(function getVersionCB(kernelVersion) {
    systemInfo.kernelVersion = kernelVersion
    finishedResponse()
  })
  module.exports._getDockerContainerId(agent, function getContainerId(containerId) {
    if (containerId) {
      systemInfo.docker = {
        id: containerId
      }
    }
    finishedResponse()
  })
  fetchAWSInfo(agent, function getAWSInfo(aws) {
    systemInfo.aws = aws
    finishedResponse()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer" id="apidoc.element.newrelic.timer">
        function <span class="apidocSignatureSpan">newrelic.</span>timer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timer() {
  this.state = PENDING
  this.touched = false
  this.duration = null
  this.hrDuration = null
  this.hrstart = null
  this.durationInMillis = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.agent" id="apidoc.module.newrelic.agent">module newrelic.agent</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.agent.agent" id="apidoc.element.newrelic.agent.agent">
        function <span class="apidocSignatureSpan">newrelic.</span>agent
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(config) {
  EventEmitter.call(this)

  if (!config) throw new Error(&#x22;Agent must be created with a configuration!&#x22;)

  // The agent base attributes which last throughout its lifetime.
  this._state = &#x27;stopped&#x27;
  this.config = config
  this.environment = require(&#x27;./environment&#x27;)
  this.version = this.config.version
  this.collector = new CollectorAPI(this)

  // Reset the agent to add all the sub-objects it needs. These object are the
  // ones that get re-created if the agent is told to restart from the collector.
  this.events = null
  this.customEvents = null
  this.errors = null
  this.mapper = null
  this.metricNameNormalizer = null
  this.metrics = null
  this.transactionNameNormalizer = null
  this.urlNormalizer = null
  this.txSegmentNormalizer = null
  this.userNormalizer = null
  this.reset()

  // Transaction tracing.
  this.tracer = this._setupTracer()
  this.traces = new TraceAggregator(this.config)

  // Query tracing.
  this.queries = new QueryTracer(this.config)

  // Set up all the configuration events the agent needs to listen for.
  var self = this
  this.config.on(&#x27;apdex_t&#x27;, this._apdexTChange.bind(this))
  this.config.on(&#x27;data_report_period&#x27;, this._harvesterIntervalChange.bind(this))
  this.config.on(&#x27;agent_enabled&#x27;, this._enabledChange.bind(this))
  this.config.on(&#x27;change&#x27;, this._configChange.bind(this))
  this.config.on(&#x27;metric_name_rules&#x27;, function updateMetricNameNormalizer() {
    self.metricNameNormalizer.load.apply(self.metricNameNormalizer, arguments)
  })
  this.config.on(&#x27;transaction_name_rules&#x27;, function updateTransactionNameNormalizer() {
    self.transactionNameNormalizer.load.apply(self.transactionNameNormalizer, arguments)
  })
  this.config.on(&#x27;url_rules&#x27;, function updateUrlNormalizer() {
    self.urlNormalizer.load.apply(self.urlNormalizer, arguments)
  })
  this.config.on(&#x27;transaction_segment_terms&#x27;, function updateSegmentNormalizer() {
    self.txSegmentNormalizer.load.apply(self.txSegmentNormalizer, arguments)
  })

  // Entity tracking metrics.
  this.totalActiveSegments = 0
  this.segmentsCreatedInHarvest = 0
  this.segmentsClearedInHarvest = 0
  this.activeTransactions = 0

  // Hidden class optimizations.
  this.harvesterHandle = null

  // Finally, add listeners for the agent&#x27;s own events.
  this.on(&#x27;transactionFinished&#x27;, this._transactionFinished.bind(this))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.super_" id="apidoc.element.newrelic.agent.super_">
        function <span class="apidocSignatureSpan">newrelic.agent.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.agent.prototype" id="apidoc.module.newrelic.agent.prototype">module newrelic.agent.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._addEventFromTransaction" id="apidoc.element.newrelic.agent.prototype._addEventFromTransaction">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_addEventFromTransaction
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _addEventFromTransaction(transaction) {
  if (!this.config.transaction_events.enabled) return

  var intrinsicAttributes = this._addIntrinsicAttrsFromTransaction(transaction)
  var userAttributes = transaction.trace.custom
  var agentAttributes = transaction.trace.parameters

  var event = [
    intrinsicAttributes,
    userAttributes,
    agentAttributes
  ]

  this.events.add(event)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.metrics.merge(transaction.metrics)
  this.errors.onTransactionFinished(transaction, this.metrics)
  this.traces.add(transaction)

  var trace = transaction.trace
  trace.intrinsics = transaction.getIntrinsicAttributes()

  this.<span class="apidocCodeKeywordSpan">_addEventFromTransaction</span>(transaction)
} else if (transaction.forceIgnore === true) {
  logger.debug(&#x22;Explicitly ignoring %s.&#x22;, transaction.name)
} else {
  logger.debug(&#x22;Ignoring %s.&#x22;, transaction.name)
}

this.activeTransactions--
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._addIntrinsicAttrsFromTransaction" id="apidoc.element.newrelic.agent.prototype._addIntrinsicAttrsFromTransaction">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_addIntrinsicAttrsFromTransaction
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _addIntrinsicAttrsFromTransaction(transaction) {
  var intrinsicAttributes = {
    webDuration: transaction.timer.duration / 1000,
    timestamp: transaction.timer.start,
    name: transaction.name,
    duration: transaction.timer.duration / 1000,
    type: &#x27;Transaction&#x27;,
    error: transaction.hasErrors()
  }

  var metric = transaction.metrics.getMetric(NAMES.QUEUETIME)
  if (metric) {
    intrinsicAttributes.queueDuration = metric.total
  }

  metric = transaction.metrics.getMetric(NAMES.EXTERNAL.ALL)
  if (metric) {
    intrinsicAttributes.externalDuration = metric.total
    intrinsicAttributes.externalCallCount = metric.callCount
  }

  metric = transaction.metrics.getMetric(NAMES.DB.ALL)
  if (metric) {
    intrinsicAttributes.databaseDuration = metric.total
    intrinsicAttributes.databaseCallCount = metric.callCount
  }

  // FLAG: cat
  if (this.config.feature_flag.cat) {
    if (!transaction.invalidIncomingExternalTransaction &#x26;&#x26;
         (
           transaction.referringTransactionGuid ||
           transaction.includesOutboundRequests()
         )
       ) {
      intrinsicAttributes[&#x27;nr.guid&#x27;] = transaction.id
      intrinsicAttributes[&#x27;nr.tripId&#x27;] = transaction.tripId || transaction.id
      intrinsicAttributes[&#x27;nr.pathHash&#x27;] = hashes.calculatePathHash(
        this.config.applications()[0],
        transaction.name || transaction.nameState.getName(),
        transaction.referringPathHash
      )
      if (transaction.referringPathHash) {
        intrinsicAttributes[&#x27;nr.referringPathHash&#x27;] = transaction.referringPathHash
      }
      if (transaction.referringTransactionGuid) {
        var refId = transaction.referringTransactionGuid
        intrinsicAttributes[&#x27;nr.referringTransactionGuid&#x27;] = refId
      }
      var alternatePathHashes = transaction.alternatePathHashes()
      if (alternatePathHashes) {
        intrinsicAttributes[&#x27;nr.alternatePathHashes&#x27;] = alternatePathHashes
      }
      if (transaction.webSegment) {
        var apdex = (this.config.web_transactions_apdex[transaction.name] ||
                     this.config.apdex_t)
        var duration = transaction.webSegment.getDurationInMillis() / 1000
        intrinsicAttributes[&#x27;nr.apdexPerfZone&#x27;] = calculateApdexZone(duration, apdex)
      }
    }
  }

  if (transaction.syntheticsData) {
    intrinsicAttributes[&#x22;nr.syntheticsResourceId&#x22;] = transaction.syntheticsData.resourceId
    intrinsicAttributes[&#x22;nr.syntheticsJobId&#x22;] = transaction.syntheticsData.jobId
    intrinsicAttributes[&#x22;nr.syntheticsMonitorId&#x22;] = transaction.syntheticsData.monitorId
  }

  return intrinsicAttributes
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Agent.prototype._addEventFromTransaction = _addEventFromTransaction

function _addEventFromTransaction(transaction) {
if (!this.config.transaction_events.enabled) return

var intrinsicAttributes = this.<span class="apidocCodeKeywordSpan">_addIntrinsicAttrsFromTransaction</span>(transaction)
var userAttributes = transaction.trace.custom
var agentAttributes = transaction.trace.parameters

var event = [
  intrinsicAttributes,
  userAttributes,
  agentAttributes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._apdexTChange" id="apidoc.element.newrelic.agent.prototype._apdexTChange">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_apdexTChange
        <span class="apidocSignatureSpan">(apdexT)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _apdexTChange(apdexT) {
  logger.debug(&#x22;Apdex tolerating value changed to %s.&#x22;, apdexT)
  this.metrics.apdexT = apdexT
  if (this.config.debug.supportability) {
    this.config.debug.supportability.apdexT = apdexT
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._configChange" id="apidoc.element.newrelic.agent.prototype._configChange">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_configChange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _configChange() {
  this.collector.reportSettings()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._enabledChange" id="apidoc.element.newrelic.agent.prototype._enabledChange">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_enabledChange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _enabledChange() {
  if (this.config.agent_enabled === false) {
    logger.warn(&#x27;agent_enabled has been changed to false, stopping the agent.&#x27;)
    this.stop(function nop() {})
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._harvesterIntervalChange" id="apidoc.element.newrelic.agent.prototype._harvesterIntervalChange">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_harvesterIntervalChange
        <span class="apidocSignatureSpan">(interval, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _harvesterIntervalChange(interval, callback) {
  var agent = this

  // only change the setup if the harvester is currently running
  if (this.harvesterHandle) {
    // force a harvest now, to be safe
    this.harvest(function cb_harvest(error) {
      agent._restartHarvester(interval)
      if (callback) callback(error)
    })
  } else if (callback) {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._processCustomEvents" id="apidoc.element.newrelic.agent.prototype._processCustomEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_processCustomEvents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _processCustomEvents() {
  this.customEventsPool = this.customEvents.toArray()

  // Create the metrics so they are at least set to 0
  var dropped = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.DROPPED)
  var seen = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SEEN)
  var sent = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SENT)

  // Bail out if there are no events
  if (this.customEventsPool.length === 0) {
    return
  }

  if (this.config.custom_insights_events.enabled) {
    // Record their values
    var diff = this.customEvents.overflow()
    dropped.incrementCallCount(diff)
    seen.incrementCallCount(this.customEvents.seen)
    sent.incrementCallCount(this.customEvents.seen - diff)

    // Log any warnings about dropping events
    if (diff) {
      logger.warn(&#x27;Dropped %s custom events out of %s.&#x27;, diff, this.customEvents.seen)
    }

    // Create a new reservoir now (instead of at send time) so metrics match
    // what we actually send.
    this.customEvents = new Reservoir(
      this.config.custom_insights_events.max_samples_stored
    )
  } else if (this.customEventsPool.length &#x3e; 0) {
    // We have events and custom events are disabled. Clear everything out so we
    // don&#x27;t hold onto memory that we shouldn&#x27;t. Only time this could happen is
    // if the server sent down settings disabling custom events in the middle of
    // a harvest cycle.
    this.customEventsPool = []
    this.customEvents = new Reservoir(
      this.config.custom_insights_events.max_samples_stored
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.config.debug.supportability) {
  this.metrics.merge(this.config.debug.supportability)
}

// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this.<span class="apidocCodeKeywordSpan">_processCustomEvents</span>()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.toJSON().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._processErrorEvents" id="apidoc.element.newrelic.agent.prototype._processErrorEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_processErrorEvents
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _processErrorEvents() {
  var events = this.errors.getEvents()

  this._lastErrorEvents = [
    this.errors.getEventsLimit(),
    this.errors.getEventsSeen(),
    events
  ]

  // Create the metrics so they are at least set to 0
  var seen = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SEEN)
  var sent = this.metrics.getOrCreateMetric(NAMES.TRANSACTION_ERROR.SENT)

  // Bail out if there are no events
  if (events.length === 0) {
    return
  }

  if (this.config.error_collector.capture_events) {
    // Record their values
    var diff = this.errors.events.overflow()
    seen.incrementCallCount(this.errors.events.seen)
    sent.incrementCallCount(this.errors.events.seen - diff)

    // Log any warnings about dropping events
    if (diff) {
      logger.warn(&#x27;Dropped %s error events out of %s.&#x27;, diff, this.errors.events.seen)
    }

    // clear the reservoir now (instead of at send time) so metrics match
    // what we actually send.
    this.errors.clearEvents()
  } else if (events.length &#x3e; 0) {
    // We have events and error events are disabled. Clear everything out so we
    // don&#x27;t hold onto memory that we shouldn&#x27;t. Only time this could happen is
    // if the server sent down settings disabling error events in the middle of
    // a harvest cycle.
    this._lastErrorEvents = []
    this.errors.clearEvents()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.metrics.merge(this.config.debug.supportability)
}

// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this._processCustomEvents()
this.<span class="apidocCodeKeywordSpan">_processErrorEvents</span>()

// wait to check until all the standard stuff has been added
if (this.metrics.toJSON().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._restartHarvester" id="apidoc.element.newrelic.agent.prototype._restartHarvester">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_restartHarvester
        <span class="apidocSignatureSpan">(harvestSeconds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _restartHarvester(harvestSeconds) {
  this._stopHarvester()
  this._startHarvester(harvestSeconds)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function _harvesterIntervalChange(interval, callback) {
  var agent = this

  // only change the setup if the harvester is currently running
  if (this.harvesterHandle) {
    // force a harvest now, to be safe
    this.harvest(function cb_harvest(error) {
      agent.<span class="apidocCodeKeywordSpan">_restartHarvester</span>(interval)
      if (callback) callback(error)
    })
  } else if (callback) {
    process.nextTick(callback)
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendCustomEvents" id="apidoc.element.newrelic.agent.prototype._sendCustomEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendCustomEvents
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendCustomEvents(callback) {
  // Must be enabled and actually have events to send, otherwise bail and nextTick
  if (this.config.custom_insights_events.enabled &#x26;&#x26; this.customEventsPool.length &#x3e; 0) {
    var agent = this
    var run_id = agent.config.run_id

    var payload = [
      run_id,
      agent.customEventsPool
    ]

    // send data to collector
    agent.collector.customEvents(payload, function cb_customEvents(err) {
      if (err &#x26;&#x26; err.statusCode === 413 ) {
        var tooLarge = agent.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.TOO_LARGE)
        tooLarge.incrementCallCount()
        logger.warn(&#x27;request too large; custom event data dropped&#x27;)
      } else if (err) {
        var failed = agent.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.FAILED)
        failed.incrementCallCount()
        logger.warn(&#x27;custom events failed to send; re-sampling&#x27;)

        for (var i = 0; i &#x3c; agent.customEventsPool.length; i++) {
          agent.customEvents.add(agent.customEventsPool[i])
        }
      }

      callback(err)
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendErrorEvents" id="apidoc.element.newrelic.agent.prototype._sendErrorEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendErrorEvents
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendErrorEvents(callback) {
  if (this.config.error_collector.capture_events &#x26;&#x26; this._lastErrorEvents &#x26;&#x26;
        this._lastErrorEvents[2].length &#x3e; 0) {
    var agent = this
    var eventsLimit = this._lastErrorEvents[0]
    var eventsSeen = this._lastErrorEvents[1]
    var events = this._lastErrorEvents[2]
    var run_id = agent.config.run_id

    if (events.length &#x3c; 1) {
      return process.nextTick(callback)
    }

    var metrics = {
      reservoir_size: eventsLimit,
      events_seen: eventsSeen
    }

    var payload = [
      run_id,
      metrics,
      events
    ]

    // send data to collector
    agent.collector.errorEvents(payload, function cb_errorEvents(err) {
      if (err &#x26;&#x26; err.statusCode === 413 ) {
        logger.warn(&#x27;request too large; event data dropped&#x27;)
      } else if (err) {
        logger.warn(&#x27;error events failed to send; re-sampling&#x27;)
        agent.errors.mergeEvents(events)
      }
      callback(err)
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendErrors" id="apidoc.element.newrelic.agent.prototype._sendErrors">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendErrors
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendErrors(callback) {
  var agent = this

  if (this.config.collect_errors &#x26;&#x26; this.config.error_collector.enabled) {
    if (!this.collector.isConnected()) {
      return process.nextTick(function cb_nextTick() {
        callback(new Error(&#x22;not connected to New Relic (errors will be held)&#x22;))
      })
    } else if (this.errors.getTotalErrorCount() &#x3c; 1) {
      logger.debug(&#x22;No errors to send.&#x22;)
      return process.nextTick(callback)
    }

    var errors = this.errors.getErrors()
    var payload = [this.config.run_id, errors]

    // reset now to avoid losing errors that come in after delivery starts
    this.errors.clearErrors()

    this.collector.errorData(payload, function cb_errorData(error) {
      if (error) agent.errors.merge(errors)

      callback(error)
    })
  } else {
<span class="apidocCodeCommentSpan">    /**
     * Reset the errors object even if collection is disabled due to error
     * counting. Also covers the case where the error collector gets disabled
     * in the middle of a harvest cycle so the agent doesn&#x27;t continue to hold
     * on to the errors it had collected during the harvest cycle so far.
     */
</span>    this.errors.clearErrors()
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendEvents" id="apidoc.element.newrelic.agent.prototype._sendEvents">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendEvents
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendEvents(callback) {
  if (this.config.transaction_events.enabled) {
    var agent = this
    var events = agent.events
    var sample = events.toArray()
    var run_id = agent.config.run_id

    // bail if there are no events
    if (sample.length &#x3c; 1) {
      return process.nextTick(callback)
    }

    var metrics = {
      reservoir_size: events.limit,
      events_seen: events.seen
    }

    var payload = [
      run_id,
      metrics,
      sample
    ]

    // clear events
    agent.events = new Reservoir(agent.config.transaction_events.max_samples_per_minute)

    // send data to collector
    agent.collector.analyticsEvents(payload, function cb_analyticsEvents(err) {
      if (err &#x26;&#x26; err.statusCode === 413 ) {
        logger.warn(&#x27;request too large; event data dropped&#x27;)
      } else if (err) {
        logger.warn(&#x27;analytics events failed to send; re-sampling&#x27;)

        // boost the limit if a connection fails
        // and re-aggregate on failure
        var newlimit = agent.config.transaction_events.max_samples_stored
        agent.events.limit = newlimit

        for (var k = 0; k &#x3c; sample.length; k++) agent.events.add(sample[k])
      } else {
        // if we had to limit events and sample them, emit a warning
        var diff = events.overflow()
        if (diff &#x3e; 0) logger.warn(
          &#x27;analytics event overflow, dropped %d events; &#x27; +
           &#x27;try increasing your limit above %d&#x27;,
          diff, events.limit
        )
      }

      callback(err)
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendMetrics" id="apidoc.element.newrelic.agent.prototype._sendMetrics">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendMetrics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendMetrics(callback) {
  var agent = this

  if (this.collector.isConnected()) {
    if (this.errors.getTotalErrorCount() &#x3e; 0) {
      var count = this.errors.getTotalErrorCount()
      this.metrics.getOrCreateMetric(NAMES.ERRORS.ALL).incrementCallCount(count)

      count = this.errors.getWebTransactionsErrorCount()
      this.metrics.getOrCreateMetric(NAMES.ERRORS.WEB).incrementCallCount(count)

      count = this.errors.getBackgroundTransactionsErrorCount()
      this.metrics.getOrCreateMetric(NAMES.ERRORS.OTHER).incrementCallCount(count)
    }

    if (this.config.debug.supportability) {
      this.metrics.merge(this.config.debug.supportability)
    }

    // Send uninstrumented supportability metrics every harvest cycle
    uninstrumented.createMetrics(this.metrics)

    this._processCustomEvents()
    this._processErrorEvents()

    // wait to check until all the standard stuff has been added
    if (this.metrics.toJSON().length &#x3c; 1) {
      logger.debug(&#x22;No metrics to send.&#x22;)
      return process.nextTick(callback)
    }

    var metrics = this.metrics
    var beginSeconds = metrics.started * FROM_MILLIS
    var endSeconds = Date.now() * FROM_MILLIS
    var payload = [this.config.run_id, beginSeconds, endSeconds, metrics]


    // reset now to avoid losing metrics that come in after delivery starts
    this.metrics = new Metrics(
      this.config.apdex_t,
      this.mapper,
      this.metricNameNormalizer
    )

    this.collector.metricData(payload, function cb_metricData(error, rules) {
      if (error) agent.metrics.merge(metrics)
      if (rules) agent.mapper.load(rules)

      callback(error)
    })
  } else {
    process.nextTick(function cb_nextTick() {
      callback(new Error(&#x22;not connected to New Relic (metrics will be held)&#x22;))
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendQueries" id="apidoc.element.newrelic.agent.prototype._sendQueries">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendQueries
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendQueries(callback) {
  var agent = this
  var queries = this.queries

  this.queries = new QueryTracer(agent.config)

  if (!this.config.slow_sql.enabled) {
    logger.debug(&#x27;Slow Query is not enabled.&#x27;)
    return process.nextTick(callback)
  }

  if (Object.keys(queries.samples).length &#x3c; 1) {
    logger.debug(&#x27;No queries to send.&#x27;)
    return process.nextTick(callback)
  }

  queries.prepareJSON(function gotJSON(err, data) {
    if (err) {
      this.queries.merge(queries)
      logger.debug(&#x27;Error while serializing query data: %s&#x27;, err.message)
      return callback(err)
    }

    agent.collector.queryData([data], function handleResponse(error) {
      if (error) agent.queries.merge(queries)
      callback(error)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._sendTrace" id="apidoc.element.newrelic.agent.prototype._sendTrace">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_sendTrace
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _sendTrace(callback) {
  var agent = this
  if (this.config.collect_traces &#x26;&#x26; this.config.transaction_tracer.enabled) {
    if (!this.collector.isConnected()) {
      return process.nextTick(function cb_nextTick() {
        callback(new Error(&#x22;not connected to New Relic (slow trace data will be held)&#x22;))
      })
    }

    this.traces.harvest(function cb_harvest(error, traces, trace) {
      if (error || !traces || traces.length === 0) return callback(error)

      var payload = [agent.config.run_id, traces]
      agent.collector.transactionSampleData(
        payload,
        function cb_transactionSampleData(error) {
          if (!error) agent.traces.reset(trace)

          callback(error)
        }
      )
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._setupTracer" id="apidoc.element.newrelic.agent.prototype._setupTracer">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_setupTracer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _setupTracer() {
  var Tracer = require(&#x27;./transaction/tracer&#x27;)
  return new Tracer(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.transactionNameNormalizer = null
this.urlNormalizer = null
this.txSegmentNormalizer = null
this.userNormalizer = null
this.reset()

// Transaction tracing.
this.tracer = this.<span class="apidocCodeKeywordSpan">_setupTracer</span>()
this.traces = new TraceAggregator(this.config)

// Query tracing.
this.queries = new QueryTracer(this.config)

// Set up all the configuration events the agent needs to listen for.
var self = this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._startHarvester" id="apidoc.element.newrelic.agent.prototype._startHarvester">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_startHarvester
        <span class="apidocSignatureSpan">(harvestSeconds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _startHarvester(harvestSeconds) {
  var agent = this

  function onError(error) {
    if (error) {
      logger.info(error, &#x22;Error on submission to New Relic (data held for redelivery):&#x22;)
    }
  }

  function harvester() {
    agent.harvest(onError)
  }

  this.harvesterHandle = setInterval(harvester, harvestSeconds * TO_MILLIS)
  // timer.unref is 0.9+
  if (this.harvesterHandle.unref) this.harvesterHandle.unref()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (agent.collector.isConnected() &#x26;&#x26; !agent.config.no_immediate_harvest) {
  // harvest immediately for quicker data display, but after at least 1
  // second or the collector will throw away the data.
  setTimeout(function one_sec_delayed_harvest() {
    agent.harvest(function cb_harvest(error) {
      agent.<span class="apidocCodeKeywordSpan">_startHarvester</span>(agent.config.data_report_period)

      agent.setState(&#x27;started&#x27;)
      callback(error, config)
    })
  }, 1000)
} else {
  process.nextTick(function cb_nextTick() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._stopHarvester" id="apidoc.element.newrelic.agent.prototype._stopHarvester">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_stopHarvester
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _stopHarvester() {
  if (this.harvesterHandle) clearInterval(this.harvesterHandle)
  this.harvesterHandle = undefined
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Agent.prototype.stop = function stop(callback) {
if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

var agent = this

this.setState(&#x27;stopping&#x27;)
this.<span class="apidocCodeKeywordSpan">_stopHarvester</span>()
sampler.stop()

if (this.collector.isConnected()) {
  this.collector.shutdown(function cb_shutdown(error) {
    if (error) {
      agent.setState(&#x27;errored&#x27;)
      logger.warn(error, &#x22;Got error shutting down connection to New Relic:&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype._transactionFinished" id="apidoc.element.newrelic.agent.prototype._transactionFinished">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>_transactionFinished
        <span class="apidocSignatureSpan">(transaction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _transactionFinished(transaction) {
  // only available when this.config.debug.tracer_tracing is true
  if (transaction.describer) {
    logger.trace({trace_dump: transaction.describer.verbose}, &#x27;Dumped transaction state.&#x27;)
  }

  // Allow the API to explicitly set the ignored status on bg-tx.
  // This is handled for web-tx when setName is called on the tx.
  if (!transaction.isWeb() &#x26;&#x26; transaction.forceIgnore !== null) {
    transaction.ignore = transaction.forceIgnore
  }

  if (!transaction.ignore) {
    if (transaction.forceIgnore === false) {
      logger.debug(&#x22;Explicitly not ignoring %s.&#x22;, transaction.name)
    }
    this.metrics.merge(transaction.metrics)
    this.errors.onTransactionFinished(transaction, this.metrics)
    this.traces.add(transaction)

    var trace = transaction.trace
    trace.intrinsics = transaction.getIntrinsicAttributes()

    this._addEventFromTransaction(transaction)
  } else if (transaction.forceIgnore === true) {
    logger.debug(&#x22;Explicitly ignoring %s.&#x22;, transaction.name)
  } else {
    logger.debug(&#x22;Ignoring %s.&#x22;, transaction.name)
  }

  this.activeTransactions--
  this.totalActiveSegments -= transaction.numSegments
  this.segmentsClearedInHarvest += transaction.numSegments
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.getTransaction" id="apidoc.element.newrelic.agent.prototype.getTransaction">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>getTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTransaction() {
  return this.tracer.getTransaction()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
API.prototype.setTransactionName = function setTransactionName(name) {
var metric = this.agent.metrics.getOrCreateMetric(
  NAMES.SUPPORTABILITY.API + &#x27;/setTransactionName&#x27;
)
metric.incrementCallCount()

var transaction = this.agent.tracer.<span class="apidocCodeKeywordSpan">getTransaction</span>()
if (!transaction) {
  return logger.warn(&#x22;No transaction found when setting name to &#x27;%s&#x27;.&#x22;, name)
}

if (!name) {
  if (transaction &#x26;&#x26; transaction.url) {
    logger.error(&#x22;Must include name in setTransactionName call for URL %s.&#x22;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.harvest" id="apidoc.element.newrelic.agent.prototype.harvest">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>harvest
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function harvest(callback) {
  if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

  var agent = this
  var harvestSteps = [
    &#x27;_sendMetrics&#x27;,
    &#x27;_sendErrors&#x27;,
    &#x27;_sendTrace&#x27;,
    &#x27;_sendEvents&#x27;,
    &#x27;_sendCustomEvents&#x27;,
    &#x27;_sendQueries&#x27;,
    &#x27;_sendErrorEvents&#x27;
  ]

  logger.trace({
    segmentTotal: this.totalActiveSegments,
    harvestCreated: this.segmentsCreatedInHarvest,
    harvestCleared: this.segmentsClearedInHarvest,
    activeTransactions: this.activeTransactions
  }, &#x27;Entity stats on harvest&#x27;)

  this.segmentsCreatedInHarvest = 0
  this.segmentsClearedInHarvest = 0

  if (!this.collector.isConnected()) {
    return process.nextTick(function cb_nextTick() {
      callback(new Error(&#x22;Not connected to New Relic!&#x22;))
    })
  }
  runHarvestStep(0)

  function runHarvestStep(n) {
    agent[harvestSteps[n++]](next)

    function next(error) {
      if (error || n &#x3e;= harvestSteps.length) return callback(error)
      runHarvestStep(n)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  logger.warn(
    &#x27;options.timeout should be of type &#x22;number&#x22;. Got %s&#x27;,
    typeof options.timeout
  )
}

agent.on(&#x27;started&#x27;, function shutdownHarvest() {
  agent.<span class="apidocCodeKeywordSpan">harvest</span>(cb_harvest)
})
agent.on(&#x27;errored&#x27;, function logShutdownError(error) {
  agent.stop(callback)
  if (error) {
    logger.error(
      error,
      &#x27;The agent encountered an error after calling shutdown.&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.reconfigure" id="apidoc.element.newrelic.agent.prototype.reconfigure">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>reconfigure
        <span class="apidocSignatureSpan">(configuration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reconfigure(configuration) {
  if (!configuration) throw new TypeError(&#x22;must pass configuration&#x22;)

  this.config.onConnect(configuration)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)

// Error tracing.
if (!this.errors) {
  this.errors = new ErrorAggregator(this.config)
}
this.errors.<span class="apidocCodeKeywordSpan">reconfigure</span>(this.config)

// Metrics.
this.mapper = new MetricMapper()
this.metricNameNormalizer = new MetricNormalizer(this.config, &#x27;metric name&#x27;)
this.metrics = new Metrics(this.config.apdex_t, this.mapper, this.metricNameNormalizer)

// Transaction naming.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.reset" id="apidoc.element.newrelic.agent.prototype.reset">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reset() {
  // Insights events.
  if (!this.events) {
    this.events = new Reservoir()
  }
  this.events.setLimit(this.config.transaction_events.max_samples_per_minute)
  if (!this.customEvents) {
    this.customEvents = new Reservoir()
  }
  this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)

  // Error tracing.
  if (!this.errors) {
    this.errors = new ErrorAggregator(this.config)
  }
  this.errors.reconfigure(this.config)

  // Metrics.
  this.mapper = new MetricMapper()
  this.metricNameNormalizer = new MetricNormalizer(this.config, &#x27;metric name&#x27;)
  this.metrics = new Metrics(this.config.apdex_t, this.mapper, this.metricNameNormalizer)

  // Transaction naming.
  this.transactionNameNormalizer = new MetricNormalizer(this.config, &#x27;transaction name&#x27;)
  this.urlNormalizer = new MetricNormalizer(this.config, &#x27;URL&#x27;)

  // Segment term based tx renaming for MGI mitigation.
  this.txSegmentNormalizer = new TxSegmentNormalizer()

  // User naming and ignoring rules.
  this.userNormalizer = new MetricNormalizer(this.config, &#x27;user&#x27;)
  this.userNormalizer.loadFromConfig()

  // Supportability.
  if (this.config.debug.internal_metrics) {
    this.config.debug.supportability = new Metrics(
      this.config.apdex_t,
      this.mapper,
      this.metricNameNormalizer
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.mapper = null
this.metricNameNormalizer = null
this.metrics = null
this.transactionNameNormalizer = null
this.urlNormalizer = null
this.txSegmentNormalizer = null
this.userNormalizer = null
this.<span class="apidocCodeKeywordSpan">reset</span>()

// Transaction tracing.
this.tracer = this._setupTracer()
this.traces = new TraceAggregator(this.config)

// Query tracing.
this.queries = new QueryTracer(this.config)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.setState" id="apidoc.element.newrelic.agent.prototype.setState">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>setState
        <span class="apidocSignatureSpan">(newState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setState(newState) {
  if (STATES.indexOf(newState) === -1) {
    throw new TypeError(&#x22;Invalid state &#x22; + newState)
  }
  logger.debug(&#x22;Agent state changed from %s to %s.&#x22;, this._state, newState)
  this._state = newState
  this.emit(this._state)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} callback Continuation and error handler.
 */
Agent.prototype.start = function start(callback) {
  if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

  var agent = this

  this.<span class="apidocCodeKeywordSpan">setState</span>(&#x27;starting&#x27;)

  if (this.config.agent_enabled !== true) {
logger.warn(&#x22;The New Relic Node.js agent is disabled by its configuration. &#x22; +
            &#x22;Not starting!&#x22;)

this.setState(&#x27;stopped&#x27;)
return process.nextTick(callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.start" id="apidoc.element.newrelic.agent.prototype.start">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>start
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start(callback) {
  if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

  var agent = this

  this.setState(&#x27;starting&#x27;)

  if (this.config.agent_enabled !== true) {
    logger.warn(&#x22;The New Relic Node.js agent is disabled by its configuration. &#x22; +
                &#x22;Not starting!&#x22;)

    this.setState(&#x27;stopped&#x27;)
    return process.nextTick(callback)
  }

  if (!(this.config.license_key)) {
    logger.error(&#x22;A valid account license key cannot be found. &#x22; +
                 &#x22;Has a license key been specified in the agent configuration &#x22; +
                 &#x22;file or via the NEW_RELIC_LICENSE_KEY environment variable?&#x22;)

    this.setState(&#x27;errored&#x27;)
    return process.nextTick(function cb_nextTick() {
      callback(new Error(&#x22;Not starting without license key!&#x22;))
    })
  }

  sampler.start(agent)

  logger.info(&#x22;Starting New Relic for Node.js connection process.&#x22;)

  this.collector.connect(function cb_connect(error, config) {
    if (error) {
      agent.setState(&#x27;errored&#x27;)
      return callback(error, config)
    }

    if (agent.collector.isConnected() &#x26;&#x26; !agent.config.no_immediate_harvest) {
      // harvest immediately for quicker data display, but after at least 1
      // second or the collector will throw away the data.
      setTimeout(function one_sec_delayed_harvest() {
        agent.harvest(function cb_harvest(error) {
          agent._startHarvester(agent.config.data_report_period)

          agent.setState(&#x27;started&#x27;)
          callback(error, config)
        })
      }, 1000)
    } else {
      process.nextTick(function cb_nextTick() {
        callback(null, config)
      })
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error(message)
      }

      var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
      shimmer.patchModule(agent)
      shimmer.bootstrapInstrumentation(agent)

      agent.<span class="apidocCodeKeywordSpan">start</span>(function cb_start(error) {
if (!error) {
  return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
}

var errorMessage = &#x22;New Relic for Node.js halted startup due to an error:&#x22;
logger.error(error, errorMessage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.agent.prototype.stop" id="apidoc.element.newrelic.agent.prototype.stop">
        function <span class="apidocSignatureSpan">newrelic.agent.prototype.</span>stop
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stop(callback) {
  if (!callback) throw new TypeError(&#x22;callback required!&#x22;)

  var agent = this

  this.setState(&#x27;stopping&#x27;)
  this._stopHarvester()
  sampler.stop()

  if (this.collector.isConnected()) {
    this.collector.shutdown(function cb_shutdown(error) {
      if (error) {
        agent.setState(&#x27;errored&#x27;)
        logger.warn(error, &#x22;Got error shutting down connection to New Relic:&#x22;)
      } else {
        agent.setState(&#x27;stopped&#x27;)
        logger.info(&#x22;Stopped New Relic for Node.js.&#x22;)
      }

      callback(error)
    })
  } else {
    process.nextTick(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function cb_harvest(error) {
  if (error) {
    logger.error(
      error,
      &#x27;An error occurred while running last harvest before shutdown.&#x27;
    )
  }
  agent.<span class="apidocCodeKeywordSpan">stop</span>(callback)
}

if (options &#x26;&#x26; options.collectPendingData &#x26;&#x26; agent._state !== &#x27;started&#x27;) {
  if (typeof options.timeout === &#x27;number&#x27;) {
    var shutdownTimeout = setTimeout(function shutdownTimeout() {
      agent.stop(callback)
    }, options.timeout)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.api" id="apidoc.module.newrelic.api">module newrelic.api</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.api.api" id="apidoc.element.newrelic.api.api">
        function <span class="apidocSignatureSpan">newrelic.</span>api
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function API(agent) {
  this.agent = agent
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.api.prototype" id="apidoc.module.newrelic.api.prototype">module newrelic.api.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.addCustomParameter" id="apidoc.element.newrelic.api.prototype.addCustomParameter">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addCustomParameter
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addCustomParameter(name, value) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/addCustomParameter&#x27;
  )
  metric.incrementCallCount()

  // If high security mode is on, custom params are disabled.
  if (this.agent.config.high_security === true) {
    logger.warnOnce(
      &#x22;Custom params&#x22;,
      &#x22;Custom parameters are disabled by high security mode.&#x22;
    )
    return false
  }

  var ignored = this.agent.config.ignored_params || []

  var transaction = this.agent.tracer.getTransaction()
  if (!transaction) {
    return logger.warn(&#x22;No transaction found for custom parameters.&#x22;)
  }

  var trace = transaction.trace
  if (!trace.custom) {
    return logger.warn(
      &#x22;Couldn&#x27;t add parameter %s to nonexistent custom parameters.&#x22;,
      name
    )
  }

  if (CUSTOM_BLACKLIST.indexOf(name) !== -1) {
    return logger.warn(&#x22;Not overwriting value of NR-only parameter %s.&#x22;, name)
  }

  if (ignored.indexOf(name) !== -1) {
    return logger.warn(&#x22;Not setting ignored parameter name %s.&#x22;, name)
  }

  if (name in trace.custom) {
    logger.debug(
      &#x22;Changing custom parameter %s from %s to %s.&#x22;,
      name,
      trace.custom[name],
      value
    )
  }

  trace.custom[name] = value
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Programmatic version of `rules.ignore` above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. The pattern is mandatory.

### Other API calls

#### newrelic.<span class="apidocCodeKeywordSpan">addCustomParameter</span>(name, value)

Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

#### newrelic.addCustomParameters(params)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.addCustomParameters" id="apidoc.element.newrelic.api.prototype.addCustomParameters">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addCustomParameters
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addCustomParameters(params) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/addCustomParameters&#x27;
  )
  metric.incrementCallCount()

  for (var key in params) {
    if (!params.hasOwnProperty(key)) {
      continue
    }

    this.addCustomParameter(key, params[key])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### newrelic.addCustomParameter(name, value)

Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

#### newrelic.<span class="apidocCodeKeywordSpan">addCustomParameters</span>(params)

Set multiple custom parameter values to be attached to a transaction trace and/or
error in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

Example of setting multiple custom parameters at once:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.addIgnoringRule" id="apidoc.element.newrelic.api.prototype.addIgnoringRule">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addIgnoringRule
        <span class="apidocSignatureSpan">(pattern)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addIgnoringRule(pattern) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/addIgnoringRule&#x27;
  )
  metric.incrementCallCount()

  if (!pattern) return logger.error(&#x22;Must include a URL pattern to ignore.&#x22;)

  this.agent.userNormalizer.addSimple(pattern, null)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### newrelic.addNamingRule(pattern, name)

Programmatic version of `rules.name` above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. Both parameters are mandatory.

#### newrelic.<span class="apidocCodeKeywordSpan">addIgnoringRule</span>(pattern)

Programmatic version of `rules.ignore` above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. The pattern is mandatory.

### Other API calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.addNamingRule" id="apidoc.element.newrelic.api.prototype.addNamingRule">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>addNamingRule
        <span class="apidocSignatureSpan">(pattern, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addNamingRule(pattern, name) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/addNamingRule&#x27;
  )
  metric.incrementCallCount()


  if (!name) return logger.error(&#x22;Simple naming rules require a replacement name.&#x22;)

  this.agent.userNormalizer.addSimple(pattern, &#x27;/&#x27; + name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Can also be set via the environment variable `NEW_RELIC_IGNORING_RULES`, with
multiple rules passed in as a list of comma-delimited patterns:
`NEW_RELIC_IGNORING_RULES=&#x27;^/socket\.io/\*/xhr-polling,ignore_me&#x27;` Note that
currently there is no way to escape commas in patterns.

### API for adding naming and ignoring rules

#### newrelic.<span class="apidocCodeKeywordSpan">addNamingRule</span>(pattern, name)

Programmatic version of `rules.name` above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. Both parameters are mandatory.

#### newrelic.addIgnoringRule(pattern)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.createBackgroundTransaction" id="apidoc.element.newrelic.api.prototype.createBackgroundTransaction">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createBackgroundTransaction
        <span class="apidocSignatureSpan">(name, group, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBackgroundTransaction(name, group, handle) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/createBackgroundTransaction&#x27;
  )
  metric.incrementCallCount()

  if (handle === undefined &#x26;&#x26; typeof group === &#x27;function&#x27;) {
    handle = group
    group = &#x27;Nodejs&#x27;
  }
  // FLAG: custom_instrumentation
  if (!this.agent.config.feature_flag.custom_instrumentation) {
    return handle
  }

  var fail = false
  if (!name) {
    logger.warn(&#x27;createBackgroundTransaction called without an url&#x27;)
    fail = true
  }

  if (typeof handle !== &#x27;function&#x27;) {
    logger.warn(
      &#x27;createBackgroundTransaction called with a handle arg that is not a function&#x27;
    )
    fail = true
  }

  if (fail) {
    // If name is undefined but handle is defined we should make a best effort
    // to return it so things don&#x27;t crash.
    return handle
  }

  logger.debug(
    &#x27;creating background transaction generator %s:%s (%s)&#x27;,
    name,
    group,
    handle &#x26;&#x26; handle.name
  )

  var tracer = this.agent.tracer

  return tracer.transactionNestProxy(&#x27;bg&#x27;, function createBackgroundSegment() {
    var tx = tracer.getTransaction()

    logger.debug(
      &#x27;creating background transaction %s:%s (%s) with transaction id: %s&#x27;,
      name,
      group,
      handle &#x26;&#x26; handle.name,
      tx.id
    )

    tx.setBackgroundName(name, group)
    tx.bgSegment = tracer.createSegment(name, recordBackground)
    tx.bgSegment.partialName = group
    tx.bgSegment.start()

    return tracer.bindFunction(handle, tx.bgSegment).apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
independent transaction and any calls within the `handle` will be bound to the
new web transaction.

Custom transactions **must** be ended manually by calling `endTransaction()`.
Timing for custom transaction starts from when the returned wrapped function is
called until `endTransaction()` is called.

#### newrelic.<span class="apidocCodeKeywordSpan">createBackgroundTransaction</span>(name, [group], handle)

`name` is the name of the job. It should be pretty static, and not include job
ids or anything very specific to that run of the job. `group` is optional, and
allows you to group types of jobs together. This should follow similar rules as
the `name`. `handle` is a function that encompases your background job. Both
custom and auto instrumentation will be captured as part of the transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.createTracer" id="apidoc.element.newrelic.api.prototype.createTracer">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createTracer
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTracer(name, callback) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/createTracer&#x27;
  )
  metric.incrementCallCount()

  // FLAG: custom_instrumentation
  if (!this.agent.config.feature_flag.custom_instrumentation) {
    return callback
  }

  var fail = false
  if (!name) {
    logger.warn(&#x27;createTracer called without a name&#x27;)
    fail = true
  }

  if (typeof callback !== &#x27;function&#x27;) {
    logger.warn(&#x27;createTracer called with a callback arg that is not a function&#x27;)
    fail = true
  }

  if (fail) {
    // If name is undefined but callback is defined we should make a best effort
    // to return it so things don&#x27;t crash.
    return callback
  }

  var tracer = this.agent.tracer
  var txn = tracer.getTransaction()
  if (!txn) {
    logger.debug(
      &#x27;createTracer called with %s (%s) outside of a transaction, &#x27; +
        &#x27;unable to create tracer.&#x27;,
      name,
      callback &#x26;&#x26; callback.name
    )
    return callback
  }

  logger.debug(
    &#x27;creating tracer %s (%s) on transaction %s.&#x27;,
    name,
    callback &#x26;&#x26; callback.name,
    txn.id
  )

  var segment = tracer.createSegment(name, customRecorder)
  segment.start()
  return tracer.bindFunction(callback, segment, true)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
called until `endTransaction()` is called.

#### newrelic.endTransaction()

This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.

#### newrelic.<span class="apidocCodeKeywordSpan">createTracer</span>(name, handle)

`name` is the name of the tracer. It will show up as a segment in your
transaction traces and create its own metric. `handle` is the function to be
bound to the tracer.

Timing is from when `createTracer` is called until the `handle` done executing.
This should be called inside of a transaction to get data. If it is called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.createWebTransaction" id="apidoc.element.newrelic.api.prototype.createWebTransaction">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>createWebTransaction
        <span class="apidocSignatureSpan">(url, handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createWebTransaction(url, handle) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/createWebTransaction&#x27;
  )
  metric.incrementCallCount()

  // FLAG: custom_instrumentation
  if (!this.agent.config.feature_flag.custom_instrumentation) {
    return handle
  }

  var fail = false
  if (!url) {
    logger.warn(&#x27;createWebTransaction called without an url&#x27;)
    fail = true
  }

  if (typeof handle !== &#x27;function&#x27;) {
    logger.warn(&#x27;createWebTransaction called with a handle arg that is not a function&#x27;)
    fail = true
  }

  if (fail) {
    // If name is undefined but handle is defined we should make a best effort
    // to return it so things don&#x27;t crash.
    return handle
  }

  logger.debug(
    &#x27;creating web transaction generator %s (%s).&#x27;,
    url,
    handle &#x26;&#x26; handle.name
  )

  var tracer = this.agent.tracer

  return tracer.transactionNestProxy(&#x27;web&#x27;, function createWebSegment() {
    var tx = tracer.getTransaction()

    logger.debug(
      &#x27;creating web transaction %s (%s) with transaction id: %s&#x27;,
      url,
      handle &#x26;&#x26; handle.name,
      tx.id
    )
    tx.nameState.setName(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url)
    tx.url = url
    tx.applyUserNamingRules(tx.url)
    tx.webSegment = tracer.createSegment(url, recordWeb)
    tx.webSegment.start()

    return tracer.bindFunction(handle, tx.webSegment).apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
varieties of socket servers, and background jobs. These are things that the
agent can&#x27;t automatically instrument because without your knowledge of your
application, the agent can&#x27;t tell when they should begin and end.

Read more at:
https://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/nodejs-custom-instrumentation

#### newrelic.<span class="apidocCodeKeywordSpan">createWebTransaction</span>(url, handle)

`url` is the name of the web transaction. It should be pretty static, not
including anything like user ids or any other data that is very specific to the
request. `handle` is the function you&#x27;d like to wrap in the web transaction.
Both custom and auto instrumentation will be captured as part of the
transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.endTransaction" id="apidoc.element.newrelic.api.prototype.endTransaction">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>endTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endTransaction() {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/endTransaction&#x27;
  )
  metric.incrementCallCount()

  // FLAG: custom_instrumentation
  if (!this.agent.config.feature_flag.custom_instrumentation) {
    return
  }

  var tracer = this.agent.tracer
  var tx = tracer.getTransaction()

  if (tx) {
    if (tx.webSegment) {
      tx.setName(tx.url, 0)
      tx.webSegment.markAsWeb(tx.url)
      tx.webSegment.end()
    } else if (tx.bgSegment) {
      tx.bgSegment.end()
    }
    logger.debug(&#x27;ending transaction with id: %s and name: %s&#x27;, tx.id, tx.name)
    tx.end()
  } else {
    logger.debug(&#x27;endTransaction() called while not in a transaction.&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
transaction and any calls within the `handle` will be bound to the new,
independent background transaction.

Custom transactions **must** be ended manually by calling `endTransaction()`.
Timing for custom transaction starts from when the returned wrapped function is
called until `endTransaction()` is called.

#### newrelic.<span class="apidocCodeKeywordSpan">endTransaction</span>()

This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.

#### newrelic.createTracer(name, handle)

`name` is the name of the tracer. It will show up as a segment in your
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.getBrowserTimingHeader" id="apidoc.element.newrelic.api.prototype.getBrowserTimingHeader">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>getBrowserTimingHeader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getBrowserTimingHeader() {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/getBrowserTimingHeader&#x27;
  )
  metric.incrementCallCount()

  var config = this.agent.config

<span class="apidocCodeCommentSpan">  /**
   * Gracefully fail.
   *
   * Output an HTML comment and log a warning the comment is meant to be
   * innocuous to the end user.
   *
   * @param {number} num          - Error code from `RUM_ISSUES`.
   * @param {bool} [quite=false]  - Be quiet about this failure.
   *
   * @see RUM_ISSUES
   */
</span>  function _gracefail(num, quiet) {
    if (quiet) {
      logger.debug(RUM_ISSUES[num])
    } else {
      logger.warn(RUM_ISSUES[num])
    }
    return &#x27;&#x3c;!-- NREUM: (&#x27; + num + &#x27;) --&#x3e;&#x27;
  }

  var browser_monitoring = config.browser_monitoring

  // config.browser_monitoring should always exist, but we don&#x27;t want the agent
  // to bail here if something goes wrong
  if (!browser_monitoring) return _gracefail(2)

  /* Can control header generation with configuration this setting is only
   * available in the newrelic.js config file, it is not ever set by the
   * server.
   */
  if (!browser_monitoring.enable) {
    // It has been disabled by the user; no need to warn them about their own
    // settings so fail quietly and gracefully.
    return _gracefail(0, true)
  }

  var trans = this.agent.getTransaction()

  // bail gracefully outside a transaction
  if (!trans) return _gracefail(1)

  var name = trans.getName()

  /* If we&#x27;re in an unnamed transaction, add a friendly warning this is to
   * avoid people going crazy, trying to figure out why browser monitoring is
   * not working when they&#x27;re missing a transaction name.
   */
  if (!name) return _gracefail(3)

  var time = trans.timer.getDurationInMillis()

  /*
   * Only the first 13 chars of the license should be used for hashing with
   * the transaction name.
   */
  var key = config.license_key.substr(0, 13)
  var appid = config.application_id

  /* This is only going to work if the agent has successfully handshaked with
   * the collector. If the networks is bad, or there is no license key set in
   * newrelis.js, there will be no application_id set.  We bail instead of
   * outputting null/undefined configuration values.
   */
  if (!appid) return _gracefail(4)

  /* If there is no browser_key, the server has likely decided to disable
   * browser monitoring.
   */
  var licenseKey = browser_monitoring.browser_key
  if (!licenseKey) return _gracefail(5)

  /* If there is no agent_loader script, there is no point
   * in setting the rum data
   */
  var js_agent_loader = browser_monitoring.js_agent_loader
  if (!js_agent_loader) return _gracefail(6)

  /* If rum is enabled, but then later disabled on the server,
   * this is the only parameter that gets updated.
   *
   * This condition should only be met if rum is disabled during
   * the lifetime of an application, and it should be picked up
   * on the next ForceRestart by the collector.
   */
  var loader = browser_monitoring.loader
  if (loader === &#x27;none&#x27;) return _gracefail(7)

  // This hash gets written directly into the browser.
  var rum_hash = {
    agent: browser_monitoring.js_agent_file,
    beacon: browser_monitoring.beacon,
    errorBeacon: browser_monitoring.error_beacon,
    licenseKey: licenseKey,
    applicationID: appid,
    applicationTime: time,
    transactionName: hashes.obfuscateNameUsingKey(name, key),
    queueTime: trans.queueTime,
    ttGuid: trans.id,

    // we don&#x27;t use these parameters yet
    agentToken: null
  }

  // if debugging, do pretty format of JSON
  var tabs = config.browser_monitoring.debug ? 2 : 0
  var json = JSON.stringify(rum_hash, null, tabs)


  // the complete header to be written to the browser
  var out = util.format(
    RUM_STUB,
    json,
    js_agent_loader
  )

  logger.trace(&#x27;generating RUM header&#x27;, out)

  return out
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
times.

Headers must be manually injected, but no extra configuration is necessary to
enable browser timings.

### Basics

- Insert the result of `newrelic.<span class="apidocCodeKeywordSpan">getBrowserTimingHeader</span>()`
into your html page.
- The browser timing headers should be placed in the beginning of your `&#x3c;head&#x3e;` tag.
  - As an exception to the above, for maximum IE compatability, the results of `getBrowserTimingHeader()`
should be placed *after* any `X-UA-COMPATIBLE HTTP-EQUIV` meta tags.
- Do *not* cache the header, call it once for every request.

### Example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.incrementMetric" id="apidoc.element.newrelic.api.prototype.incrementMetric">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>incrementMetric
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function incrementMetric(name, value) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/incrementMetric&#x27;
  )
  metric.incrementCallCount()

  // FLAG: custom_metrics
  if (!this.agent.config.feature_flag.custom_metrics) {
    return
  }

  if (!value &#x26;&#x26; value !== 0) {
    value = 1
  }

  if (typeof value !== &#x27;number&#x27; || value % 1 !== 0) {
    logger.warn(&#x27;Metric Increment value must be an integer&#x27;)
    return
  }

  this.recordMetric(name, {
    count: value,
    total: 0,
    min: 0,
    max: 0,
    sumOfSquares: 0
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`value` is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If `value` is
an object, it must include keys for `count`, `total`, `min`, `max`, and
`sumOfSquares`.

#### newrelic.<span class="apidocCodeKeywordSpan">incrementMetric</span>(name[, amount])

`name` is the metric name to record, it must be a string that beings with
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`amount` is optional, but must be an integer if provided.  `amount` is
the number of times to increment the metrics `count`, it defaults to 1.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.noticeError" id="apidoc.element.newrelic.api.prototype.noticeError">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>noticeError
        <span class="apidocSignatureSpan">(error, customParameters)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noticeError(error, customParameters) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/noticeError&#x27;
  )
  metric.incrementCallCount()


  if (typeof error === &#x27;string&#x27;) error = new Error(error)
  var transaction = this.agent.tracer.getTransaction()

  this.agent.errors.addUserError(transaction, error, customParameters)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you **must**
pass `false` as the parameter – in this case `null` or `undefined` will be
ignored.

#### newrelic.<span class="apidocCodeKeywordSpan">noticeError</span>(error, customParameters)

If your app is doing its own error handling with domains or try/catch clauses,
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.recordCustomEvent" id="apidoc.element.newrelic.api.prototype.recordCustomEvent">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>recordCustomEvent
        <span class="apidocSignatureSpan">(eventType, attributes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordCustomEvent(eventType, attributes) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/recordCustomEvent&#x27;
  )
  metric.incrementCallCount()

  if (!this.agent.config.custom_insights_events.enabled) {
    return
  }
  // Check all the arguments before bailing to give maximum information in a
  // single invocation.
  var fail = false

  if (!eventType || typeof eventType !== &#x27;string&#x27;) {
    logger.warn(
      &#x27;recordCustomEvent requires a string for its first argument, got %s (%s)&#x27;,
      stringify(eventType),
      typeof eventType
    )
    fail = true
  } else if (!CUSTOM_EVENT_TYPE_REGEX.test(eventType)) {
    logger.warn(
      &#x27;recordCustomEvent eventType of %s is invalid, it must match /%s/&#x27;,
      eventType,
      CUSTOM_EVENT_TYPE_REGEX.source
    )
    fail = true
  } else if (eventType.length &#x3e; 255) {
    logger.warn(
      &#x27;recordCustomEvent eventType must have a length less than 256, got %s (%s)&#x27;,
      eventType,
      eventType.length
    )
    fail = true
  }
  // If they don&#x27;t pass an attributes object, or the attributes argument is not
  // an object, or if it is an object and but is actually an array, log a
  // warning and set the fail bit.
  if (!attributes || typeof attributes !== &#x27;object&#x27; || Array.isArray(attributes)) {
    logger.warn(
      &#x27;recordCustomEvent requires an object for its second argument, got %s (%s)&#x27;,
      stringify(attributes),
      typeof attributes
    )
    fail = true
  } else if (_checkKeyLength(attributes, 255)) {
    fail = true
  }

  if (fail) {
    return
  }

  var instrinics = {
    type: eventType,
    timestamp: Date.now()
  }

  this.agent.customEvents.add([instrinics, attributes])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Custom Insights Events
 *
 * Custom insights events are JSON object that are sent to New Relic
 * Insights. You can tell the agent to send your custom events via the
 * `newrelic.<span class="apidocCodeKeywordSpan">recordCustomEvent</span>()` API. These events are sampled once the max
 * reservoir size is reached. You can tune this setting below.
 *
 * Read more here: http://newrelic.com/insights
 */
custom_insights_events: {
  /**
   * If this is disabled, the agent does not collect, nor try to send, custom
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.recordMetric" id="apidoc.element.newrelic.api.prototype.recordMetric">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>recordMetric
        <span class="apidocSignatureSpan">(name, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordMetric(name, value) {
  var supportMetric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/recordMetric&#x27;
  )
  supportMetric.incrementCallCount()

  // FLAG: custom_metrics
  if (!this.agent.config.feature_flag.custom_metrics) {
    return
  }

  if (typeof name !== &#x27;string&#x27;) {
    logger.warn(&#x27;Metric name must be a string&#x27;)
    return
  }

  var metric = this.agent.metrics.getOrCreateMetric(name)

  if (typeof value === &#x27;number&#x27;) {
    metric.recordValue(value)
    return
  }

  if (typeof value !== &#x27;object&#x27;) {
    logger.warn(&#x27;Metric value must be either a number, or a metric object&#x27;)
    return
  }

  var stats = {}
  var required = [&#x27;count&#x27;, &#x27;total&#x27;, &#x27;min&#x27;, &#x27;max&#x27;, &#x27;sumOfSquares&#x27;]
  var keyMap = {count: &#x27;callCount&#x27;}

  for (var i = 0, l = required.length; i &#x3c; l; ++i) {
    if (typeof value[required[i]] !== &#x27;number&#x27;) {
      logger.warn(&#x27;Metric object must include &#x27; + required[i] + &#x27; as a number&#x27;)
      return
    }

    var key = keyMap[required[i]] || required[i]
    stats[key] = value[required[i]]
  }

  if (typeof value.totalExclusive === &#x27;number&#x27;) {
    stats.totalExclusive = value.totalExclusive
  } else {
    stats.totalExclusive = value.total
  }

  metric.merge(stats)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
transaction traces and create its own metric. `handle` is the function to be
bound to the tracer.

Timing is from when `createTracer` is called until the `handle` done executing.
This should be called inside of a transaction to get data. If it is called
outside of a transaction it will just pass through.

#### newrelic.<span class="apidocCodeKeywordSpan">recordMetric</span>(name, value)

`name` is the metric name to record, it must be a string that begins with
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`value` is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If `value` is
an object, it must include keys for `count`, `total`, `min`, `max`, and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.setControllerName" id="apidoc.element.newrelic.api.prototype.setControllerName">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setControllerName
        <span class="apidocSignatureSpan">(name, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setControllerName(name, action) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/setControllerName&#x27;
  )
  metric.incrementCallCount()

  var transaction = this.agent.tracer.getTransaction()
  if (!transaction) {
    return logger.warn(&#x22;No transaction found when setting controller to %s.&#x22;, name)
  }

  if (!name) {
    if (transaction &#x26;&#x26; transaction.url) {
      logger.error(&#x22;Must include name in setControllerName call for URL %s.&#x22;,
                   transaction.url)
    } else {
      logger.error(&#x22;Must include name in setControllerName call.&#x22;)
    }

    return
  }

  action = action || transaction.verb || &#x27;GET&#x27;
  transaction.forceName = NAMES.CONTROLLER + &#x27;/&#x27; + name + &#x27;/&#x27; + action
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.

Explicitly calling `newrelic.setTransactionName()` will override any names set
by Express, Restify or Hapi routes. Calls to `newrelic.setTransactionName()` and
`newrelic.<span class="apidocCodeKeywordSpan">setControllerName</span>()` will overwrite each other. The last call made
before the request ends wins.

**VERY IMPORTANT NOTE:** Do not include highly variable information like GUIDs,
numerical IDs, or timestamps in the request names you create. If your request
is slow enough to generate a transaction trace, that trace will contain the
original URL. If you enable parameter capture, the parameters will also be
attached to the trace. The request names are used to group requests for New
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.setIgnoreTransaction" id="apidoc.element.newrelic.api.prototype.setIgnoreTransaction">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setIgnoreTransaction
        <span class="apidocSignatureSpan">(ignored)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setIgnoreTransaction(ignored) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/setIgnoreTransaction&#x27;
  )
  metric.incrementCallCount()

  var transaction = this.agent.tracer.getTransaction()
  if (!transaction) {
    return logger.warn(&#x22;No transaction found to ignore.&#x22;)
  }

  transaction.forceIgnore = ignored
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example of setting multiple custom parameters at once:

```javascript
newrelic.addCustomParameters({test: &#x27;value&#x27;, test2: &#x27;value2&#x27;});
```

#### newrelic.<span class="apidocCodeKeywordSpan">setIgnoreTransaction</span>(ignored)

Tell the module explicitly whether or not a given request should be ignored.
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you **must**
pass `false` as the parameter – in this case `null` or `undefined` will be
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.setTransactionName" id="apidoc.element.newrelic.api.prototype.setTransactionName">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>setTransactionName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTransactionName(name) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/setTransactionName&#x27;
  )
  metric.incrementCallCount()

  var transaction = this.agent.tracer.getTransaction()
  if (!transaction) {
    return logger.warn(&#x22;No transaction found when setting name to &#x27;%s&#x27;.&#x22;, name)
  }

  if (!name) {
    if (transaction &#x26;&#x26; transaction.url) {
      logger.error(&#x22;Must include name in setTransactionName call for URL %s.&#x22;,
                   transaction.url)
    } else {
      logger.error(&#x22;Must include name in setTransactionName call.&#x22;)
    }

    return
  }

  transaction.forceName = NAMES.CUSTOM + &#x27;/&#x27; + name
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

is all you need. Please note that you still need to ensure that loading the New
Relic module is the first thing your application does, as it needs to bootstrap
itself before the rest of your application loads, but you can safely require
the module from multiple modules in your application – it will only initialize
itself once.

#### newrelic.<span class="apidocCodeKeywordSpan">setTransactionName</span>(name)

Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.

Explicitly calling `newrelic.setTransactionName()` will override any names set
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.api.prototype.shutdown" id="apidoc.element.newrelic.api.prototype.shutdown">
        function <span class="apidocSignatureSpan">newrelic.api.prototype.</span>shutdown
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shutdown(options, cb) {
  var metric = this.agent.metrics.getOrCreateMetric(
    NAMES.SUPPORTABILITY.API + &#x27;/shutdown&#x27;
  )
  metric.incrementCallCount()

  var callback = cb
  if (!callback) {
    if (typeof options === &#x27;function&#x27;) {
      callback = options
    } else {
      callback = function noop() {}
    }
  }

  var agent = this.agent

  function cb_harvest(error) {
    if (error) {
      logger.error(
        error,
        &#x27;An error occurred while running last harvest before shutdown.&#x27;
      )
    }
    agent.stop(callback)
  }

  if (options &#x26;&#x26; options.collectPendingData &#x26;&#x26; agent._state !== &#x27;started&#x27;) {
    if (typeof options.timeout === &#x27;number&#x27;) {
      var shutdownTimeout = setTimeout(function shutdownTimeout() {
        agent.stop(callback)
      }, options.timeout)
      // timer.unref only in 0.9+
      if (shutdownTimeout.unref) {
        shutdownTimeout.unref()
      }
    } else if (options.timeout) {
      logger.warn(
        &#x27;options.timeout should be of type &#x22;number&#x22;. Got %s&#x27;,
        typeof options.timeout
      )
    }

    agent.on(&#x27;started&#x27;, function shutdownHarvest() {
      agent.harvest(cb_harvest)
    })
    agent.on(&#x27;errored&#x27;, function logShutdownError(error) {
      agent.stop(callback)
      if (error) {
        logger.error(
          error,
          &#x27;The agent encountered an error after calling shutdown.&#x27;
        )
      }
    })
  } else if (options &#x26;&#x26; options.collectPendingData) {
    agent.harvest(cb_harvest)
  } else {
    agent.stop(callback)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
display.

#### newrelic.<span class="apidocCodeKeywordSpan">shutdown</span>([options], callback)

Use this method to gracefully shut down the agent.  When called with
`options.collectPendingData` set to true, the agent will send any pending data to
the New Relic servers before shutting down.  This is useful when you want to shut down
the Node process and make sure that all transactions and/or errors are captured by
New Relic.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.aws_info" id="apidoc.module.newrelic.aws_info">module newrelic.aws_info</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.aws_info.aws_info" id="apidoc.element.newrelic.aws_info.aws_info">
        function <span class="apidocSignatureSpan">newrelic.</span>aws_info
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchAWSInfo(agent, callback) {
  if (!agent.config.utilization || !agent.config.utilization.detect_aws) {
    return callback(null)
  }

  if (resultDict) {
    return callback(resultDict)
  }

  var awsQuery = module.exports._awsQuery

  awsQuery(&#x27;instance-type&#x27;, agent, function getInstanceType(type) {
    if (!type) return callback(null)
    awsQuery(&#x27;instance-id&#x27;, agent, function getInstanceId(id) {
      if (!id) return callback(null)
      awsQuery(&#x27;placement/availability-zone&#x27;, agent, function getZone(zone) {
        if (!zone) return callback(null)
        resultDict = {
          type: type,
          id: id,
          zone: zone
        }
        return callback(resultDict)
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aws_info._awsQuery" id="apidoc.element.newrelic.aws_info._awsQuery">
        function <span class="apidocSignatureSpan">newrelic.aws_info.</span>_awsQuery
        <span class="apidocSignatureSpan">(key, agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function awsQuery(key, agent, callback) {
  var instanceHost = &#x27;169.254.169.254&#x27;
  var apiVersion = &#x27;2008-02-01&#x27;
  var url = [&#x27;http:/&#x27;, instanceHost, apiVersion, &#x27;meta-data&#x27;, key].join(&#x27;/&#x27;)
  var req = http.get(url, function awsRequest(res) {
    res.pipe(concat(respond))
    function respond(data) {
      var valid = checkResponseString(data)
      if (!valid) {
        var awsError = agent.metrics.getOrCreateMetric(NAMES.UTILIZATION.AWS_ERROR)
        awsError.incrementCallCount()
        logger.debug(&#x27;Response for attribute &#x27; + key + &#x27;: %s&#x27;
          , data)
        data = null
      } else {
        data = data.toString(&#x27;utf8&#x27;)
      }

      agent.removeListener(&#x27;errored&#x27;, abortRequest)
      agent.removeListener(&#x27;stopped&#x27;, abortRequest)
      callback(data)
    }
  })
  req.setTimeout(1000, function awsTimeout() {
    logger.debug(&#x27;Request for attribute %s timed out&#x27;, key)
    callback(null)
  })
  req.on(&#x27;error&#x27;, function awsError(err) {
    logger.debug(&#x27;Message for attribute %s: %s&#x27;, key, err.message)
    callback(null)
  })

  agent.once(&#x27;errored&#x27;, abortRequest)
  agent.once(&#x27;stopped&#x27;, abortRequest)

  function abortRequest() {
    logger.debug(&#x27;Abborting request for attribute %s&#x27;, key)
    req.abort()
    agent.removeListener(&#x27;errored&#x27;, abortRequest)
    agent.removeListener(&#x27;stopped&#x27;, abortRequest)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.aws_info.clearCache" id="apidoc.element.newrelic.aws_info.clearCache">
        function <span class="apidocSignatureSpan">newrelic.aws_info.</span>clearCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearAWSCache() {
  resultDict = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.config" id="apidoc.module.newrelic.config">module newrelic.config</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.config.config" id="apidoc.element.newrelic.config.config">
        function <span class="apidocSignatureSpan">newrelic.</span>config
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Config(config) {
  EventEmitter.call(this)

  // 1. start by cloning the defaults
  try {
    var basis = JSON.parse(stringifySync(DEFAULT_CONFIG))
    Object.keys(basis).forEach(function cb_forEach(key) {
      this[key] = basis[key]
    }, this)
  } catch (err) {
    logger.warn(&#x27;Unable to clone the default config, %s: %s&#x27;, DEFAULT_CONFIG_PATH, err)
  }

  if (config &#x26;&#x26;
      (process.env[ENV_MAPPING.ssl] === &#x27;false&#x27; || config.ssl === false) &#x26;&#x26;
      process.env[ENV_MAPPING.port] === undefined &#x26;&#x26; config.port === undefined ) {
    config.port = 80
  }

  // 2. initialize undocumented, internal-only default values

  // feature flags are mostly private settings for gating unreleased features
  // flags are set in the feature_flags.js file
  this.feature_flag = feature_flag.prerelease

  // set by environment
  this.newrelic_home = null
  // set by configuration file loader
  this.config_file_path = null
  // set by collector on handshake
  this.run_id = null
  this.application_id = null
  this.web_transactions_apdex = {}
  this.cross_process_id = null
  this.encoding_key = null
  this.obfuscatedId = null
  this.trusted_account_ids = null

  // how frequently harvester runs
  this.data_report_period = 60

  // this value is arbitrary
  this.max_trace_segments = 900

  // feature level of this account
  this.product_level = 0
  // product-level related
  this.collect_traces = true
  this.collect_errors = true

  // override options for utilization stats
  this.utilization.logical_processors = null
  this.utilization.total_ram_mib = null
  this.utilization.billing_hostname = null

  this.browser_monitoring.loader = &#x27;rum&#x27;
  this.browser_monitoring.loader_version = &#x27;&#x27;

  // Settings to play nice with DLPs (see NODE-1044).
  this.compressed_content_encoding = &#x22;deflate&#x22;  // Deflate or gzip
  this.simple_compression = false               // Disables subcomponent compression
  this.put_for_data_send = false                // Changes http verb for harvest


  // 3. override defaults with values from the loaded / passed configuration
  this._fromPassed(config)

  // 3.5. special values (only Azure environment APP_POOL_ID for now)
  this._fromSpecial()

  // 4. override config with environment variables
  this._fromEnvironment()

  // 5. clean up anything that requires postprocessing
  this._canonicalize()

  // 6. put the version in the config
  this.version = require(&#x27;../package.json&#x27;).version

  // 7. apply high security overrides
  if (this.high_security === true) {
    this._applyHighSecurity()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.getOrCreateInstance" id="apidoc.element.newrelic.config.getOrCreateInstance">
        function <span class="apidocSignatureSpan">newrelic.config.</span>getOrCreateInstance
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getOrCreateInstance() {
  if (_configInstance === null) {
    _configInstance = initialize()
  }
  return _configInstance
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error(message)
}

logger.debug(&#x22;Current working directory at module load is %s.&#x22;, process.cwd())
logger.debug(&#x22;Process title is %s.&#x22;, process.title)
logger.debug(&#x22;Application was invoked as %s.&#x22;, process.argv.join(&#x27; &#x27;))

var config = require(&#x27;./lib/config.js&#x27;).<span class="apidocCodeKeywordSpan">getOrCreateInstance</span>()

// Get the initialized logger as we likely have a bootstrap logger which
// just pipes to stdout.
logger = require(&#x27;./lib/logger.js&#x27;)

if (!config || !config.agent_enabled) {
  logger.info(&#x22;Module not enabled in configuration; not starting.&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.initialize" id="apidoc.element.newrelic.config.initialize">
        function <span class="apidocSignatureSpan">newrelic.config.</span>initialize
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initialize(config) {
<span class="apidocCodeCommentSpan">  /* When the logger is required here, it bootstraps itself and then
   * injects itself into this module&#x27;s closure via setLogger on the
   * instance of the logger it creates.
   */
</span>  logger = require(&#x27;./logger.js&#x27;)

  if (config) return new Config(config)

  if (isTruthular(process.env.NEW_RELIC_NO_CONFIG_FILE)) {
    config = new Config({})
    if (config.newrelic_home) delete config.newrelic_home
    return config
  }

  var filepath = _findConfigFile()
  if (!filepath) {
    _noConfigFile()
    return null
  }

  try {
    config = new Config(require(filepath).config)
    config.config_file_path = filepath
    logger.debug(&#x22;Using configuration file %s.&#x22;, filepath)

    config.validateFlags()

    return config
  } catch (error) {
    logger.error(error)

    throw new Error(
      &#x22;Unable to read configuration file &#x22; + filepath + &#x22;. A default\n&#x22; +
      &#x22;configuration file can be copied from &#x22; + DEFAULT_CONFIG_PATH + &#x22;\n&#x22; +
      &#x22;and renamed to &#x27;newrelic.js&#x27; in the directory from which you&#x27;ll be starting\n&#x22; +
      &#x22;your application.&#x22;
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.super_" id="apidoc.element.newrelic.config.super_">
        function <span class="apidocSignatureSpan">newrelic.config.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.config.prototype" id="apidoc.module.newrelic.config.prototype">module newrelic.config.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._alwaysUpdateIfChanged" id="apidoc.element.newrelic.config.prototype._alwaysUpdateIfChanged">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_alwaysUpdateIfChanged
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _alwaysUpdateIfChanged(json, key) {
  var value = json[key]
  if (value !== null &#x26;&#x26; value !== undefined &#x26;&#x26; this[key] !== value) {
    if (Array.isArray(value) &#x26;&#x26; Array.isArray(this[key])) {
      value.forEach(function cb_forEach(element) {
        if (this[key].indexOf(element) === -1) this[key].push(element)
      }, this)
    } else {
      this[key] = value
    }
    this.emit(key, value)
    logger.debug(&#x22;Configuration of %s was changed to %s by New Relic.&#x22;, key, value)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// handled by config.onConnect
case &#x27;high_security&#x27;:
  break

// always accept these settings
case &#x27;cross_process_id&#x27;:
case &#x27;encoding_key&#x27;:
  this.<span class="apidocCodeKeywordSpan">_alwaysUpdateIfChanged</span>(params, key)
  if (this.cross_process_id &#x26;&#x26; this.encoding_key) {
    this.obfuscatedId = hashes.obfuscateNameUsingKey(this.cross_process_id,
                                                     this.encoding_key)
  }
  break

// always accept these settings
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._applyHighSecurity" id="apidoc.element.newrelic.config.prototype._applyHighSecurity">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_applyHighSecurity
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _applyHighSecurity() {
  var config = this
  checkNode(&#x27;&#x27;, this, HIGH_SECURITY_SETTINGS)

  function checkNode(base, target, settings) {
    Object.keys(settings).forEach(checkKey.bind(null, base, target, settings))
  }

  function checkKey(base, target, settings, key) {
    var hsValue = settings[key]


    if (hsValue &#x26;&#x26; typeof hsValue === &#x27;object&#x27;) {
      if (typeof target[key] !== &#x27;object&#x27;) {
        logger.warn(
          &#x27;High Security Mode: %s should be an object, found %s&#x27;,
          key,
          target[key]
        )
        target[key] = {}
      }

      return checkNode(base + key + &#x27;.&#x27;, target[key], hsValue)
    }

    if (target[key] !== hsValue) {
      logger.warn(&#x27;High Security Mode: %s was set to %s, coercing to %s&#x27;,
                  key, target[key], hsValue)
      target[key] = hsValue
      config.emit(base + key, hsValue)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this._canonicalize()

 // 6. put the version in the config
 this.version = require(&#x27;../package.json&#x27;).version

 // 7. apply high security overrides
 if (this.high_security === true) {
   this.<span class="apidocCodeKeywordSpan">_applyHighSecurity</span>()
 }
}
util.inherits(Config, EventEmitter)

/**
* Because this module and logger depend on each other, the logger needs
* a way to inject the actual logger instance once it&#x27;s constructed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._canonicalize" id="apidoc.element.newrelic.config.prototype._canonicalize">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_canonicalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _canonicalize() {
  var codes = this.error_collector &#x26;&#x26; this.error_collector.ignore_status_codes
  if (codes) {
    this.error_collector.ignore_status_codes = codes.map(function cb_map(code) {
      return parseInt(code, 10)
    })
  }

  var logAliases = {
    &#x27;verbose&#x27;: &#x27;trace&#x27;,
    &#x27;debugging&#x27;: &#x27;debug&#x27;,
    &#x27;warning&#x27;: &#x27;warn&#x27;,
    &#x27;err&#x27;: &#x27;error&#x27;
  }
  var level = this.logging.level
  this.logging.level = logAliases[level] || level
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3.5. special values (only Azure environment APP_POOL_ID for now)
this._fromSpecial()

// 4. override config with environment variables
this._fromEnvironment()

// 5. clean up anything that requires postprocessing
this.<span class="apidocCodeKeywordSpan">_canonicalize</span>()

// 6. put the version in the config
this.version = require(&#x27;../package.json&#x27;).version

// 7. apply high security overrides
if (this.high_security === true) {
  this._applyHighSecurity()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._emitIfSet" id="apidoc.element.newrelic.config.prototype._emitIfSet">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_emitIfSet
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _emitIfSet(json, key) {
  var value = json[key]
  if (value !== null &#x26;&#x26; value !== undefined) this.emit(key, value)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break

// also accept these settings
case &#x27;url_rules&#x27;:
case &#x27;metric_name_rules&#x27;:
case &#x27;transaction_name_rules&#x27;:
case &#x27;transaction_segment_terms&#x27;:
  this.<span class="apidocCodeKeywordSpan">_emitIfSet</span>(params, key)
  break

// setting these can be disabled by ignore_server_configuration
case &#x27;ssl&#x27;:
case &#x27;apdex_t&#x27;:
case &#x27;web_transactions_apdex&#x27;:
case &#x27;data_report_period&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._fromEnvironment" id="apidoc.element.newrelic.config.prototype._fromEnvironment">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromEnvironment
        <span class="apidocSignatureSpan">(metadata, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fromEnvironment(metadata, data) {
  if (!metadata) metadata = ENV_MAPPING
  if (!data) data = this

  Object.keys(metadata).forEach(function cb_forEach(value) {
    // if it&#x27;s not in the config, it doesn&#x27;t exist
    if (data[value] === undefined) return

    var node = metadata[value]
    if (typeof node === &#x27;string&#x27;) {
      var setting = process.env[node]
      if (setting) {
        if (LIST_VARS.indexOf(node) &#x3e; -1) {
          data[value] = setting.split(&#x27;,&#x27;).map(function cb_map(k) {
            return k.trim()
          })
        } else if (OBJECT_LIST_VARS.indexOf(node) &#x3e; -1) {
          data[value] = fromObjectList(setting)
        } else if (BOOLEAN_VARS.indexOf(node) &#x3e; -1) {
          data[value] = isTruthular(setting)
        } else if (FLOAT_VARS.indexOf(node) &#x3e; -1) {
          data[value] = parseFloat(setting, 10)
        } else if (INT_VARS.indexOf(node) &#x3e; -1) {
          data[value] = parseInt(setting, 10)
        } else {
          data[value] = setting
        }
      }
    } else {
      // don&#x27;t crash if the mapping has config keys the current config doesn&#x27;t.
      if (!data[value]) data[value] = {}
      this._fromEnvironment(node, data[value])
    }
  }, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// 3. override defaults with values from the loaded / passed configuration
this._fromPassed(config)

// 3.5. special values (only Azure environment APP_POOL_ID for now)
this._fromSpecial()

// 4. override config with environment variables
this.<span class="apidocCodeKeywordSpan">_fromEnvironment</span>()

// 5. clean up anything that requires postprocessing
this._canonicalize()

// 6. put the version in the config
this.version = require(&#x27;../package.json&#x27;).version
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._fromPassed" id="apidoc.element.newrelic.config.prototype._fromPassed">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromPassed
        <span class="apidocSignatureSpan">(external, internal, arbitrary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fromPassed(external, internal, arbitrary) {
  if (!external) return
  if (!internal) internal = this

  Object.keys(external).forEach(function cb_forEach(key) {
    // if it&#x27;s not in the defaults, it doesn&#x27;t exist
    if (!arbitrary &#x26;&#x26; internal[key] === undefined) return

    try {
      var node = external[key]
    } catch (err) {
      logger.warn(&#x27;Error thrown on access of user config for key: %s&#x27;, key)
      return
    }

    if (Array.isArray(node)) {
      internal[key] = node
    } else if (typeof node === &#x27;object&#x27;) {
      // is top level and can have arbitrary keys
      if (internal === this &#x26;&#x26; HAS_ARBITRARY_KEYS.indexOf(key) !== -1) {
        this._fromPassed(node, internal[key], true)
      } else {
        this._fromPassed(node, internal[key], false)
      }
    } else {
      internal[key] = node
    }
  }, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Settings to play nice with DLPs (see NODE-1044).
this.compressed_content_encoding = &#x22;deflate&#x22;  // Deflate or gzip
this.simple_compression = false               // Disables subcomponent compression
this.put_for_data_send = false                // Changes http verb for harvest


// 3. override defaults with values from the loaded / passed configuration
this.<span class="apidocCodeKeywordSpan">_fromPassed</span>(config)

// 3.5. special values (only Azure environment APP_POOL_ID for now)
this._fromSpecial()

// 4. override config with environment variables
this._fromEnvironment()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._fromServer" id="apidoc.element.newrelic.config.prototype._fromServer">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromServer
        <span class="apidocSignatureSpan">(params, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fromServer(params, key) {
  switch (key) {
    // handled by the connection
    case &#x27;messages&#x27;:
      break

    // *sigh* Xzibit, etc.
    case &#x27;agent_config&#x27;:
      this.onConnect(params[key], true)
      break

    // if it&#x27;s undefined or null, so be it
    case &#x27;agent_run_id&#x27;:
      this.run_id = params.agent_run_id
      break

    // handled by config.onConnect
    case &#x27;high_security&#x27;:
      break

    // always accept these settings
    case &#x27;cross_process_id&#x27;:
    case &#x27;encoding_key&#x27;:
      this._alwaysUpdateIfChanged(params, key)
      if (this.cross_process_id &#x26;&#x26; this.encoding_key) {
        this.obfuscatedId = hashes.obfuscateNameUsingKey(this.cross_process_id,
                                                         this.encoding_key)
      }
      break

    // always accept these settings
    case &#x27;collect_traces&#x27;:
    case &#x27;collect_errors&#x27;:
    case &#x27;product_level&#x27;:
    case &#x27;application_id&#x27;:
    case &#x27;trusted_account_ids&#x27;:
      this._alwaysUpdateIfChanged(params, key)
      break

    case &#x27;collect_error_events&#x27;:
      if (params.collect_error_events === false) {
        this._updateNestedIfChanged(
          params,
          this.error_collector,
          key,
          &#x27;capture_events&#x27;
        )
      }
      break

    // also accept these settings
    case &#x27;url_rules&#x27;:
    case &#x27;metric_name_rules&#x27;:
    case &#x27;transaction_name_rules&#x27;:
    case &#x27;transaction_segment_terms&#x27;:
      this._emitIfSet(params, key)
      break

    // setting these can be disabled by ignore_server_configuration
    case &#x27;ssl&#x27;:
    case &#x27;apdex_t&#x27;:
    case &#x27;web_transactions_apdex&#x27;:
    case &#x27;data_report_period&#x27;:
    case &#x27;ignored_params&#x27;:
      this._updateIfChanged(params, key)
      break
    case &#x27;transaction_tracer.enabled&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_tracer,
        &#x27;transaction_tracer.enabled&#x27;,
        &#x27;enabled&#x27;
      )
      break
    case &#x27;transaction_tracer.transaction_threshold&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_tracer,
        &#x27;transaction_tracer.transaction_threshold&#x27;,
        &#x27;transaction_threshold&#x27;
      )
      break
    case &#x27;error_collector.enabled&#x27;:
      this._updateNestedIfChanged(
        params,
        this.error_collector,
        &#x27;error_collector.enabled&#x27;,
        &#x27;enabled&#x27;
      )
      break
    case &#x27;error_collector.ignore_status_codes&#x27;:
      this._updateNestedIfChanged(
        params,
        this.error_collector,
        &#x27;error_collector.ignore_status_codes&#x27;,
        &#x27;ignore_status_codes&#x27;
      )
      this._canonicalize()
      break

    case &#x27;error_collector.capture_events&#x27;:
      this._updateNestedIfChanged(
        params,
        this.error_collector,
        &#x27;error_collector.capture_events&#x27;,
        &#x27;capture_events&#x27;
      )
      break

    case &#x27;error_collector.max_event_samples_stored&#x27;:
      this._updateNestedIfChanged(
        params,
        this.error_collector,
        &#x27;error_collector.max_event_samples_stored&#x27;,
        &#x27;max_event_samples_stored&#x27;
      )
      break

    case &#x27;collect_analytics_events&#x27;:
      // never enable from server-side
      // but we allow the server to disable
      if (params.collect_analytics_events === false)
        this.transaction_events.enabled = false
      break

    case &#x27;collect_custom_events&#x27;:
      // never enable from server-side
      // but we allow the server to disable
      if (params.collect_custom_events === false)
        this.custom_insights_events.enabled = false
      break

    case &#x27;transaction_events.max_samples_stored&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_events,
        key,
        &#x27;max_samples_stored&#x27;
      )
      break

    case &#x27;transaction_events.max_samples_per_minute&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_events,
        key,
        &#x27;max_samples_per_minute&#x27;
      )
      break

    case &#x27;transaction_events.enabled&#x27;:
      this._updateNestedIfChanged(
        params,
        this.transaction_events,
        key,
        &#x27;enabled&#x27;
      ) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.agent_enabled = false
   this.emit(&#x27;agent_enabled&#x27;, false)
   return
 }
 if (Object.keys(json).length === 0) return

 Object.keys(json).forEach(function cb_forEach(key) {
   this.<span class="apidocCodeKeywordSpan">_fromServer</span>(json, key)
 }, this)

 this.emit(&#x27;change&#x27;, this)
}

/**
* The guts of the logic about how to deal with server-side configuration.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._fromSpecial" id="apidoc.element.newrelic.config.prototype._fromSpecial">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_fromSpecial
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _fromSpecial() {
  var name = this.app_name
  if (name === null || name === undefined || name === &#x27;&#x27; ||
      (Array.isArray(name) &#x26;&#x26; name.length === 0)) {
    var azureName = process.env[AZURE_APP_NAME]
    if (azureName) this.app_name = azureName.split(&#x27;,&#x27;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.put_for_data_send = false                // Changes http verb for harvest


// 3. override defaults with values from the loaded / passed configuration
this._fromPassed(config)

// 3.5. special values (only Azure environment APP_POOL_ID for now)
this.<span class="apidocCodeKeywordSpan">_fromSpecial</span>()

// 4. override config with environment variables
this._fromEnvironment()

// 5. clean up anything that requires postprocessing
this._canonicalize()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._updateIfChanged" id="apidoc.element.newrelic.config.prototype._updateIfChanged">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateIfChanged
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _updateIfChanged(json, key) {
  this._updateNestedIfChanged(json, this, key, key)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// setting these can be disabled by ignore_server_configuration
case &#x27;ssl&#x27;:
case &#x27;apdex_t&#x27;:
case &#x27;web_transactions_apdex&#x27;:
case &#x27;data_report_period&#x27;:
case &#x27;ignored_params&#x27;:
  this.<span class="apidocCodeKeywordSpan">_updateIfChanged</span>(params, key)
  break
case &#x27;transaction_tracer.enabled&#x27;:
  this._updateNestedIfChanged(
    params,
    this.transaction_tracer,
    &#x27;transaction_tracer.enabled&#x27;,
    &#x27;enabled&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._updateNestedIfChanged" id="apidoc.element.newrelic.config.prototype._updateNestedIfChanged">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateNestedIfChanged
        <span class="apidocSignatureSpan">(remote, local, remoteKey, localKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _updateNestedIfChanged(remote, local, remoteKey, localKey) {
  if (this.ignore_server_configuration) return this.logDisabled(remote, remoteKey)
  // if high-sec mode is enabled, we do not accept server changes to high-sec
  if (this.high_security &#x26;&#x26; HIGH_SECURITY_KEYS.indexOf(localKey) !== -1) {
    return this.logDisabled(remote, remoteKey)
  }
  return this._updateNestedIfChangedRaw(remote, local, remoteKey, localKey)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case &#x27;application_id&#x27;:
case &#x27;trusted_account_ids&#x27;:
  this._alwaysUpdateIfChanged(params, key)
  break

case &#x27;collect_error_events&#x27;:
  if (params.collect_error_events === false) {
    this.<span class="apidocCodeKeywordSpan">_updateNestedIfChanged</span>(
      params,
      this.error_collector,
      key,
      &#x27;capture_events&#x27;
    )
  }
  break
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype._updateNestedIfChangedRaw" id="apidoc.element.newrelic.config.prototype._updateNestedIfChangedRaw">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>_updateNestedIfChangedRaw
        <span class="apidocSignatureSpan">( remote, local, remoteKey, localKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _updateNestedIfChangedRaw( remote, local, remoteKey, localKey) {
  var value = remote[remoteKey]
  if (value !== null &#x26;&#x26; value !== undefined &#x26;&#x26; local[localKey] !== value) {
    if (Array.isArray(value) &#x26;&#x26; Array.isArray(local[localKey])) {
      value.forEach(function cb_forEach(element) {
        if (local[localKey].indexOf(element) === -1) local[localKey].push(element)
      })
    } else {
      local[localKey] = value
    }
    this.emit(remoteKey, value)
    logger.debug(&#x22;Configuration of %s was changed to %s by New Relic.&#x22;, remoteKey, value)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// and the api.getRUMHeader() method
case &#x27;js_agent_file&#x27;:
case &#x27;js_agent_loader_file&#x27;:
case &#x27;beacon&#x27;:
case &#x27;error_beacon&#x27;:
case &#x27;browser_key&#x27;:
case &#x27;js_agent_loader&#x27;:
  this.<span class="apidocCodeKeywordSpan">_updateNestedIfChangedRaw</span>(
    params,
    this.browser_monitoring,
    key,
    key
  )
  break
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.applications" id="apidoc.element.newrelic.config.prototype.applications">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>applications
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applications() {
  var apps = this.app_name

  if (Array.isArray(apps) &#x26;&#x26; apps.length &#x3e; 0) {
    return apps
  }

  if (apps &#x26;&#x26; typeof apps === &#x27;string&#x27;) {
    return [apps]
  }

  return []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * The agent must be a singleton, or else module loading will be patched
 * multiple times, with undefined results. New Relic&#x27;s instrumentation
 * can&#x27;t be enabled or disabled without an application restart.
 */
var Agent = require(&#x27;./lib/agent.js&#x27;)
agent = new Agent(config)
var appNames = agent.config.<span class="apidocCodeKeywordSpan">applications</span>()

if (config.logging.diagnostics) {
  logger.warn(
    &#x27;Diagnostics logging is enabled, this may cause significant overhead.&#x27;
  )
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.clearDisplayHostCache" id="apidoc.element.newrelic.config.prototype.clearDisplayHostCache">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>clearDisplayHostCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearDisplayHostCache() {
  this.getDisplayHost = getDisplayHost
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.clearHostnameCache" id="apidoc.element.newrelic.config.prototype.clearHostnameCache">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>clearHostnameCache
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearHostnameCache() {
  this.getHostnameSafe = getHostnameSafe
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.getDisplayHost" id="apidoc.element.newrelic.config.prototype.getDisplayHost">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getDisplayHost
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDisplayHost() {
  var _displayHost
  this.getDisplayHost = function getCachedDisplayHost() {
    return _displayHost
  }
  if (this.process_host.display_name === &#x27;&#x27;) {
    _displayHost = this.getHostnameSafe()
    return _displayHost
  }
  var stringBuffer = new Buffer(this.process_host.display_name, &#x27;utf8&#x27;)
  var numBytes = stringBuffer.length

  if (numBytes &#x3e; 255) {
    logger.warn(&#x27;Custom host display name must be less than 255 bytes&#x27;)
    _displayHost = this.getHostnameSafe()
    return _displayHost
  }

  _displayHost = this.process_host.display_name
  return _displayHost
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.getHostnameSafe" id="apidoc.element.newrelic.config.prototype.getHostnameSafe">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getHostnameSafe
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHostnameSafe() {
  var _hostname
  this.getHostnameSafe = function getCachedHostname() {
    return _hostname
  }
  try {
    _hostname = os.hostname()
    return _hostname
  } catch (e) {
    var addresses = this.getIPAddresses()

    if (this.process_host.ipv_preference === &#x27;6&#x27; &#x26;&#x26; addresses.ipv6) {
      _hostname = addresses.ipv6
    } else if (addresses.ipv4) {
      logger.info(&#x27;Defaulting to ipv4 address for host name&#x27;)
      _hostname = addresses.ipv4
    } else if (addresses.ipv6) {
      logger.info(&#x27;Defaulting to ipv6 address for host name&#x27;)
      _hostname = addresses.ipv6
    } else {
      logger.info(&#x27;No hostname, ipv4, or ipv6 address found for machine&#x27;)
      _hostname = &#x27;UNKNOWN_BOX&#x27;
    }

    return _hostname
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function getDisplayHost() {
var _displayHost
this.getDisplayHost = function getCachedDisplayHost() {
  return _displayHost
}
if (this.process_host.display_name === &#x27;&#x27;) {
  _displayHost = this.<span class="apidocCodeKeywordSpan">getHostnameSafe</span>()
  return _displayHost
}
var stringBuffer = new Buffer(this.process_host.display_name, &#x27;utf8&#x27;)
var numBytes = stringBuffer.length

if (numBytes &#x3e; 255) {
  logger.warn(&#x27;Custom host display name must be less than 255 bytes&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.getIPAddresses" id="apidoc.element.newrelic.config.prototype.getIPAddresses">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>getIPAddresses
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getIPAddresses() {
  var addresses = {}
  var interfaces = os.networkInterfaces()

  for (var interfaceKey in interfaces) {
    if (interfaceKey.match(/^lo/)) continue

    var interfaceDescriptions = interfaces[interfaceKey]
    for (var i = 0; i &#x3c; interfaceDescriptions.length; i++) {
      var description = interfaceDescriptions[i]
      var family = description.family.toLowerCase()
      addresses[family] = description.address
    }
  }
  return addresses
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.getHostnameSafe = function getCachedHostname() {
return _hostname
  }
  try {
_hostname = os.hostname()
return _hostname
  } catch (e) {
var addresses = this.<span class="apidocCodeKeywordSpan">getIPAddresses</span>()

if (this.process_host.ipv_preference === &#x27;6&#x27; &#x26;&#x26; addresses.ipv6) {
  _hostname = addresses.ipv6
} else if (addresses.ipv4) {
  logger.info(&#x27;Defaulting to ipv4 address for host name&#x27;)
  _hostname = addresses.ipv4
} else if (addresses.ipv6) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.logDisabled" id="apidoc.element.newrelic.config.prototype.logDisabled">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logDisabled
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function logDisabled(json, key) {
  var value = json[key]
  if (value !== null &#x26;&#x26; value !== undefined) {
    logger.debug(
      &#x22;Server-side configuration of %s is currently disabled by local configuration. &#x22; +
      &#x22;(Server sent value of %s.)&#x22;,
      key,
      value
    )
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} local     A portion of this configuration object.
 * @param {string} remoteKey The name sent by New Relic.
 * @param {string} localKey  The local name.
 */
Config.prototype._updateNestedIfChanged = _updateNestedIfChanged

function _updateNestedIfChanged(remote, local, remoteKey, localKey) {
  if (this.ignore_server_configuration) return this.<span class="apidocCodeKeywordSpan">logDisabled</span>(remote, remoteKey)
  // if high-sec mode is enabled, we do not accept server changes to high-sec
  if (this.high_security &#x26;&#x26; HIGH_SECURITY_KEYS.indexOf(localKey) !== -1) {
    return this.logDisabled(remote, remoteKey)
  }
  return this._updateNestedIfChangedRaw(remote, local, remoteKey, localKey)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.logUnknown" id="apidoc.element.newrelic.config.prototype.logUnknown">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logUnknown
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function logUnknown(json, key) {
  var value = json[key]
  logger.debug(
    &#x22;New Relic sent unknown configuration parameter %s with value %s.&#x22;,
    key,
    value
  )
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   case &#x27;transaction_tracer.record_sql&#x27;:
   case &#x27;slow_sql.enabled&#x27;:
   case &#x27;rum.load_episodes_file&#x27;:
     this.logUnsupported(params, key)
     break

   default:
     this.<span class="apidocCodeKeywordSpan">logUnknown</span>(params, key)
 }
}

/**
* Change a value sent by the collector if and only if it&#x27;s different from the
* value we already have. Emit an event with the key name and the new value,
* and log that the value has changed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.logUnsupported" id="apidoc.element.newrelic.config.prototype.logUnsupported">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>logUnsupported
        <span class="apidocSignatureSpan">(json, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function logUnsupported(json, key) {
  var flavor
  if (this.ignore_server_configuration) {
    flavor = &#x22;ignored&#x22;
  } else {
    flavor = &#x22;not supported by the Node.js agent&#x22;
  }

  var value = json[key]
  if (value !== null &#x26;&#x26; value !== undefined) {
    logger.debug(
      &#x22;Server-side configuration of %s is currently %s. (Server sent value of %s.)&#x22;,
      key,
      flavor,
      value
    )
    this.emit(key, value)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case &#x27;sampling_rate&#x27;:
    case &#x27;episodes_file&#x27;:
    case &#x27;episodes_url&#x27;:
    case &#x27;cross_application_tracing&#x27;:
    case &#x27;transaction_tracer.record_sql&#x27;:
    case &#x27;slow_sql.enabled&#x27;:
    case &#x27;rum.load_episodes_file&#x27;:
      this.<span class="apidocCodeKeywordSpan">logUnsupported</span>(params, key)
      break

    default:
      this.logUnknown(params, key)
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.measureInternal" id="apidoc.element.newrelic.config.prototype.measureInternal">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>measureInternal
        <span class="apidocSignatureSpan">(suffix, duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function measureInternal(suffix, duration) {
  if (this.debug.supportability) {
    var internal = this.debug.supportability
    internal.measureMilliseconds(NAMES.SUPPORTABILITY.PREFIX + suffix, null, duration)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.onConnect" id="apidoc.element.newrelic.config.prototype.onConnect">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>onConnect
        <span class="apidocSignatureSpan">(json, recursion)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onConnect(json, recursion) {
  json = json || {}
  if (this.high_security === true &#x26;&#x26; recursion !== true &#x26;&#x26; json.high_security !== true) {
    this.agent_enabled = false
    this.emit(&#x27;agent_enabled&#x27;, false)
    return
  }
  if (Object.keys(json).length === 0) return

  Object.keys(json).forEach(function cb_forEach(key) {
    this._fromServer(json, key)
  }, this)

  this.emit(&#x27;change&#x27;, this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* decoupled.
*
* @param {object} configuration New config JSON from the collector.
*/
Agent.prototype.reconfigure = function reconfigure(configuration) {
 if (!configuration) throw new TypeError(&#x22;must pass configuration&#x22;)

 this.config.<span class="apidocCodeKeywordSpan">onConnect</span>(configuration)
}

/**
* Make it easier to determine what state the agent thinks it&#x27;s in (needed
* for a few tests, but fragile).
*
* FIXME: remove the need for this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.publicSettings" id="apidoc.element.newrelic.config.prototype.publicSettings">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>publicSettings
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publicSettings() {
  var settings = {}

  for (var key in this) {
    if (this.hasOwnProperty(key)) {
      var item = this[key]

      if (REDACT_BEFORE_SEND.indexOf(key) &#x3e; -1) {
        item = &#x27;****&#x27;
      }

      if (REMOVE_BEFORE_SEND.indexOf(key) === -1) {
        settings[key] = item
      }
    }
  }

  // Agent-side setting is &#x27;enable&#x27;, but collector-side setting is
  // &#x27;auto_instrument&#x27;. Send both values up.
  settings.browser_monitoring.auto_instrument = settings.browser_monitoring.enable

  // Remove simple circular references
  parse(stringifySync(settings), function cb_parse(err, settingsCopy) {
    if (err === null) {
      settings = flatten({}, &#x27;&#x27;, settingsCopy)
    } else {
      logger.warn(&#x27;Error while creating deep copy: %s&#x27;, err)
    }
  })

  return settings
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.setLogger" id="apidoc.element.newrelic.config.prototype.setLogger">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>setLogger
        <span class="apidocSignatureSpan">(bootstrapped)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLogger(bootstrapped) {
  logger = bootstrapped
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          /* eslint-enable no-console */
        })
    }
    module.exports.pipe(stream)
  }

  // now tell the config module to switch to the real logger
  config.<span class="apidocCodeKeywordSpan">setLogger</span>(module.exports)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.config.prototype.validateFlags" id="apidoc.element.newrelic.config.prototype.validateFlags">
        function <span class="apidocSignatureSpan">newrelic.config.prototype.</span>validateFlags
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function validateFlags() {
  Object.keys(this.feature_flag).forEach(function cb_forEach(key) {
    if (feature_flag.released.indexOf(key) &#x3e; -1) {
      logger.warn(&#x27;Feature flag &#x27; + key + &#x27; has been released&#x27;)
    }
    if (feature_flag.unreleased.indexOf(key) &#x3e; -1) {
      logger.warn(&#x27;Feature flag &#x27; + key + &#x27; has been deprecated&#x27;)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  try {
config = new Config(require(filepath).config)
config.config_file_path = filepath
logger.debug(&#x22;Using configuration file %s.&#x22;, filepath)

config.<span class="apidocCodeKeywordSpan">validateFlags</span>()

return config
  } catch (error) {
logger.error(error)

throw new Error(
  &#x22;Unable to read configuration file &#x22; + filepath + &#x22;. A default\n&#x22; +
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.environment" id="apidoc.module.newrelic.environment">module newrelic.environment</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.environment.clearDispatcher" id="apidoc.element.newrelic.environment.clearDispatcher">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>clearDispatcher
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearDispatcher() {
  clearSetting(&#x27;Dispatcher&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.clearFramework" id="apidoc.element.newrelic.environment.clearFramework">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>clearFramework
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clearFramework() {
  clearSetting(&#x27;Framework&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.get" id="apidoc.element.newrelic.environment.get">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSetting(name) {
  return settings[name] || []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var newrelic = require(&#x27;newrelic&#x27;);
var app = require(&#x27;express&#x27;)();

// In Express, this lets you call newrelic from within a template.
app.locals.newrelic = newrelic;

app.<span class="apidocCodeKeywordSpan">get</span>(&#x27;/user/:id&#x27;, function (req, res) {
  res.render(&#x27;user&#x27;);
});
app.listen(process.env.PORT);
```

*layout.jade:*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.listPackages" id="apidoc.element.newrelic.environment.listPackages">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>listPackages
        <span class="apidocSignatureSpan">(root, packages)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listPackages(root, packages) {
  if (!packages) {
    packages = []
  }

  try {
    fs.readdirSync(root).forEach(function forEachReadDirSync(dir) {
      // Skip npm&#x27;s binary directory where it stores executables.
      if (dir === &#x27;.bin&#x27;) {
        return
      }

      var version = null
      try {
        var pck = path.resolve(root, dir, &#x27;package.json&#x27;)
        version = JSON.parse(fs.readFileSync(pck)).version
      } catch (e) {
        logger.debug(&#x27;Could not load %s for environment scan&#x27;, pck || dir)
      }

      packages.push([dir, version || &#x27;&#x3c;unknown&#x3e;&#x27;])
    })
  } catch (e) {
    logger.trace(e, &#x27;Failed to list packages in %s&#x27;, root)
  }

  return packages
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.refresh" id="apidoc.element.newrelic.environment.refresh">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>refresh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function refresh() {
  // gather persisted settings
  var framework = getSetting(&#x27;Framework&#x27;)
  var dispatcher = getSetting(&#x27;Dispatcher&#x27;)
  var packages = getSetting(&#x27;Packages&#x27;)
  var dependencies = getSetting(&#x27;Dependencies&#x27;)

  // clearing and rebuilding a global variable
  settings = {}
  // add persisted settings
  if (framework.length) {
    framework.forEach(function addFrameworks(fw) {
      addSetting(&#x27;Framework&#x27;, fw)
    })
  }

  if (dispatcher.length) {
    dispatcher.forEach(function addDispatchers(d) {
      addSetting(&#x27;Dispatcher&#x27;, d)
    })
  }

  gatherEnv()
  remapConfigSettings()

  if (packages.length &#x26;&#x26; dependencies.length) {
    settings.Packages = packages
    settings.Dependencies = dependencies
  } else {
    findPackages()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.setDispatcher" id="apidoc.element.newrelic.environment.setDispatcher">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>setDispatcher
        <span class="apidocSignatureSpan">(dispatcher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setDispatcher(dispatcher) {
  addSetting(&#x27;Dispatcher&#x27;, dispatcher)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.setFramework" id="apidoc.element.newrelic.environment.setFramework">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>setFramework
        <span class="apidocSignatureSpan">(framework)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setFramework(framework) {
  addSetting(&#x27;Framework&#x27;, framework)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.environment.toJSON" id="apidoc.element.newrelic.environment.toJSON">
        function <span class="apidocSignatureSpan">newrelic.environment.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toJSON() {
  // TODO:  Do not refresh when JSON-ifying. This takes a _long_ time and blocks
  //        the event loop. Currently, removing this causes a couple of tests to
  //        fail (ironically from timing out).
  refresh()
  var items = []
  Object.keys(settings).forEach(function settingKeysForEach(key) {
    settings[key].forEach(function settingsValuesForEach(setting) {
      items.push([key, setting])
    })
  })

  return items
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.createMetrics(this.metrics)

this._processCustomEvents()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.<span class="apidocCodeKeywordSpan">toJSON</span>().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
  return process.nextTick(callback)
}

var metrics = this.metrics
var beginSeconds = metrics.started * FROM_MILLIS
var endSeconds = Date.now() * FROM_MILLIS
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.reservoir" id="apidoc.module.newrelic.reservoir">module newrelic.reservoir</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.reservoir.reservoir" id="apidoc.element.newrelic.reservoir.reservoir">
        function <span class="apidocSignatureSpan">newrelic.</span>reservoir
        <span class="apidocSignatureSpan">(limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reservoir(limit) {
  this.limit = limit || 10
  this.seen = 0
  this._data = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.reservoir.prototype" id="apidoc.module.newrelic.reservoir.prototype">module newrelic.reservoir.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.add" id="apidoc.element.newrelic.reservoir.prototype.add">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>add
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(item) {
  if (this.seen &#x3c; this.limit) {
    this._data.push(item)
  } else {
    // Take a number between 0 and n + 1, drop the element at that index
    // from the array. If the element to drop is the (n + 1)th, the new item is
    // not added, otherwise the new item replaces the item that was
    // dropped.
    // This is effectively the same as adding the new element to the
    // end, swapping the last element (the new one) with a random element in the list,
    // then dropping the last element (the potentially swapped one) in the list.
    var toReplace = Math.floor(Math.random() * (this.seen + 2))
    if (toReplace &#x3c; this.limit) this._data[toReplace] = item
  }
  this.seen++
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 var instrinics = {
   type: eventType,
   timestamp: Date.now()
 }

 this.agent.customEvents.<span class="apidocCodeKeywordSpan">add</span>([instrinics, attributes])
}

/**
* Shuts down the agent.
*
* @param {object}  [options]                           object with shut down options
* @param {boolean} [options.collectPendingData=false]  If true, the agent will send any
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.merge" id="apidoc.element.newrelic.reservoir.prototype.merge">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>merge
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(items) {
  if (!items || !items.length) return
  if (items === this._data) return
  for (var i = 0; i &#x3c; items.length; i++) {
    this.add(items[i])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (typeof value.totalExclusive === &#x27;number&#x27;) {
  stats.totalExclusive = value.totalExclusive
} else {
  stats.totalExclusive = value.total
}

metric.<span class="apidocCodeKeywordSpan">merge</span>(stats)
}

API.prototype.incrementMetric = function incrementMetric(name, value) {
var metric = this.agent.metrics.getOrCreateMetric(
  NAMES.SUPPORTABILITY.API + &#x27;/incrementMetric&#x27;
)
metric.incrementCallCount()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.overflow" id="apidoc.element.newrelic.reservoir.prototype.overflow">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>overflow
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function overflow() {
  var diff = this.seen - this.limit
  return diff &#x3e;= 0 ? diff : 0
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Bail out if there are no events
  if (this.customEventsPool.length === 0) {
return
  }

  if (this.config.custom_insights_events.enabled) {
// Record their values
var diff = this.customEvents.<span class="apidocCodeKeywordSpan">overflow</span>()
dropped.incrementCallCount(diff)
seen.incrementCallCount(this.customEvents.seen)
sent.incrementCallCount(this.customEvents.seen - diff)

// Log any warnings about dropping events
if (diff) {
  logger.warn(&#x27;Dropped %s custom events out of %s.&#x27;, diff, this.customEvents.seen)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.setLimit" id="apidoc.element.newrelic.reservoir.prototype.setLimit">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>setLimit
        <span class="apidocSignatureSpan">(newLimit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setLimit(newLimit) {
  this.limit = newLimit
  if (this._data.length &#x3e; newLimit) {
    this._data = this._data.slice(0, newLimit)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Builds all of the sub-properties of the agent that rely on configurations.
 */
Agent.prototype.reset = function reset() {
// Insights events.
if (!this.events) {
  this.events = new Reservoir()
}
this.events.<span class="apidocCodeKeywordSpan">setLimit</span>(this.config.transaction_events.max_samples_per_minute)
if (!this.customEvents) {
  this.customEvents = new Reservoir()
}
this.customEvents.setLimit(this.config.custom_insights_events.max_samples_stored)

// Error tracing.
if (!this.errors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.reservoir.prototype.toArray" id="apidoc.element.newrelic.reservoir.prototype.toArray">
        function <span class="apidocSignatureSpan">newrelic.reservoir.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toArray() {
  return this._data
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * This function takes the custom events reservoir, gets stats on it for
 * metric purposes, then instantiates a new custom events reservoir. This is
 * so the stats are consistent with what actually gets pushed by the later
 * call to _sendCustomEvents.
 */
Agent.prototype._processCustomEvents = function _processCustomEvents() {
this.customEventsPool = this.customEvents.<span class="apidocCodeKeywordSpan">toArray</span>()

// Create the metrics so they are at least set to 0
var dropped = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.DROPPED)
var seen = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SEEN)
var sent = this.metrics.getOrCreateMetric(NAMES.CUSTOM_EVENTS.SENT)

// Bail out if there are no events
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.sampler" id="apidoc.module.newrelic.sampler">module newrelic.sampler</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.sampler.checkEvents" id="apidoc.element.newrelic.sampler.checkEvents">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>checkEvents
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function checkEvents(agent) {
  return function eventSampler() {
    var timer = new Timer()
    timer.begin()
    setTimeout(recordQueueTime.bind(null, agent, timer), 0)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.sampleCpu" id="apidoc.element.newrelic.sampler.sampleCpu">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleCpu
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleCpu(agent) {
  var lastSample
  var recordCPU = generateCPUMetricRecorder(agent)
  return function cpuSampler() {
    var cpuSample = getCpuSample(lastSample)
    lastSample = getCpuSample()

    if (lastSample == null) {
      return
    }

    recordCPU(cpuSample.user / MICROS, cpuSample.system / MICROS)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.sampleGc" id="apidoc.element.newrelic.sampler.sampleGc">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleGc
        <span class="apidocSignatureSpan">(agent, nativeMetrics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleGc(agent, nativeMetrics) {
  // Hook into the stats event to accumulate total pause time and record per-run
  // pause time metric.
  nativeMetrics.on(&#x27;gc&#x27;, function onGCStatsEvent(stats) {
    var duration = stats.duration / NANOS
    recordValue(agent, NAMES.GC.PAUSE_TIME, duration)

    if (stats.type) {
      recordValue(agent, NAMES.GC.PREFIX + stats.type, duration)
    } else {
      logger.debug(stats, &#x27;Unknown GC type %j&#x27;, stats.typeId)
    }
  })

  return function gcSampler() {
    // NOOP?
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.sampleLoop" id="apidoc.element.newrelic.sampler.sampleLoop">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleLoop
        <span class="apidocSignatureSpan">(agent, nativeMetrics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleLoop(agent, nativeMetrics) {
  return function loopSampler() {
    var loopMetrics = nativeMetrics.getLoopMetrics()

    // convert from microseconds to seconds
    loopMetrics.usage.min = loopMetrics.usage.min / MICROS
    loopMetrics.usage.max = loopMetrics.usage.max / MICROS
    loopMetrics.usage.total = loopMetrics.usage.total / MICROS
    loopMetrics.usage.sumOfSquares = loopMetrics.usage.sumOfSquares / (MICROS * MICROS)

    recordCompleteMetric(agent, NAMES.LOOP.USAGE, loopMetrics.usage)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.sampleMemory" id="apidoc.element.newrelic.sampler.sampleMemory">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>sampleMemory
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sampleMemory(agent) {
  return function memorySampler() {
    try {
      var mem = process.memoryUsage()
      agent.metrics.measureBytes(NAMES.MEMORY.PHYSICAL, mem.rss)
      agent.metrics.measureBytes(NAMES.MEMORY.USED_HEAP, mem.heapUsed)
      agent.metrics.measureBytes(NAMES.MEMORY.MAX_HEAP, mem.heapTotal)
      agent.metrics.measureBytes(NAMES.MEMORY.FREE_HEAP, mem.heapTotal - mem.heapUsed)
      agent.metrics.measureBytes(NAMES.MEMORY.USED_NONHEAP, mem.rss - mem.heapTotal)
      logger.trace(&#x27;Recorded memory:&#x27;, mem)
    } catch (e) {
      logger.debug(&#x27;Could not record memory usage&#x27;, e)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.start" id="apidoc.element.newrelic.sampler.start">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>start
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function start(agent) {
  samplers.push(new Sampler(sampleMemory(agent), 5 * MILLIS))
  samplers.push(new Sampler(checkEvents(agent), SAMPLE_INTERVAL))
  var metricFeatureFlag = agent.config.feature_flag.native_metrics

  // This requires a native module which may have failed to build.
  if (!this.nativeMetrics) {
    if (metricFeatureFlag) {
      try {
        this.nativeMetrics = require(&#x27;@newrelic/native-metrics&#x27;)({
          timeout: SAMPLE_INTERVAL
        })
      } catch (err) {
        logger.info(
          {error: {message: err.message, stack: err.stack}},
          &#x27;Not adding native metric sampler.&#x27;
        )
        agent.metrics.getOrCreateMetric(
          NAMES.SUPPORTABILITY.DEPENDENCIES + &#x27;/NoNativeMetricsModule&#x27;
        ).incrementCallCount()
      }
    } else {
      logger.info(&#x27;Feature flag for native metrics is false&#x27;)
    }
  }

  if (this.nativeMetrics) {
    if (!this.nativeMetrics.bound) {
      this.nativeMetrics.bind(SAMPLE_INTERVAL)
    }

    // Add GC events if available.
    if (this.nativeMetrics.gcEnabled) {
      samplers.push(new Sampler(sampleGc(agent, this.nativeMetrics), SAMPLE_INTERVAL))
    }

    // Add loop metrics if available.
    if (this.nativeMetrics.loopEnabled) {
      samplers.push(new Sampler(sampleLoop(agent, this.nativeMetrics), SAMPLE_INTERVAL))
    }
  }

  // Add CPU sampling using the built-in data if available, otherwise pulling
  // from the native module.
  if (process.cpuUsage) { // introduced in 6.1.0
    samplers.push(new Sampler(sampleCpu(agent), SAMPLE_INTERVAL))
  } else if (this.nativeMetrics &#x26;&#x26; this.nativeMetrics.usageEnabled) {
    samplers.push(
      new Sampler(sampleCpuNative(agent, this.nativeMetrics), SAMPLE_INTERVAL)
    )
  } else {
    logger.debug(&#x27;Not adding CPU metric sampler.&#x27;)
  }

  sampler.state = &#x27;running&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error(message)
      }

      var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
      shimmer.patchModule(agent)
      shimmer.bootstrapInstrumentation(agent)

      agent.<span class="apidocCodeKeywordSpan">start</span>(function cb_start(error) {
if (!error) {
  return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
}

var errorMessage = &#x22;New Relic for Node.js halted startup due to an error:&#x22;
logger.error(error, errorMessage)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.sampler.stop" id="apidoc.element.newrelic.sampler.stop">
        function <span class="apidocSignatureSpan">newrelic.sampler.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stop() {
  samplers.forEach(function forEachSampler(s) {
    s.stop()
  })
  samplers = []
  sampler.state = &#x27;stopped&#x27;
  if (this.nativeMetrics) {
    this.nativeMetrics.unbind()
    this.nativeMetrics.removeAllListeners()

    // Setting this.nativeMetrics to null allows us to config a new
    // nativeMetrics object after the first start call.
    this.nativeMetrics = null
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function cb_harvest(error) {
  if (error) {
    logger.error(
      error,
      &#x27;An error occurred while running last harvest before shutdown.&#x27;
    )
  }
  agent.<span class="apidocCodeKeywordSpan">stop</span>(callback)
}

if (options &#x26;&#x26; options.collectPendingData &#x26;&#x26; agent._state !== &#x27;started&#x27;) {
  if (typeof options.timeout === &#x27;number&#x27;) {
    var shutdownTimeout = setTimeout(function shutdownTimeout() {
      agent.stop(callback)
    }, options.timeout)
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.shimmer" id="apidoc.module.newrelic.shimmer">module newrelic.shimmer</a></h1>




    <h2>
        <a href="#apidoc.element.newrelic.shimmer.bootstrapInstrumentation" id="apidoc.element.newrelic.shimmer.bootstrapInstrumentation">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>bootstrapInstrumentation
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bootstrapInstrumentation(agent) {
  var globalsFilepath = path.join(__dirname, &#x27;instrumentation&#x27;, &#x27;core&#x27;, &#x27;globals.js&#x27;)
  instrument(agent, &#x27;globals&#x27;, globalsFilepath, global)

  Object.keys(CORE_INSTRUMENTATION).forEach(function cb_forEach(mojule) {
    var filename = CORE_INSTRUMENTATION[mojule]
    var filepath = path.join(__dirname, &#x27;instrumentation/core&#x27;, filename)
    var uninstrumented

    try {
      uninstrumented = require(mojule)
    } catch (err) {
      logger.trace(
        &#x27;Could not load core module %s got error %s&#x27;,
        mojule,
        err
      )
    }

    instrument(agent, filename, filepath, uninstrumented, mojule)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          &#x22;NEW_RELIC_APP_NAME. Not starting!&#x22;
logger.error(message)
throw new Error(message)
      }

      var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
      shimmer.patchModule(agent)
      shimmer.<span class="apidocCodeKeywordSpan">bootstrapInstrumentation</span>(agent)

      agent.start(function cb_start(error) {
if (!error) {
  return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
}

var errorMessage = &#x22;New Relic for Node.js halted startup due to an error:&#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.isWrapped" id="apidoc.element.newrelic.shimmer.isWrapped">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>isWrapped
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isWrapped(fn) {
  return !!(fn &#x26;&#x26; fn.__NR_original)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.patchModule" id="apidoc.element.newrelic.shimmer.patchModule">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>patchModule
        <span class="apidocSignatureSpan">(agent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function patchModule(agent) {
  logger.trace(&#x22;Wrapping module loader.&#x22;)
  var Module = require(&#x27;module&#x27;)

  shimmer.wrapMethod(Module, &#x27;Module&#x27;, &#x27;_load&#x27;, function cb_wrapMethod(load) {
    return function cls_wrapMethod(file) {
      return _postLoad(agent, load.apply(this, arguments), file)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            &#x22;Set app_name in your newrelic.js file or set environment variable\n&#x22; +
            &#x22;NEW_RELIC_APP_NAME. Not starting!&#x22;
  logger.error(message)
  throw new Error(message)
}

var shimmer = require(&#x27;./lib/shimmer.js&#x27;)
shimmer.<span class="apidocCodeKeywordSpan">patchModule</span>(agent)
shimmer.bootstrapInstrumentation(agent)

agent.start(function cb_start(error) {
  if (!error) {
    return logger.debug(&#x22;New Relic for Node.js is connected to New Relic.&#x22;)
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.reinstrument" id="apidoc.element.newrelic.shimmer.reinstrument">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>reinstrument
        <span class="apidocSignatureSpan">(agent, modulePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reinstrument(agent, modulePath) {
  return _postLoad(agent, require(modulePath), modulePath)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.unpatchModule" id="apidoc.element.newrelic.shimmer.unpatchModule">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unpatchModule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unpatchModule() {
  logger.trace(&#x22;Unwrapping to previous module loader.&#x22;)
  var Module = require(&#x27;module&#x27;)

  shimmer.unwrapMethod(Module, &#x27;Module&#x27;, &#x27;_load&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.unwrapAll" id="apidoc.element.newrelic.shimmer.unwrapAll">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unwrapAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unwrapAll() {
  instrumented.forEach(function cb_forEach(wrapper) {
    wrapper.__NR_unwrap()
  })
  instrumented = []
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.unwrapMethod" id="apidoc.element.newrelic.shimmer.unwrapMethod">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>unwrapMethod
        <span class="apidocSignatureSpan">(nodule, noduleName, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unwrapMethod(nodule, noduleName, method) {
  if (!noduleName) noduleName = &#x27;[unknown]&#x27;
  if (!method) return logger.debug(&#x22;Must include a method name to unwrap. &#x22; +
                                   &#x22;Called from: %s&#x22;, new Error().stack)

  var fqmn = noduleName + &#x27;.&#x27; + method

  if (!nodule) return logger.debug(&#x22;Can&#x27;t unwrap %s from nonexistent object.&#x22;,
                                   fqmn)
  var wrapped = nodule[method]

  // keep instrumented up to date
  var pos = instrumented.indexOf(wrapped)
  if (pos !== -1) instrumented.splice(pos, 1)

  if (!wrapped) return logger.debug(&#x22;%s not defined, so not unwrapping.&#x22;, fqmn)
  if (!wrapped.__NR_unwrap) return logger.debug(&#x22;%s isn&#x27;t unwrappable.&#x22;, fqmn)

  wrapped.__NR_unwrap()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
})
  },

  unpatchModule: function unpatchModule() {
logger.trace(&#x22;Unwrapping to previous module loader.&#x22;)
var Module = require(&#x27;module&#x27;)

shimmer.<span class="apidocCodeKeywordSpan">unwrapMethod</span>(Module, &#x27;Module&#x27;, &#x27;_load&#x27;)
  },

  bootstrapInstrumentation: function bootstrapInstrumentation(agent) {
var globalsFilepath = path.join(__dirname, &#x27;instrumentation&#x27;, &#x27;core&#x27;, &#x27;globals.js&#x27;)
instrument(agent, &#x27;globals&#x27;, globalsFilepath, global)

Object.keys(CORE_INSTRUMENTATION).forEach(function cb_forEach(mojule) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.wrapDeprecated" id="apidoc.element.newrelic.shimmer.wrapDeprecated">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>wrapDeprecated
        <span class="apidocSignatureSpan">(nodule, noduleName, property, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapDeprecated(nodule, noduleName, property, options) {
  if (!property) {
    logger.warn(new Error(), &#x22;Must include a function name to wrap. Called from:&#x22;)
    return
  }

  if (!noduleName) noduleName = &#x27;[unknown]&#x27;

  var fqmn = noduleName + &#x27;.&#x27; + property
  if (!nodule) {
    logger.debug(&#x22;Can&#x27;t wrap %s from nonexistent object.&#x22;, fqmn)
    return
  }

  var original = nodule[property]
  if (!original) {
    logger.trace(&#x22;%s not defined, so not wrapping.&#x22;, fqmn)
    return
  }

  delete nodule[property]

  var descriptor = {
    configurable: true,
    enumerable: true
  }
  if (options.get) descriptor.get = options.get
  if (options.set) descriptor.set = options.set
  Object.defineProperty(nodule, property, descriptor)
  logger.trace(&#x22;Instrumented %s.&#x22;, fqmn)

  if (shimmer.debug) {
    instrumented.push({
      __NR_unwrap: function unwrapDeprecated() {
        delete nodule[property]
        nodule[property] = original
      }
    })
  }

  return original
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.shimmer.wrapMethod" id="apidoc.element.newrelic.shimmer.wrapMethod">
        function <span class="apidocSignatureSpan">newrelic.shimmer.</span>wrapMethod
        <span class="apidocSignatureSpan">(nodule, noduleName, methods, wrapper)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapMethod(nodule, noduleName, methods, wrapper) {
  if (!methods) {
    return logger.warn(new Error(),
                       &#x22;Must include a method name to wrap. Called from:&#x22;)
  }

  if (!noduleName) noduleName = &#x27;[unknown]&#x27;
  if (!Array.isArray(methods)) methods = [methods]

  methods.forEach(function cb_forEach(method) {
    var fqmn = noduleName + &#x27;.&#x27; + method

    if (!nodule) return logger.debug(&#x22;Can&#x27;t wrap %s from nonexistent object.&#x22;,
                                     fqmn)
    if (!wrapper) return logger.debug(&#x22;Can&#x27;t wrap %s without a wrapper generator.&#x22;,
                                      fqmn)

    var original = nodule[method]

    if (!original) return logger.trace(&#x22;%s not defined, so not wrapping.&#x22;, fqmn)
    if (original.__NR_unwrap) return logger.debug(&#x22;%s already wrapped by agent.&#x22;, fqmn)

    var wrapped = wrapper(original, method)
    wrapped.__NR_original = original
    wrapped.__NR_unwrap = function __NR_unwrap() {
      nodule[method] = original
      logger.trace(&#x22;Removed instrumentation from %s.&#x22;, fqmn)
    }

    nodule[method] = wrapped
    if (shimmer.debug) instrumented.push(wrapped)
    logger.trace(&#x22;Instrumented %s.&#x22;, fqmn)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Patch the module.load function so that we see modules loading and
 * have an opportunity to patch them with instrumentation.
 */
patchModule: function patchModule(agent) {
  logger.trace(&#x22;Wrapping module loader.&#x22;)
  var Module = require(&#x27;module&#x27;)

  shimmer.<span class="apidocCodeKeywordSpan">wrapMethod</span>(Module, &#x27;Module&#x27;, &#x27;_load&#x27;, function cb_wrapMethod
(load) {
    return function cls_wrapMethod(file) {
      return _postLoad(agent, load.apply(this, arguments), file)
    }
  })
},

unpatchModule: function unpatchModule() {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.stub_api" id="apidoc.module.newrelic.stub_api">module newrelic.stub_api</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.stub_api.stub_api" id="apidoc.element.newrelic.stub_api.stub_api">
        function <span class="apidocSignatureSpan">newrelic.</span>stub_api
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stub() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.stub_api.prototype" id="apidoc.module.newrelic.stub_api.prototype">module newrelic.stub_api.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.addCustomParameter" id="apidoc.element.newrelic.stub_api.prototype.addCustomParameter">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addCustomParameter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addCustomParameter() {logger.debug(&#x27;Not calling addCustomParameter because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Programmatic version of `rules.ignore` above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. The pattern is mandatory.

### Other API calls

#### newrelic.<span class="apidocCodeKeywordSpan">addCustomParameter</span>(name, value)

Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

#### newrelic.addCustomParameters(params)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.addCustomParameters" id="apidoc.element.newrelic.stub_api.prototype.addCustomParameters">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addCustomParameters
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addCustomParameters() {logger.debug(&#x27;Not calling addCustomParameters because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### newrelic.addCustomParameter(name, value)

Set a custom parameter value to be attached to a transaction trace and/or error
in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

#### newrelic.<span class="apidocCodeKeywordSpan">addCustomParameters</span>(params)

Set multiple custom parameter values to be attached to a transaction trace and/or
error in the New Relic UI. This must be called within the context of a transaction,
so it has a place to set the custom parameters.

Example of setting multiple custom parameters at once:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.addIgnoringRule" id="apidoc.element.newrelic.stub_api.prototype.addIgnoringRule">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addIgnoringRule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addIgnoringRule() {logger.debug(&#x27;Not calling addIgnoringRule because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### newrelic.addNamingRule(pattern, name)

Programmatic version of `rules.name` above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. Both parameters are mandatory.

#### newrelic.<span class="apidocCodeKeywordSpan">addIgnoringRule</span>(pattern)

Programmatic version of `rules.ignore` above. Ignoring rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. The pattern is mandatory.

### Other API calls
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.addNamingRule" id="apidoc.element.newrelic.stub_api.prototype.addNamingRule">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>addNamingRule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addNamingRule() {logger.debug(&#x27;Not calling addNamingRule because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Can also be set via the environment variable `NEW_RELIC_IGNORING_RULES`, with
multiple rules passed in as a list of comma-delimited patterns:
`NEW_RELIC_IGNORING_RULES=&#x27;^/socket\.io/\*/xhr-polling,ignore_me&#x27;` Note that
currently there is no way to escape commas in patterns.

### API for adding naming and ignoring rules

#### newrelic.<span class="apidocCodeKeywordSpan">addNamingRule</span>(pattern, name)

Programmatic version of `rules.name` above. Naming rules can not be removed
until the Node process is restarted. They can also be added via the module&#x27;s
configuration. Both parameters are mandatory.

#### newrelic.addIgnoringRule(pattern)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.createBackgroundTransaction" id="apidoc.element.newrelic.stub_api.prototype.createBackgroundTransaction">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createBackgroundTransaction
        <span class="apidocSignatureSpan">(name, group, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBackgroundTransaction(name, group, callback) {
  logger.debug(&#x27;Not calling createBackgroundTransaction because New Relic is disabled.&#x27;)
  return (callback === undefined) ? group : callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
independent transaction and any calls within the `handle` will be bound to the
new web transaction.

Custom transactions **must** be ended manually by calling `endTransaction()`.
Timing for custom transaction starts from when the returned wrapped function is
called until `endTransaction()` is called.

#### newrelic.<span class="apidocCodeKeywordSpan">createBackgroundTransaction</span>(name, [group], handle)

`name` is the name of the job. It should be pretty static, and not include job
ids or anything very specific to that run of the job. `group` is optional, and
allows you to group types of jobs together. This should follow similar rules as
the `name`. `handle` is a function that encompases your background job. Both
custom and auto instrumentation will be captured as part of the transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.createTracer" id="apidoc.element.newrelic.stub_api.prototype.createTracer">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createTracer
        <span class="apidocSignatureSpan">(name, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTracer(name, callback) {
  logger.debug(&#x27;Not calling createTracer because New Relic is disabled.&#x27;)
  return callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
called until `endTransaction()` is called.

#### newrelic.endTransaction()

This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.

#### newrelic.<span class="apidocCodeKeywordSpan">createTracer</span>(name, handle)

`name` is the name of the tracer. It will show up as a segment in your
transaction traces and create its own metric. `handle` is the function to be
bound to the tracer.

Timing is from when `createTracer` is called until the `handle` done executing.
This should be called inside of a transaction to get data. If it is called
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.createWebTransaction" id="apidoc.element.newrelic.stub_api.prototype.createWebTransaction">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>createWebTransaction
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createWebTransaction(url, callback) {
  logger.debug(&#x27;Not calling createWebTransaction because New Relic is disabled.&#x27;)
  return callback
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
varieties of socket servers, and background jobs. These are things that the
agent can&#x27;t automatically instrument because without your knowledge of your
application, the agent can&#x27;t tell when they should begin and end.

Read more at:
https://docs.newrelic.com/docs/agents/nodejs-agent/supported-features/nodejs-custom-instrumentation

#### newrelic.<span class="apidocCodeKeywordSpan">createWebTransaction</span>(url, handle)

`url` is the name of the web transaction. It should be pretty static, not
including anything like user ids or any other data that is very specific to the
request. `handle` is the function you&#x27;d like to wrap in the web transaction.
Both custom and auto instrumentation will be captured as part of the
transaction.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.endTransaction" id="apidoc.element.newrelic.stub_api.prototype.endTransaction">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>endTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function endTransaction() {logger.debug(&#x27;Not calling endTransaction because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
transaction and any calls within the `handle` will be bound to the new,
independent background transaction.

Custom transactions **must** be ended manually by calling `endTransaction()`.
Timing for custom transaction starts from when the returned wrapped function is
called until `endTransaction()` is called.

#### newrelic.<span class="apidocCodeKeywordSpan">endTransaction</span>()

This takes no arguments and must be called to end any custom transaction. It
will detect what kind of transaction was active and end it.

#### newrelic.createTracer(name, handle)

`name` is the name of the tracer. It will show up as a segment in your
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.getBrowserTimingHeader" id="apidoc.element.newrelic.stub_api.prototype.getBrowserTimingHeader">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>getBrowserTimingHeader
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getBrowserTimingHeader() {
  logger.debug(&#x27;Not calling getBrowserTimingHeader because New Relic is disabled.&#x27;)
  return &#x27;&#x27;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
times.

Headers must be manually injected, but no extra configuration is necessary to
enable browser timings.

### Basics

- Insert the result of `newrelic.<span class="apidocCodeKeywordSpan">getBrowserTimingHeader</span>()`
into your html page.
- The browser timing headers should be placed in the beginning of your `&#x3c;head&#x3e;` tag.
  - As an exception to the above, for maximum IE compatability, the results of `getBrowserTimingHeader()`
should be placed *after* any `X-UA-COMPATIBLE HTTP-EQUIV` meta tags.
- Do *not* cache the header, call it once for every request.

### Example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.incrementMetric" id="apidoc.element.newrelic.stub_api.prototype.incrementMetric">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>incrementMetric
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function incrementMetric() {logger.debug(&#x27;Not calling incrementMetric because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`value` is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If `value` is
an object, it must include keys for `count`, `total`, `min`, `max`, and
`sumOfSquares`.

#### newrelic.<span class="apidocCodeKeywordSpan">incrementMetric</span>(name[, amount])

`name` is the metric name to record, it must be a string that beings with
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`amount` is optional, but must be an integer if provided.  `amount` is
the number of times to increment the metrics `count`, it defaults to 1.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.noticeError" id="apidoc.element.newrelic.stub_api.prototype.noticeError">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>noticeError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noticeError() {logger.debug(&#x27;Not calling noticeError because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you **must**
pass `false` as the parameter – in this case `null` or `undefined` will be
ignored.

#### newrelic.<span class="apidocCodeKeywordSpan">noticeError</span>(error, customParameters)

If your app is doing its own error handling with domains or try/catch clauses,
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.recordCustomEvent" id="apidoc.element.newrelic.stub_api.prototype.recordCustomEvent">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>recordCustomEvent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordCustomEvent() {logger.debug(&#x27;Not calling recordCustomEvent because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

/**
 * Custom Insights Events
 *
 * Custom insights events are JSON object that are sent to New Relic
 * Insights. You can tell the agent to send your custom events via the
 * `newrelic.<span class="apidocCodeKeywordSpan">recordCustomEvent</span>()` API. These events are sampled once the max
 * reservoir size is reached. You can tune this setting below.
 *
 * Read more here: http://newrelic.com/insights
 */
custom_insights_events: {
  /**
   * If this is disabled, the agent does not collect, nor try to send, custom
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.recordMetric" id="apidoc.element.newrelic.stub_api.prototype.recordMetric">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>recordMetric
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function recordMetric() {logger.debug(&#x27;Not calling recordMetric because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
transaction traces and create its own metric. `handle` is the function to be
bound to the tracer.

Timing is from when `createTracer` is called until the `handle` done executing.
This should be called inside of a transaction to get data. If it is called
outside of a transaction it will just pass through.

#### newrelic.<span class="apidocCodeKeywordSpan">recordMetric</span>(name, value)

`name` is the metric name to record, it must be a string that begins with
`Custom/` typically followed by segments for `category` and `label`.
(eg.`Custom/my_category/my_label`).
`value` is either a numerical value to associate with the metric sample,
or an object representing multiple samples for the metric. If `value` is
an object, it must include keys for `count`, `total`, `min`, `max`, and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.setControllerName" id="apidoc.element.newrelic.stub_api.prototype.setControllerName">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setControllerName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setControllerName() {logger.debug(&#x27;Not calling setControllerName because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.

Explicitly calling `newrelic.setTransactionName()` will override any names set
by Express, Restify or Hapi routes. Calls to `newrelic.setTransactionName()` and
`newrelic.<span class="apidocCodeKeywordSpan">setControllerName</span>()` will overwrite each other. The last call made
before the request ends wins.

**VERY IMPORTANT NOTE:** Do not include highly variable information like GUIDs,
numerical IDs, or timestamps in the request names you create. If your request
is slow enough to generate a transaction trace, that trace will contain the
original URL. If you enable parameter capture, the parameters will also be
attached to the trace. The request names are used to group requests for New
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.setIgnoreTransaction" id="apidoc.element.newrelic.stub_api.prototype.setIgnoreTransaction">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setIgnoreTransaction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setIgnoreTransaction() {logger.debug(&#x27;Not calling setIgnoreTransaction because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Example of setting multiple custom parameters at once:

```javascript
newrelic.addCustomParameters({test: &#x27;value&#x27;, test2: &#x27;value2&#x27;});
```

#### newrelic.<span class="apidocCodeKeywordSpan">setIgnoreTransaction</span>(ignored)

Tell the module explicitly whether or not a given request should be ignored.
Allows you to explicitly filter out long-polling routes or requests you know
are going to be time-consuming in an uninteresting way, and also allows you
to gather metrics for requests that would otherwise be ignored. Note that
to prevent a transaction from being ignored with this function, you **must**
pass `false` as the parameter – in this case `null` or `undefined` will be
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.setTransactionName" id="apidoc.element.newrelic.stub_api.prototype.setTransactionName">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>setTransactionName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTransactionName() {logger.debug(&#x27;Not calling setTransactionName because New Relic is disabled.&#x27;);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

is all you need. Please note that you still need to ensure that loading the New
Relic module is the first thing your application does, as it needs to bootstrap
itself before the rest of your application loads, but you can safely require
the module from multiple modules in your application – it will only initialize
itself once.

#### newrelic.<span class="apidocCodeKeywordSpan">setTransactionName</span>(name)

Name the current request. You can call this function anywhere within the
context of an HTTP request handler, at any time after handling of the request
has started, but before the request has finished. A good rule of thumb is that
if the request and response objects are in scope, you can set the name.

Explicitly calling `newrelic.setTransactionName()` will override any names set
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.stub_api.prototype.shutdown" id="apidoc.element.newrelic.stub_api.prototype.shutdown">
        function <span class="apidocSignatureSpan">newrelic.stub_api.prototype.</span>shutdown
        <span class="apidocSignatureSpan">(options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shutdown(options, cb) {
  logger.debug(&#x27;Not calling shutdown because New Relic is disabled.&#x27;)

  var callback = cb
  if (!callback) {
    if (typeof options === &#x27;function&#x27;) {
      callback = options
    } else {
      callback = new Function()
    }
  }

  process.nextTick(callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
but you want all of the information about how many errors are coming out of the
app to be centrally managed, use this call. Unlike most of the calls here, this
function can be used outside of route handlers, but will have additional
context if called from within transaction scope. If custom parameters are
passed in on an object literal, they will be passed back to New Relic for
display.

#### newrelic.<span class="apidocCodeKeywordSpan">shutdown</span>([options], callback)

Use this method to gracefully shut down the agent.  When called with
`options.collectPendingData` set to true, the agent will send any pending data to
the New Relic servers before shutting down.  This is useful when you want to shut down
the Node process and make sure that all transactions and/or errors are captured by
New Relic.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.system_info" id="apidoc.module.newrelic.system_info">module newrelic.system_info</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.system_info.system_info" id="apidoc.element.newrelic.system_info.system_info">
        function <span class="apidocSignatureSpan">newrelic.</span>system_info
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fetchSystemInfo(agent, callback) {
  var config = agent.config
  var systemInfo = {
    processorArch: os.arch()
  }

  var utilizationConfig = {}
  if (config.utilization) {
    var configProcessors = config.utilization.logical_processors
    var configRam = config.utilization.total_ram_mib
    var configHostname = config.utilization.billing_hostname

    if (configProcessors) {
      var parsedConfigProcessors = parseFloat(configProcessors, 10)
      if (!isNaN(parsedConfigProcessors) &#x26;&#x26; isInteger(parsedConfigProcessors)) {
        utilizationConfig.logical_processors = parsedConfigProcessors
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.logical_processors, expected a number&#x27;,
          configProcessors
        )
      }
    }

    if (configRam) {
      var parsedConfigRam = parseFloat(configRam, 10)
      if (!isNaN(parsedConfigRam) &#x26;&#x26; isInteger(parsedConfigRam)) {
        utilizationConfig.total_ram_mib = parsedConfigRam
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.total_ram_mib, expected a number&#x27;,
          configRam
        )
      }
    }

    if (configHostname) {
      if (typeof configHostname === &#x27;string&#x27;) {
        utilizationConfig.hostname = configHostname
      } else {
        logger.info(
          &#x27;%s supplied in config for utilization.Hostname, expected a string&#x27;,
          configHostname
        )
      }
    }

    if (Object.keys(utilizationConfig).length &#x3e; 0) {
      systemInfo.config = utilizationConfig
    }
  }

  var tasksDone = 0
  var numTasks = 5
  function finishedResponse() {
    if (++tasksDone === numTasks) return callback(systemInfo)
  }

  module.exports._getProcessorStats(function getProcessCB(processorStats) {
    systemInfo.packages = processorStats.packages
    systemInfo.logicalProcessors = processorStats.logical
    systemInfo.cores = processorStats.cores
    finishedResponse()
  })
  module.exports._getMemoryStats(function getMemCB(memory) {
    systemInfo.memory = memory
    finishedResponse()
  })
  getKernelVersion(function getVersionCB(kernelVersion) {
    systemInfo.kernelVersion = kernelVersion
    finishedResponse()
  })
  module.exports._getDockerContainerId(agent, function getContainerId(containerId) {
    if (containerId) {
      systemInfo.docker = {
        id: containerId
      }
    }
    finishedResponse()
  })
  fetchAWSInfo(agent, function getAWSInfo(aws) {
    systemInfo.aws = aws
    finishedResponse()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.system_info._getDockerContainerId" id="apidoc.element.newrelic.system_info._getDockerContainerId">
        function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getDockerContainerId
        <span class="apidocSignatureSpan">(agent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDockerContainerId(agent, callback) {
  if (!platform.match(/linux/i)) {
    logger.debug(&#x27;Platform is not a flavor of linux, omitting docker info&#x27;)
    callback(null)
  } else {
    readProc(&#x27;/proc/self/cgroup&#x27;, function getCGroup(data) {
      if (!data) callback(null)
      else callback(parseDockerInfo(agent, data))
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  systemInfo.memory = memory
  finishedResponse()
})
getKernelVersion(function getVersionCB(kernelVersion) {
  systemInfo.kernelVersion = kernelVersion
  finishedResponse()
})
module.exports.<span class="apidocCodeKeywordSpan">_getDockerContainerId</span>(agent, function getContainerId(containerId) {
  if (containerId) {
    systemInfo.docker = {
      id: containerId
    }
  }
  finishedResponse()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.system_info._getMemoryStats" id="apidoc.element.newrelic.system_info._getMemoryStats">
        function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getMemoryStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMemoryStats(callback) {
  if (platform.match(/darwin/i)) {
    getSysctlValue([&#x27;hw.memsize&#x27;], function getMem(memory) {
      callback(parseInt(memory, 10) / (1024 * 1024))
    })
  } else if (platform.match(/bsd/i)) {
    getSysctlValue([&#x27;hw.realmem&#x27;], function getMem(memory) {
      callback(parseInt(memory, 10) / (1024 * 1024))
    })
  } else if (platform.match(/linux/i)) {
    readProc(&#x27;/proc/meminfo&#x27;, function parseProc(data) {
      callback(parseMemInfo(data))
    })
  } else {
    logger.debug(&#x27;Unknown platform: &#x27; + platform + &#x27;, could not retrieve memory info&#x27;)
    callback(null)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

module.exports._getProcessorStats(function getProcessCB(processorStats) {
  systemInfo.packages = processorStats.packages
  systemInfo.logicalProcessors = processorStats.logical
  systemInfo.cores = processorStats.cores
  finishedResponse()
})
module.exports.<span class="apidocCodeKeywordSpan">_getMemoryStats</span>(function getMemCB(memory) {
  systemInfo.memory = memory
  finishedResponse()
})
getKernelVersion(function getVersionCB(kernelVersion) {
  systemInfo.kernelVersion = kernelVersion
  finishedResponse()
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.system_info._getProcessorStats" id="apidoc.element.newrelic.system_info._getProcessorStats">
        function <span class="apidocSignatureSpan">newrelic.system_info.</span>_getProcessorStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getProcessorStats(callback) {
  var processorStats = {
    logical: null,
    cores: null,
    packages: null
  }

  if (platform.match(/darwin/i)) {
    getSysctlValue([&#x27;hw.packages&#x27;], function getPackages(packages) {
      getSysctlValue([&#x27;hw.physicalcpu_max&#x27;, &#x27;hw.physicalcpu&#x27;],
      function getCores(cores) {
        getSysctlValue([&#x27;hw.logicalcpu_max&#x27;, &#x27;hw.logicalcpu&#x27;, &#x27;hw.ncpu&#x27;],
        function getLogicalCpu(logical) {
          processorStats.logical = parseFloat(logical, 10)
          processorStats.cores = parseFloat(cores, 10)
          processorStats.packages = parseFloat(packages, 10)

          for (var key in processorStats) {
            if (!processorStats[key] || !isInteger(processorStats[key])) {
              processorStats[key] = null
            }
          }

          callback(processorStats)
        })
      })
    })
  } else if (platform.match(/bsd/i)) {
    getSysctlValue([&#x27;hw.ncpu&#x27;], function getLogicalCpu(logical) {
      processorStats.logical = logical
      callback(processorStats)
    })
  } else if (platform.match(/linux/i)) {
    readProc(&#x27;/proc/cpuinfo&#x27;, function parseProc(data) {
      callback(parseCpuInfo(data))
    })
  } else {
    logger.debug(&#x27;Unknown platform: &#x27; + platform + &#x27;, could not retrieve processor info&#x27;)
    callback(processorStats)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var tasksDone = 0
var numTasks = 5
function finishedResponse() {
  if (++tasksDone === numTasks) return callback(systemInfo)
}

module.exports.<span class="apidocCodeKeywordSpan">_getProcessorStats</span>(function getProcessCB(processorStats) {
  systemInfo.packages = processorStats.packages
  systemInfo.logicalProcessors = processorStats.logical
  systemInfo.cores = processorStats.cores
  finishedResponse()
})
module.exports._getMemoryStats(function getMemCB(memory) {
  systemInfo.memory = memory
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.timer" id="apidoc.module.newrelic.timer">module newrelic.timer</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.timer.timer" id="apidoc.element.newrelic.timer.timer">
        function <span class="apidocSignatureSpan">newrelic.</span>timer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Timer() {
  this.state = PENDING
  this.touched = false
  this.duration = null
  this.hrDuration = null
  this.hrstart = null
  this.durationInMillis = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.timer.prototype" id="apidoc.module.newrelic.timer.prototype">module newrelic.timer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.begin" id="apidoc.element.newrelic.timer.prototype.begin">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>begin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function begin() {
  if (this.state &#x3e; PENDING) return

  this.start = Date.now()
  // need to put a guard on this for compatibility with Node &#x3c; 0.8
  if (process.hrtime) this.hrstart = process.hrtime()
  this.state = RUNNING
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
}

function checkEvents(agent) {
return function eventSampler() {
  var timer = new Timer()
  timer.<span class="apidocCodeKeywordSpan">begin</span>()
  setTimeout(recordQueueTime.bind(null, agent, timer), 0)
}
}

function getCpuSample(lastSample) {
try {
  return process.cpuUsage(lastSample)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.end" id="apidoc.element.newrelic.timer.prototype.end">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end() {
  if (this.state &#x3e; RUNNING) return
  if (this.state === PENDING) this.begin()
  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
  this.touched = true
  this.duration = Date.now() - this.start
  this.state = STOPPED
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var tracer = this.agent.tracer
var tx = tracer.getTransaction()

if (tx) {
  if (tx.webSegment) {
    tx.setName(tx.url, 0)
    tx.webSegment.markAsWeb(tx.url)
    tx.webSegment.<span class="apidocCodeKeywordSpan">end</span>()
  } else if (tx.bgSegment) {
    tx.bgSegment.end()
  }
  logger.debug(&#x27;ending transaction with id: %s and name: %s&#x27;, tx.id, tx.name)
  tx.end()
} else {
  logger.debug(&#x27;endTransaction() called while not in a transaction.&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.endsAfter" id="apidoc.element.newrelic.timer.prototype.endsAfter">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>endsAfter
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(other) {
  return (this.getDurationInMillis() + this.start) &#x3e;
    (other.getDurationInMillis() + other.start)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.getDurationInMillis" id="apidoc.element.newrelic.timer.prototype.getDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>getDurationInMillis
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDurationInMillis() {
  if (this.state === PENDING) return 0

  // only set by setDurationInMillis
  if (this.durationInMillis !== null &#x26;&#x26; this.durationInMillis &#x3e;= 0) {
    return this.durationInMillis
  }

  // prioritize .end() and .touch()
  if (this.hrDuration) {
    return hrToMillis(this.hrDuration)
  }

  if (this.duration) {
    return this.duration
  }

  if (process.hrtime) {
    return hrToMillis(process.hrtime(this.hrstart))
  }

  return Date.now() - this.start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* If we&#x27;re in an unnamed transaction, add a friendly warning this is to
 * avoid people going crazy, trying to figure out why browser monitoring is
 * not working when they&#x27;re missing a transaction name.
 */
if (!name) return _gracefail(3)

var time = trans.timer.<span class="apidocCodeKeywordSpan">getDurationInMillis</span>()

/*
 * Only the first 13 chars of the license should be used for hashing with
 * the transaction name.
 */
var key = config.license_key.substr(0, 13)
var appid = config.application_id
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.hasEnd" id="apidoc.element.newrelic.timer.prototype.hasEnd">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>hasEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasEnd() {
  return !!this.hrDuration
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.isActive" id="apidoc.element.newrelic.timer.prototype.isActive">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>isActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isActive() {
  return this.state &#x3c; STOPPED
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.isRunning" id="apidoc.element.newrelic.timer.prototype.isRunning">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>isRunning
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRunning() {
  return this.state === RUNNING
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.overwriteDurationInMillis" id="apidoc.element.newrelic.timer.prototype.overwriteDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>overwriteDurationInMillis
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function overwriteDurationInMillis(duration) {
  this.touched = true
  this.durationInMillis = duration
  this.state = STOPPED
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.setDurationInMillis" id="apidoc.element.newrelic.timer.prototype.setDurationInMillis">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>setDurationInMillis
        <span class="apidocSignatureSpan">(duration, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setDurationInMillis(duration, start) {
  if (this.state &#x3e; RUNNING) return
  if (this.state === PENDING)
  if (!start &#x26;&#x26; start !== 0) this.begin()

  this.state = STOPPED
  this.durationInMillis = duration

  // this assignment is incorrect, process.hrtime doesn&#x27;t time from epoch, which
  // is the assumption being made here.  since hrstart isn&#x27;t used
  // anywhere except to calculate duration, and we are setting duration
  // this is fine.
  this.hrstart = [Math.floor(start / 1e3), start % 1e3 * 1e6]
  this.start = start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.softEnd" id="apidoc.element.newrelic.timer.prototype.softEnd">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>softEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function softEnd() {
  if (this.state &#x3e; RUNNING) return false
  if (this.state === PENDING) this.begin()

  this.state = STOPPED

  if (this.touched) return false
  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
  this.touched = true
  this.duration = Date.now() - this.start
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.startedRelativeTo" id="apidoc.element.newrelic.timer.prototype.startedRelativeTo">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>startedRelativeTo
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function startedRelativeTo(other) {
  if (this.hrstart &#x26;&#x26; other.hrstart &#x26;&#x26; process.hrtime) {
    var s = this.hrstart[0] - other.hrstart[0]
    var ns = this.hrstart[1] - other.hrstart[1]


    return hrToMillis([s, ns])
  }

  return this.start - other.start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.toRange" id="apidoc.element.newrelic.timer.prototype.toRange">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>toRange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toRange() {
  return [this.start, this.start + this.getDurationInMillis()]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.timer.prototype.touch" id="apidoc.element.newrelic.timer.prototype.touch">
        function <span class="apidocSignatureSpan">newrelic.timer.prototype.</span>touch
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function touch() {
  this.touched = true
  if (this.state &#x3e; RUNNING) return
  if (this.state === PENDING) this.begin()

  if (process.hrtime) this.hrDuration = process.hrtime(this.hrstart)
  this.duration = Date.now() - this.start
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.state === PENDING) return 0

// only set by setDurationInMillis
if (this.durationInMillis !== null &#x26;&#x26; this.durationInMillis &#x3e;= 0) {
  return this.durationInMillis
}

// prioritize .end() and .<span class="apidocCodeKeywordSpan">touch</span>()
if (this.hrDuration) {
  return hrToMillis(this.hrDuration)
}

if (this.duration) {
  return this.duration
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.newrelic.uninstrumented" id="apidoc.module.newrelic.uninstrumented">module newrelic.uninstrumented</a></h1>


    <h2>
        <a href="#apidoc.element.newrelic.uninstrumented.check" id="apidoc.element.newrelic.uninstrumented.check">
        function <span class="apidocSignatureSpan">newrelic.uninstrumented.</span>check
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function check() {
  for (var filename in require.cache) {
    if (!require.cache.hasOwnProperty(filename)) {
      continue
    }
    var name = moduleNameFromFilename(filename)

    if (INSTRUMENTATIONS.indexOf(name) !== -1) {
      uninstrumented.push({name: name, filename: filename})
    }
  }

  logUninstrumented()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// just to make clear what&#x27;s going on
var TO_MILLIS = 1e3
var FROM_MILLIS = 1e-3

// Check for already loaded modules and warn about them. This must be executed
// only once, at the first require of this file, or else we have problems in
// unit tests.
uninstrumented.<span class="apidocCodeKeywordSpan">check</span>()

/**
* There&#x27;s a lot of stuff in this constructor, due to Agent acting as the
* orchestrator for New Relic within instrumented applications.
*
* This constructor can throw if, for some reason, the configuration isn&#x27;t
* available. Don&#x27;t try to recover here, because without configuration the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.newrelic.uninstrumented.createMetrics" id="apidoc.element.newrelic.uninstrumented.createMetrics">
        function <span class="apidocSignatureSpan">newrelic.uninstrumented.</span>createMetrics
        <span class="apidocSignatureSpan">(metrics)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMetrics(metrics) {
  if (uninstrumented.length &#x3e; 0) {
    metrics.getOrCreateMetric(NAMES.SUPPORTABILITY.UNINSTRUMENTED).incrementCallCount()
  }

  uninstrumented.forEach(function addMetrics(module) {
    metrics.getOrCreateMetric(
      NAMES.SUPPORTABILITY.UNINSTRUMENTED + &#x27;/&#x27; + module.name
    ).incrementCallCount()
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (this.config.debug.supportability) {
  this.metrics.merge(this.config.debug.supportability)
}

// Send uninstrumented supportability metrics every harvest cycle
uninstrumented.<span class="apidocCodeKeywordSpan">createMetrics</span>(this.metrics)

this._processCustomEvents()
this._processErrorEvents()

// wait to check until all the standard stuff has been added
if (this.metrics.toJSON().length &#x3c; 1) {
  logger.debug(&#x22;No metrics to send.&#x22;)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
